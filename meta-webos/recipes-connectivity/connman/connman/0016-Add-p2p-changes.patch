From f2814b30bdca4ebcd4054a5b324ec5a2aea01538 Mon Sep 17 00:00:00 2001
From: "penikelapati.kumar" <penikelapati.kumar@lge.com>
Date: Wed, 27 Jan 2021 17:23:22 +0530
Subject: [PATCH] Add p2p changes

:Release Notes:
Add p2p changes to support additional support.

:Detailed Notes:
Added code to support all methods realted to p2p go, p2p group
p2p discovery service.

:Testing Performed:
Build successfully.
Ethrenet/wifi connection successfully.

:QA Notes:
N/A

:Issues Addressed:
[PLAT-131728] Integrating and verification p2p/getstate, p2p/setstate
              and p2p/setgointent Luna API

Upstream-Status: Inappropriate[webos specific]
---
 Makefile.am               |    8 +-
 gsupplicant/dbus.c        |   94 +-
 gsupplicant/dbus.h        |   10 +
 gsupplicant/gsupplicant.h |  337 +-
 gsupplicant/supplicant.c  | 7193 ++++++++++++++++++++++++++++--------
 include/dbus.h            |    3 +
 include/device.h          |    2 +
 include/group.h           |   74 +
 include/network.h         |    3 +
 include/peer.h            |   22 +-
 include/sd.h              |   25 +
 include/technology.h      |   38 +
 include/types.h           |   45 +
 plugins/wifi.c            | 7204 ++++++++++++++++++++++++-------------
 src/connman.h             |   27 +-
 src/dbus.c                |    5 +
 src/device.c              |   76 +
 src/dhcp.c                |   10 +
 src/group.c               |  799 ++++
 src/ippool.c              |   68 +-
 src/manager.c             |   78 +-
 src/network.c             |   12 +
 src/p2pgo.c               |  284 ++
 src/peer.c                |  514 ++-
 src/peer_service.c        |   23 +-
 src/sd.c                  |  382 ++
 src/service.c             |    5 +
 src/storage.c             |  139 +-
 src/technology.c          |  812 ++++-
 src/util.c                |  105 +
 30 files changed, 14314 insertions(+), 4083 deletions(-)
 create mode 100644 include/group.h
 create mode 100644 include/sd.h
 create mode 100644 include/types.h
 create mode 100644 src/group.c
 create mode 100644 src/p2pgo.c
 create mode 100644 src/sd.c

diff --git a/Makefile.am b/Makefile.am
index 5971ca9b..a9ae37dd 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -11,8 +11,8 @@ include_HEADERS = include/log.h include/plugin.h \
 			include/device.h include/network.h include/inet.h \
 			include/storage.h include/provision.h \
 			include/session.h include/ipaddress.h include/agent.h \
-			include/inotify.h include/peer.h include/machine.h \
-			include/acd.h include/tethering.h
+			include/inotify.h include/peer.h include/sd.h include/types.h \
+			include/machine.h include/group.h include/acd.h include/tethering.h
 
 nodist_include_HEADERS = include/version.h
 
@@ -128,9 +128,9 @@ src_connmand_SOURCES = $(gdhcp_sources) $(gweb_sources) $(stats_sources) \
 			src/technology.c src/counter.c src/ntp.c \
 			src/session.c src/tethering.c src/wpad.c src/wispr.c \
 			src/6to4.c src/ippool.c src/bridge.c src/nat.c \
-			src/ipaddress.c src/inotify.c src/ipv6pd.c src/peer.c \
+			src/ipaddress.c src/inotify.c src/ipv6pd.c src/sd.c src/peer.c \
 			src/peer_service.c src/machine.c src/util.c \
-			src/acd.c
+			src/p2pgo.c src/group.c src/acd.c
 
 if INTERNAL_DNS_BACKEND
 src_connmand_SOURCES += src/dnsproxy.c
diff --git a/gsupplicant/dbus.c b/gsupplicant/dbus.c
index 2957979a..c0347374 100644
--- a/gsupplicant/dbus.c
+++ b/gsupplicant/dbus.c
@@ -66,12 +66,14 @@ struct property_call_data {
 	DBusPendingCall *pending_call;
 	supplicant_dbus_property_function function;
 	void *user_data;
+	char *interface_path;
 };
 
 static void property_call_free(void *pointer)
 {
 	struct property_call_data *property_call = pointer;
 	property_calls = g_slist_remove(property_calls, property_call);
+	g_free(property_call->interface_path);
 	g_free(property_call);
 }
 
@@ -239,6 +241,7 @@ int supplicant_dbus_property_get_all(const char *path, const char *interface,
 	property_call->pending_call = call;
 	property_call->function = function;
 	property_call->user_data = user_data;
+	property_call->interface_path = NULL;
 
 	property_calls = g_slist_prepend(property_calls, property_call);
 
@@ -270,7 +273,7 @@ static void property_get_reply(DBusPendingCall *call, void *user_data)
 		dbus_message_iter_recurse(&iter, &variant);
 
 		if (property_call->function)
-			property_call->function(NULL, &variant,
+			property_call->function(property_call->interface_path, &variant,
 						property_call->user_data);
 	}
 done:
@@ -328,6 +331,7 @@ int supplicant_dbus_property_get(const char *path, const char *interface,
 	property_call->pending_call = call;
 	property_call->function = function;
 	property_call->user_data = user_data;
+	property_call->interface_path = g_strdup(path);
 
 	property_calls = g_slist_prepend(property_calls, property_call);
 
@@ -422,6 +426,7 @@ int supplicant_dbus_property_set(const char *path, const char *interface,
 	property_call->pending_call = call;
 	property_call->function = function;
 	property_call->user_data = user_data;
+	property_call->interface_path = NULL;
 
 	property_calls = g_slist_prepend(property_calls, property_call);
 
@@ -648,3 +653,90 @@ void supplicant_dbus_property_append_array(DBusMessageIter *iter,
 
 	dbus_message_iter_close_container(iter, &value);
 }
+
+bool dbus_message_get_args_from_array_of_sv(DBusMessageIter *iter, int first_arg_type, ...)
+{
+	va_list var_args;
+	bool result = false;
+	int arg_type = first_arg_type;
+
+	va_start(var_args, first_arg_type);
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
+		goto cleanup;
+
+	while(arg_type != DBUS_TYPE_INVALID)
+	{
+		const char* arg_name = NULL;
+		bool mandatory = false;
+		void* arg_location = NULL;
+		bool found = false;
+		DBusMessageIter dict;
+		DBusMessageIter value;
+
+		arg_name = va_arg(var_args, const char*);
+		arg_location = va_arg(var_args, void *);
+		mandatory = va_arg(var_args, int);
+
+		if (arg_name == NULL || arg_location == NULL){
+			goto cleanup;
+		}
+
+		/* Find the entry for the name in message */
+		dbus_message_iter_recurse(iter, &dict);
+		while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+			DBusMessageIter entry;
+			const char *key;
+
+			dbus_message_iter_recurse(&dict, &entry);
+			if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING)
+				goto cleanup;
+
+			dbus_message_iter_get_basic(&entry, &key);
+
+			if (g_strcmp0(arg_name, key) == 0)
+			{
+				/* found the key */
+				dbus_message_iter_next(&entry);
+				if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT)
+					goto cleanup;
+
+				dbus_message_iter_recurse(&entry, &value);
+				found = true;
+				break;
+			}
+			dbus_message_iter_next(&dict);
+		}
+
+		if (found)
+		{
+			/* Parse the value */
+			if (arg_type != dbus_message_iter_get_arg_type(&value))
+			{
+				goto cleanup;
+			}
+
+			if (dbus_type_is_basic(arg_type))
+			{
+				dbus_message_iter_get_basic(&value, arg_location);
+			}
+			else
+			{
+				// Unsupported type
+				goto cleanup;
+			}
+		}
+		else if (mandatory)
+		{
+			goto cleanup;
+		}
+
+        /* Move to next entry */
+		arg_type = va_arg(var_args, int);
+	}
+
+	result = true;
+cleanup:
+	va_end(var_args);
+	return result;
+}
diff --git a/gsupplicant/dbus.h b/gsupplicant/dbus.h
index 3a904069..071d19f4 100644
--- a/gsupplicant/dbus.h
+++ b/gsupplicant/dbus.h
@@ -20,6 +20,7 @@
  */
 
 #include <dbus/dbus.h>
+#include <stdbool.h>
 
 #define SUPPLICANT_SERVICE	"fi.w1.wpa_supplicant1"
 #define SUPPLICANT_INTERFACE	"fi.w1.wpa_supplicant1"
@@ -136,3 +137,12 @@ supplicant_dbus_dict_append_array(DBusMessageIter *dict,
 						function, user_data);
 	dbus_message_iter_close_container(dict, &entry);
 }
+
+/**
+ * Usage: dbus_message_get_args_from_array_of_sv(iter,
+ *           DBUS_TYPE_STRING, "property_name", &property_value, bool_is_manadatory
+ *           ... ,
+ *           DBUS_TYPE_INVALID);
+ * Only basic types are supported - no strings, containers, dict entries.
+ */
+bool dbus_message_get_args_from_array_of_sv(DBusMessageIter *iter, int first_arg_type, ...);
diff --git a/gsupplicant/gsupplicant.h b/gsupplicant/gsupplicant.h
index e034cade..c787d5a0 100644
--- a/gsupplicant/gsupplicant.h
+++ b/gsupplicant/gsupplicant.h
@@ -155,6 +155,7 @@ struct _GSupplicantSSID {
 	dbus_bool_t use_wps;
 	const char *pin_wps;
 	const char *bgscan;
+	const char *bssid;
 };
 
 typedef struct _GSupplicantSSID GSupplicantSSID;
@@ -177,8 +178,15 @@ typedef struct _GSupplicantScanParams GSupplicantScanParams;
 
 struct _GSupplicantPeerParams {
 	bool master;
+	char *wps_method;
 	char *wps_pin;
 	char *path;
+
+	dbus_bool_t persistent;
+	dbus_bool_t join;
+	dbus_bool_t authorize_only;
+	dbus_int32_t frequency;
+	dbus_int32_t go_intent;
 };
 
 typedef struct _GSupplicantPeerParams GSupplicantPeerParams;
@@ -192,10 +200,92 @@ struct _GSupplicantP2PServiceParams {
 	int response_length;
 	unsigned char *wfd_ies;
 	int wfd_ies_length;
+
+	const char *service_info;
+	dbus_uint32_t auto_accept;
+	dbus_uint32_t adv_id;
+	uint8_t service_state;
+	dbus_uint16_t config_method;
 };
 
 typedef struct _GSupplicantP2PServiceParams GSupplicantP2PServiceParams;
 
+typedef enum
+{
+	G_SUPPLICANT_P2P_FIND_START_WITH_FULL,
+	G_SUPPLICANT_P2P_FIND_ONLY_SOCIAL,
+	G_SUPPLICANT_P2P_FIND_PROGRESSIVE
+} GSupplicantP2PFindType;
+
+
+struct _GSupplicantP2PSDParams {
+	const char *peer;
+	const char *service_type;
+	dbus_int32_t version;
+	const char *desc;
+	const char *service_info;
+	unsigned char service_transaction_id;
+	unsigned char *query;
+	int query_len;
+	unsigned char *response;
+	dbus_uint32_t auto_accept;
+	dbus_uint32_t adv_id;
+	uint8_t service_state;
+	dbus_uint16_t config_method;
+	int response_len;
+};
+
+typedef struct _GSupplicantP2PSDParams GSupplicantP2PSDParams;
+
+
+typedef struct _GSupplicantP2PASPProvisionRequestParams {
+	const char *peer;
+	uint16_t config_method;
+	uint32_t advertisement_id;
+	const char *service_mac;
+	uint8_t role;
+	uint32_t session_id;
+	const char *session_mac;
+	const char *service_info;
+} GSupplicantP2PASPProvisionRequestParams;
+
+typedef struct _GSupplicantP2PASPProvisionResponseParams {
+	const char *peer;
+	uint32_t advertisement_id;
+	const char *service_mac;
+	int32_t status;
+	uint8_t role;
+	uint32_t session_id;
+	const char *session_mac;
+} GSupplicantP2PASPProvisionResponseParams;
+
+typedef struct _GSupplicantP2PSProvisionSignalParams {
+	//Common
+	uint32_t advertisement_id;
+	char service_mac[18];
+	uint32_t session_id;
+	char session_mac[18];
+	uint32_t connection_capability;
+	uint32_t password_id;
+	uint16_t feature_capability;
+
+	//Start only
+	char session_info[150]; // up to 144 bytes
+
+	//Done only
+	uint32_t status;
+	uint32_t persist;
+	char group_mac[18];
+} GSupplicantP2PSProvisionSignalParams;
+
+struct _GSupplicantP2PGroupAddParams {
+	dbus_bool_t persistent;
+	const char *persistent_group_object;
+	dbus_int32_t frequency;
+};
+
+typedef struct _GSupplicantP2PGroupAddParams GSupplicantP2PGroupAddParams;
+
 /* global API */
 typedef void (*GSupplicantCountryCallback) (int result,
 						const char *alpha2,
@@ -208,14 +298,114 @@ int g_supplicant_set_country(const char *alpha2,
 /* Interface API */
 struct _GSupplicantInterface;
 struct _GSupplicantPeer;
+struct _GSupplicantP2PInterface;
 
 typedef struct _GSupplicantInterface GSupplicantInterface;
 typedef struct _GSupplicantPeer GSupplicantPeer;
+typedef struct _GSupplicantP2PInterface GSupplicantP2PInterface;
+typedef struct _GSupplicantRequestedPeer GSupplicantRequestedPeer;
+
+struct _GSupplicantP2PDeviceConfigParams {
+	GSupplicantInterface *interface;
+	char *device_name;
+	unsigned char pri_dev_type[8];
+	dbus_uint32_t go_intent;
+	int persistent_reconnect;
+	dbus_uint32_t listen_reg_class;
+	dbus_uint32_t listen_channel;
+	dbus_uint32_t oper_reg_class;
+	dbus_uint32_t oper_channel;
+	char *ssid_postfix;
+	int intra_bss;
+	dbus_uint32_t group_idle;
+	dbus_uint32_t disassoc_low_ack;
+	const void *user_data;
+};
+
+typedef int		connman_bool_t;
+
+struct _GSupplicantP2PPersistentGroup {
+	GSupplicantInterface *interface;
+	char *path;
+	char *group_path;
+	char *bssid;
+	char *bssid_no_colon;
+	char *ssid;
+	char *psk;
+	connman_bool_t go;
+	unsigned long long connected_time;
+};
+
+typedef struct _GSupplicantP2PPersistentGroup GSupplicantP2PPersistentGroup;
+
+struct _GSupplicantP2PGroup {
+	GSupplicantInterface *interface;
+	GSupplicantInterface *group_interface;
+	char *path;
+	char *ssid;
+	char *bssid_no_colon;
+	char *passphrase;
+	char *psk;
+	char *role;
+	char *ip_addr;
+	char *ip_mask;
+	char *go_ip_addr;
+	int persistent;
+	int freq;
+	GSupplicantP2PPersistentGroup *persistent_group;
+};
+
+typedef struct _GSupplicantP2PGroup GSupplicantP2PGroup;
+
+/* ASP service advertised by the peer.*/
+struct _GSupplicantP2PService {
+	dbus_uint32_t advertisement_id;
+	char service_name[256];
+};
+
+typedef struct _GSupplicantP2PService GSupplicantP2PService;
+
+struct _GSupplicantP2PWPSParams {
+	const char *role;
+	const char *type;
+	const char *p2p_dev_addr;
+	const char *pin;
+};
+
+typedef struct _GSupplicantP2PWPSParams GSupplicantP2PWPSParams;
+
+struct _GSupplicantP2PFindParams {
+	dbus_int32_t timeout;
+	int disc_type;
+	const char** seek_array;
+	int frequency;
+};
+
+typedef struct _GSupplicantP2PFindParams GSupplicantP2PFindParams;
+
+typedef struct _GSupplicantP2PDeviceConfigParams GSupplicantP2PDeviceConfigParams;
+
+struct p2p_listen_data {
+	int period;
+	int interval;
+};
+
+struct _GSupplicantP2PInviteParams {
+	const char *peer;
+	const char *persistent_group;
+};
+
+typedef struct _GSupplicantP2PInviteParams GSupplicantP2PInviteParams;
 
 typedef void (*GSupplicantInterfaceCallback) (int result,
 					GSupplicantInterface *interface,
 							void *user_data);
 
+typedef void (*GSupplicantInterfaceBcmCallback) (int result,
+					GSupplicantInterface *interface,
+						const char *cmd_response,
+							void *user_data);
+int dev_type_str2bin(const char *type, unsigned char dev_type[8]);
 void g_supplicant_interface_cancel(GSupplicantInterface *interface);
 
 int g_supplicant_interface_create(const char *ifname, const char *driver,
@@ -231,7 +421,8 @@ int g_supplicant_interface_scan(GSupplicantInterface *interface,
 							void *user_data);
 
 int g_supplicant_interface_p2p_find(GSupplicantInterface *interface,
-					GSupplicantInterfaceCallback callback,
+				GSupplicantP2PFindParams *find_data,
+				GSupplicantInterfaceCallback callback,
 							void *user_data);
 
 int g_supplicant_interface_p2p_stop_find(GSupplicantInterface *interface);
@@ -244,17 +435,93 @@ int g_supplicant_interface_p2p_connect(GSupplicantInterface *interface,
 int g_supplicant_interface_p2p_disconnect(GSupplicantInterface *interface,
 					GSupplicantPeerParams *peer_params);
 
+int g_supplicant_interface_p2p_group_disconnect(GSupplicantInterface *interface,
+					GSupplicantInterfaceCallback callback,
+					void *user_data);
+
+int g_supplicant_interface_p2p_persistent_group_add(GSupplicantInterface *interface,
+					GSupplicantSSID *ssid, GSupplicantInterfaceCallback callback,
+					void *user_data);
+
+int g_supplicant_interface_p2p_group_add(GSupplicantInterface *interface,
+				GSupplicantP2PGroupAddParams *group_data,
+				GSupplicantInterfaceCallback callback,
+				void *user_data);
+
 int g_supplicant_interface_p2p_listen(GSupplicantInterface *interface,
-						int period, int interval);
+						int period, int interval,
+						GSupplicantInterfaceCallback callback,
+						void *user_data);
 
 int g_supplicant_interface_p2p_add_service(GSupplicantInterface *interface,
 				GSupplicantInterfaceCallback callback,
 				GSupplicantP2PServiceParams *p2p_service_params,
 				void *user_data);
 
+typedef void (*GSupplicantInterfaceCallbackWithData) (int result,
+					GSupplicantInterface *interface,
+							void *user_data, void* data);
+int g_supplicant_interface_p2p_wps_start(GSupplicantInterface *interface,
+													GSupplicantP2PWPSParams *wps_data,
+													GSupplicantInterfaceCallback callback,
+													void *user_data);
+
+int g_supplicant_interface_p2p_remove_all_persistent_groups(GSupplicantInterface *interface);
+int g_supplicant_interface_p2p_add_persistent_group(GSupplicantInterface *interface,
+										GSupplicantSSID *ssid, void *user_data);
+
+int g_supplicant_interface_p2p_sd_request(GSupplicantInterface *interface,
+				GSupplicantP2PSDParams *sd_data,
+				GSupplicantInterfaceCallbackWithData callback,
+				void *user_data);
+
+int g_supplicant_interface_p2p_sd_cancel_request(GSupplicantInterface *interface,
+				dbus_uint64_t request_id,
+				GSupplicantInterfaceCallback callback,
+				void *user_data);
+
+int g_supplicant_interface_p2p_replace_service(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback,
+				GSupplicantP2PServiceParams *p2p_service_params,
+				void *user_data);
+
+int g_supplicant_interface_p2p_asp_provision_request(GSupplicantInterface *interface,
+										  GSupplicantP2PASPProvisionRequestParams *sd_data,
+										  GSupplicantInterfaceCallback callback,
+										  void *user_data);
+
+int g_supplicant_interface_p2p_asp_provision_response(GSupplicantInterface *interface,
+                                                      GSupplicantP2PASPProvisionResponseParams *params,
+                                                      GSupplicantInterfaceCallback callback,
+                                                      void *user_data);
+
+int g_supplicant_interface_p2p_read_device_address(GSupplicantInterface *interface,
+                                                   GSupplicantInterfaceCallback callback, void *user_data);
+
+const unsigned char *g_supplicant_interface_p2p_get_device_address(GSupplicantInterface *interface);
+
+
 int g_supplicant_interface_p2p_del_service(GSupplicantInterface *interface,
 				GSupplicantP2PServiceParams *p2p_service_params);
 
+int g_supplicant_interface_p2p_reject(GSupplicantInterface *interface,
+					GSupplicantPeerParams *peer_params, GSupplicantInterfaceCallback callback,
+					void *user_data);
+
+int g_supplicant_interface_p2p_client_remove(GSupplicantInterface *interface,
+					GSupplicantInterfaceCallback callback,
+					char* peer_path);
+
+int g_supplicant_interface_p2p_cancel(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback, void *user_data);
+
+int g_supplicant_interface_p2p_flush(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback, void *user_data);
+
+int g_supplicant_interface_p2p_invite(GSupplicantInterface *interface,
+				GSupplicantP2PInviteParams *invite_data,
+				GSupplicantInterfaceCallback callback, void *user_data);
+
 int g_supplicant_set_widi_ies(GSupplicantP2PServiceParams *p2p_service_params,
 					GSupplicantInterfaceCallback callback,
 					void *user_data);
@@ -303,12 +570,19 @@ bool g_supplicant_interface_has_p2p(GSupplicantInterface *interface);
 int g_supplicant_interface_set_p2p_device_config(GSupplicantInterface *interface,
 						const char *device_name,
 						const char *primary_dev_type);
+int g_supplicant_interface_set_p2p_device_configs(GSupplicantInterface *interface,
+						GSupplicantP2PDeviceConfigParams *p2p_device_config_data,
+						void *user_data);
+int g_supplicant_interface_get_p2p_device_config(GSupplicantInterface *interface,
+						GSupplicantP2PDeviceConfigParams *p2p_device_config);
+int g_supplicant_interface_set_p2p_disabled(GSupplicantInterface *interface,
+						dbus_bool_t disabled);
 GSupplicantPeer *g_supplicant_interface_peer_lookup(GSupplicantInterface *interface,
 						const char *identifier);
 bool g_supplicant_interface_is_p2p_finding(GSupplicantInterface *interface);
 
 int g_supplicant_interface_update_signal_info(GSupplicantInterface *interface,
-										GSupplicantInterfaceCallback callback, void *user_data);
+					GSupplicantInterfaceCallback callback, void *user_data);
 
 unsigned int g_supplicant_interface_get_rssi(GSupplicantInterface *interface);
 unsigned int g_supplicant_interface_get_link_speed(GSupplicantInterface *interface);
@@ -319,6 +593,9 @@ unsigned int g_supplicant_interface_get_noise(GSupplicantInterface *interface);
 struct _GSupplicantNetwork;
 struct _GSupplicantGroup;
 
+struct _GSupplicantP2PNetwork;
+typedef struct _GSupplicantP2PNetwork GSupplicantP2PNetwork;
+
 typedef struct _GSupplicantNetwork GSupplicantNetwork;
 typedef struct _GSupplicantGroup GSupplicantGroup;
 
@@ -350,12 +627,18 @@ dbus_uint16_t g_supplicant_bss_get_frequency(GSupplicantBss *bss);
 
 GSupplicantInterface *g_supplicant_peer_get_interface(GSupplicantPeer *peer);
 const char *g_supplicant_peer_get_path(GSupplicantPeer *peer);
+dbus_uint16_t g_supplicant_peer_get_config_methods(GSupplicantPeer *peer);
 const char *g_supplicant_peer_get_identifier(GSupplicantPeer *peer);
 const void *g_supplicant_peer_get_device_address(GSupplicantPeer *peer);
 const void *g_supplicant_peer_get_iface_address(GSupplicantPeer *peer);
+const char *g_supplicant_peer_get_ip_address(GSupplicantPeer *peer);
+
 const char *g_supplicant_peer_get_name(GSupplicantPeer *peer);
 const unsigned char *g_supplicant_peer_get_widi_ies(GSupplicantPeer *peer,
 								int *length);
+dbus_int32_t g_supplicant_peer_get_level(GSupplicantPeer *peer);
+const char *g_supplicant_peer_get_pri_dev_type(GSupplicantPeer *peer);
+int g_supplicant_peer_get_failure_status(GSupplicantPeer *peer);
 bool g_supplicant_peer_is_wps_pbc(GSupplicantPeer *peer);
 bool g_supplicant_peer_is_wps_pin(GSupplicantPeer *peer);
 bool g_supplicant_peer_is_in_a_group(GSupplicantPeer *peer);
@@ -363,6 +646,31 @@ GSupplicantInterface *g_supplicant_peer_get_group_interface(GSupplicantPeer *pee
 bool g_supplicant_peer_is_client(GSupplicantPeer *peer);
 bool g_supplicant_peer_has_requested_connection(GSupplicantPeer *peer);
 
+GSupplicantP2PNetwork* g_supplicant_find_network_from_intf_address(const char* pintf_addr, const char* p2p_dev_addr);
+const char *g_supplicant_peer_identifier_from_intf_address(const char* pintf_addr);
+
+const char *g_supplicant_peer_wfds_get_identifier(GSupplicantPeer *peer);
+int g_supplicant_peer_wfds_get_asp_services(GSupplicantPeer *peer, GSupplicantP2PService** services);
+const char *g_supplicant_peer_wfds_get_peer_name(GSupplicantPeer *peer);
+
+int g_supplicant_interface_bcm_private_cmd(GSupplicantInterface *interface,const char *driver_cmd,
+			GSupplicantInterfaceBcmCallback callback,void *user_data);
+
+GSupplicantInterface *g_supplicant_group_get_interface(GSupplicantGroup *group);
+GSupplicantInterface *g_supplicant_group_get_orig_interface(GSupplicantGroup *group);
+char *g_supplicant_group_get_object_path(GSupplicantGroup *group);
+char *g_supplicant_group_get_bssid_no_colon(GSupplicantGroup *group);
+GSupplicantGroup *g_supplicant_get_group(const char *path);
+
+int g_supplicant_group_get_role(GSupplicantGroup *group);
+char *g_supplicant_group_get_ssid(GSupplicantGroup *group);
+char *g_supplicant_group_get_passphrase(GSupplicantGroup *group);
+int g_supplicant_group_get_frequency(GSupplicantGroup *group);
+bool g_supplicant_group_get_persistent(GSupplicantGroup *group);
+char *g_supplicant_group_get_ip_addr(GSupplicantGroup *group);
+char *g_supplicant_group_get_ip_mask(GSupplicantGroup *group);
+char *g_supplicant_group_get_go_ip_addr(GSupplicantGroup *group);
+
 struct _GSupplicantCallbacks {
 	void (*system_ready) (void);
 	void (*system_killed) (void);
@@ -370,6 +678,7 @@ struct _GSupplicantCallbacks {
 	void (*interface_state) (GSupplicantInterface *interface);
 	void (*interface_removed) (GSupplicantInterface *interface);
 	void (*p2p_support) (GSupplicantInterface *interface);
+	void (*p2p_device_config_loaded) (GSupplicantInterface *interface);
 	void (*scan_started) (GSupplicantInterface *interface);
 	void (*scan_finished) (GSupplicantInterface *interface);
 	void (*ap_create_fail) (GSupplicantInterface *interface);
@@ -388,13 +697,31 @@ struct _GSupplicantCallbacks {
 	void (*peer_lost) (GSupplicantPeer *peer);
 	void (*peer_changed) (GSupplicantPeer *peer,
 					GSupplicantPeerState state);
-	void (*peer_request) (GSupplicantPeer *peer);
-        void (*wps_state)(GSupplicantInterface *interface);
+	void (*peer_request) (GSupplicantPeer *peer, int dev_passwd_id);
+	void (*p2p_sd_response) (GSupplicantInterface *interface, GSupplicantPeer *peer, int indicator, unsigned char *tlv, int tlv_len);
+	void (*p2p_sd_asp_response) (GSupplicantInterface *interface,  GSupplicantPeer *peer, unsigned char transaction_id, unsigned int advertisment_id, unsigned char service_status, dbus_uint16_t config_method, const char* service_name, const char* service_info);
+	void (*wps_state)(GSupplicantInterface *interface);
 	void (*debug) (const char *str);
 	void (*disconnect_reasoncode)(GSupplicantInterface *interface,
 				int reasoncode);
 	void (*assoc_status_code)(GSupplicantInterface *interface,
 				int reasoncode);
+	void (*p2p_group_started)(GSupplicantGroup *group);
+	void (*p2p_group_finished)(GSupplicantInterface *interface);
+	void (*p2ps_prov_start) (GSupplicantInterface *interface,  GSupplicantPeer *peer, GSupplicantP2PSProvisionSignalParams* params);
+	void (*p2ps_prov_done) (GSupplicantInterface *interface,  GSupplicantPeer *peer, GSupplicantP2PSProvisionSignalParams* params);
+
+	void (*p2p_persistent_group_added) (GSupplicantInterface *interface, GSupplicantP2PPersistentGroup *persistent_group);
+	void (*p2p_persistent_group_removed) (GSupplicantInterface *interface, const char *persistent_group_path);
+	void (*p2p_prov_disc_requested_pbc) (GSupplicantInterface *interface, GSupplicantPeer *peer);
+	void (*p2p_prov_disc_requested_enter_pin) (GSupplicantInterface *interface, GSupplicantPeer *peer);
+	void (*p2p_prov_disc_requested_display_pin) (GSupplicantInterface *interface, GSupplicantPeer *peer, const char *pin);
+	void (*p2p_prov_disc_response_enter_pin) (GSupplicantInterface *interface, GSupplicantPeer *peer);
+	void (*p2p_prov_disc_response_display_pin) (GSupplicantInterface *interface, GSupplicantPeer *peer, const char *pin);
+	void (*p2p_prov_disc_fail) (GSupplicantInterface *interface, GSupplicantPeer *peer, int status);
+
+	void (*p2p_invitation_result)(GSupplicantInterface *interface, int status);
+	void (*p2p_invitation_received) (GSupplicantInterface *interface, GSupplicantP2PNetwork *p2p_network, const char *go_dev_addr, connman_bool_t persistent);
 };
 
 typedef struct _GSupplicantCallbacks GSupplicantCallbacks;
diff --git a/gsupplicant/supplicant.c b/gsupplicant/supplicant.c
index 8c008319..6546ca93 100644
--- a/gsupplicant/supplicant.c
+++ b/gsupplicant/supplicant.c
@@ -46,6 +46,9 @@
 
 #define BSS_UNKNOWN_STRENGTH    -90
 
+#define WPAS_P2P_WPS_PIN_LENGTH		8
+#define MAX_P2P_SSID_LEN			32
+
 static DBusConnection *connection;
 
 static const GSupplicantCallbacks *callbacks_pointer;
@@ -144,6 +147,13 @@ static GHashTable *peer_mapping;
 static GHashTable *group_mapping;
 static GHashTable *pending_peer_connection;
 static GHashTable *config_file_table;
+static GHashTable *intf_addr_mapping;
+static GHashTable *dev_addr_mapping;
+static GSList *p2p_network_list;
+static GHashTable *p2p_peer_table;
+
+typedef void (*g_supplicant_p2p_prov_dics_signal_func) (GSupplicantInterface *interface,
+				GSupplicantPeer* peer, void* params);
 
 struct _GSupplicantWpsCredentials {
 	unsigned char ssid[32];
@@ -191,10 +201,15 @@ struct _GSupplicantInterface {
 	GHashTable *peer_table;
 	GHashTable *group_table;
 	GHashTable *bss_mapping;
+	GHashTable *p2p_peer_path_to_network;
+	GHashTable *p2p_group_path_to_group;
 	void *data;
 	const char *pending_peer_path;
 	GSupplicantNetwork *current_network;
 	struct added_network_information network_info;
+
+	unsigned char p2p_device_address[6];
+
 };
 
 struct g_supplicant_bss {
@@ -222,6 +237,29 @@ struct g_supplicant_bss {
 	unsigned int wps_capabilities;
 };
 
+struct _GSupplicantP2PNetwork {
+	GSupplicantInterface *interface;
+	int found_ref;
+	char *path;
+	char *identifier; /* Device address in string 112233445566 format */
+	char *group;
+	char *name;
+	unsigned char p2p_device_addr[6]; /* Device address in binary format */
+	uint8_t pri_dev_type[8];
+	uint8_t dev_capab;
+	uint8_t group_capab;
+	dbus_uint16_t config_methods;
+	dbus_int32_t level;
+	int wfd_dev_type;
+	int wfd_session_avail;
+	int wfd_cp_support;
+	unsigned int wfd_rtsp_port;
+	GSupplicantP2PService* asp_services;
+	int asp_services_len;
+	GHashTable *peer_table;
+	connman_bool_t removed;
+};
+
 struct _GSupplicantNetwork {
 	GSupplicantInterface *interface;
 	char *path;
@@ -247,12 +285,32 @@ struct _GSupplicantPeer {
 	unsigned char iface_address[ETH_ALEN];
 	char *name;
 	unsigned char *widi_ies;
+	char *ip_addr;
 	int widi_ies_length;
 	char *identifier;
+	dbus_uint16_t config_methods;
 	unsigned int wps_capabilities;
 	GSList *groups;
 	const GSupplicantInterface *current_group_iface;
 	bool connection_requested;
+	dbus_int32_t level;
+
+	GSupplicantP2PService* asp_services;
+	int asp_services_len;
+	int status;
+	int found_pending_signal_timeout_ref;
+
+	char *pri_dev_type;
+	GSList* pending_signals; // List of ordered signals pending dispatch when peer properties are fetched and network is created
+	GSList* pending_invitation_signals;
+};
+
+struct _GSupplicantRequestedPeer {
+	char *requested_p2p_dev_addr;
+	char *requested_path;
+	char *requested_ip_addr;
+	bool requested_is_ip_present;
+	struct peer_device_data *found_p2p_network;
 };
 
 struct _GSupplicantGroup {
@@ -261,6 +319,21 @@ struct _GSupplicantGroup {
 	char *path;
 	int role;
 	GSList *members;
+	char *ssid;
+	char *passphrase;
+	char *bssid_no_colon;
+	bool persistent;
+	int frequency;
+	char *ip_addr;
+	char *ip_mask;
+	char *go_ip_addr;
+	char *psk;
+	GSupplicantP2PPersistentGroup *persistent_group;
+};
+
+struct _GSupplicantP2PInterface {
+	char *path;
+	GSupplicantP2PDeviceConfigParams *p2p_device_config_param;
 };
 
 struct interface_data {
@@ -279,9 +352,12 @@ struct interface_create_data {
 	char *driver;
 	char *bridge;
 	const char *config_file;
+	const char *country_code;
 	GSupplicantInterface *interface;
+	char *interface_path;
 	GSupplicantInterfaceCallback callback;
 	void *user_data;
+	unsigned char get_interface_timer_count;
 };
 
 struct interface_connect_data {
@@ -295,6 +371,14 @@ struct interface_connect_data {
 	};
 };
 
+struct interface_wps_connect_data {
+	GSupplicantInterface *interface;
+	char *path;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantSSID *ssid;
+	void *user_data;
+};
+
 struct interface_scan_data {
 	GSupplicantInterface *interface;
 	char *path;
@@ -303,7 +387,43 @@ struct interface_scan_data {
 	void *user_data;
 };
 
+struct interface_reject_data {
+	GSupplicantInterface *interface;
+	char *path;
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
+	GSupplicantPeerParams *peer;
+};
+
+struct interface_p2p_device_config {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PDeviceConfigParams *p2p_device_config_params;
+	void *user_data;
+};
+
+typedef void (*g_supplicant_p2p_network_signal_func) (GSupplicantInterface *interface, GSupplicantPeer *peer, GSupplicantP2PSProvisionSignalParams* params);
+typedef void (*g_supplicant_p2p_network_signal_free_func) (void* params);
+
+struct g_supplicant_p2p_peer_signal {
+	g_supplicant_p2p_network_signal_func dispatch_function;
+	g_supplicant_p2p_network_signal_free_func free_function; // function to use for freeing the params
+	void* callback_params;
+};
+
+struct g_supplicant_p2p_inv_recv_info {
+	GSupplicantInterface *interface;
+	const char *p2p_go_dev_addr;
+	const char *src_addr;
+	connman_bool_t persistent;
+	unsigned char get_invitation_timer_count;
+};
+
+static int inv_recv_ref = -1;
+static int scan_callback_ref;
+
 static int network_remove(struct interface_data *data);
+static gboolean get_interface_retry(void* user_data);
 
 static inline void debug(const char *format, ...)
 {
@@ -541,6 +661,17 @@ static void callback_p2p_support(GSupplicantInterface *interface)
 		callbacks_pointer->p2p_support(interface);
 }
 
+static void callback_p2p_device_config_loaded(GSupplicantInterface *interface)
+{
+	SUPPLICANT_DBG("");
+
+	if (!interface->p2p_support)
+		return;
+
+	if (callbacks_pointer && callbacks_pointer->p2p_device_config_loaded)
+		callbacks_pointer->p2p_device_config_loaded(interface);
+}
+
 static void callback_scan_started(GSupplicantInterface *interface)
 {
 	if (!callbacks_pointer)
@@ -677,7 +808,221 @@ static void callback_peer_changed(GSupplicantPeer *peer,
 	callbacks_pointer->peer_changed(peer, state);
 }
 
-static void callback_peer_request(GSupplicantPeer *peer)
+static void callback_p2p_group_started(GSupplicantGroup *group)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_group_started)
+		return;
+
+	callbacks_pointer->p2p_group_started(group);
+}
+
+static void callback_p2p_group_finished(GSupplicantInterface *interface)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_group_finished)
+		return;
+
+	callbacks_pointer->p2p_group_finished(interface);
+}
+
+static void callback_p2ps_prov_start(GSupplicantInterface *interface, GSupplicantPeer *peer,
+                                       GSupplicantP2PSProvisionSignalParams* params)
+{
+	if (callbacks_pointer == NULL)
+		return;
+
+	if (callbacks_pointer->p2ps_prov_start == NULL)
+		return;
+
+	callbacks_pointer->p2ps_prov_start(interface,peer, params);
+}
+
+static void callback_p2ps_prov_done(GSupplicantInterface *interface, GSupplicantPeer *peer,
+                                    GSupplicantP2PSProvisionSignalParams* params)
+{
+	if (callbacks_pointer == NULL)
+		return;
+
+	if (callbacks_pointer->p2ps_prov_done == NULL)
+		return;
+
+	callbacks_pointer->p2ps_prov_done(interface,peer, params);
+}
+
+static void callback_p2p_prov_disc_requested_pbc(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, void * data)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_requested_pbc)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_requested_pbc(interface, peer);
+}
+
+static void callback_p2p_prov_disc_requested_enter_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, void * data)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_requested_enter_pin)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_requested_enter_pin(interface, peer);
+}
+
+static void callback_p2p_prov_disc_requested_display_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, const char *pin)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_requested_display_pin)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_requested_display_pin(interface, peer, pin);
+}
+
+static void callback_p2p_prov_disc_response_enter_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, void * data)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_requested_enter_pin)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_response_enter_pin(interface, peer);
+}
+
+static void callback_p2p_prov_disc_response_display_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, const char *pin)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_requested_display_pin)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_response_display_pin(interface, peer, pin);
+}
+
+static void callback_p2p_prov_disc_fail(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, const char *pin)
+{
+	if (!callbacks_pointer)
+		return;
+
+	if (!callbacks_pointer->p2p_prov_disc_fail)
+		return;
+
+	callbacks_pointer->p2p_prov_disc_fail(interface, peer, pin);
+}
+
+GSupplicantInterface *g_supplicant_group_get_interface(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->interface;
+}
+
+GSupplicantInterface *g_supplicant_group_get_orig_interface(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->orig_interface;
+}
+
+char *g_supplicant_group_get_bssid_no_colon(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->bssid_no_colon;
+}
+
+char *g_supplicant_group_get_object_path(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->path;
+}
+
+char *g_supplicant_group_get_ssid(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->ssid;
+}
+
+char *g_supplicant_group_get_passphrase(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->passphrase;
+}
+
+int g_supplicant_group_get_frequency(GSupplicantGroup *group)
+{
+	if(!group)
+		return 0;
+
+	return group->frequency;
+}
+
+int g_supplicant_group_get_role(GSupplicantGroup *group)
+{
+	if(!group)
+		return 0;
+
+	return group->role;
+}
+
+bool g_supplicant_group_get_persistent(GSupplicantGroup *group)
+{
+	if(!group)
+		return false;
+
+	return group->persistent;
+}
+
+char *g_supplicant_group_get_ip_addr(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->ip_addr;
+}
+
+char *g_supplicant_group_get_ip_mask(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->ip_mask;
+}
+
+char *g_supplicant_group_get_go_ip_addr(GSupplicantGroup *group)
+{
+	if(!group)
+		return NULL;
+
+	return group->go_ip_addr;
+}
+
+static void callback_peer_request(GSupplicantPeer *peer, int dev_passwd_id)
 {
 	if (!callbacks_pointer)
 		return;
@@ -687,7 +1032,7 @@ static void callback_peer_request(GSupplicantPeer *peer)
 
 	peer->connection_requested = true;
 
-	callbacks_pointer->peer_request(peer);
+	callbacks_pointer->peer_request(peer, dev_passwd_id);
 }
 
 static void callback_disconnect_reason_code(GSupplicantInterface *interface,
@@ -704,6 +1049,41 @@ static void callback_disconnect_reason_code(GSupplicantInterface *interface,
 							reason_code);
 }
 
+
+static void callback_p2p_persistent_group_added(GSupplicantInterface *interface, GSupplicantP2PPersistentGroup *group)
+{
+	if (callbacks_pointer == NULL)
+		return;
+
+	if (callbacks_pointer->p2p_persistent_group_added == NULL)
+		return;
+
+	callbacks_pointer->p2p_persistent_group_added(interface, group);
+}
+
+static void callback_p2p_persistent_group_removed(GSupplicantInterface *interface, const char *persistent_group_path)
+{
+	if (callbacks_pointer == NULL)
+		return;
+
+	if (callbacks_pointer->p2p_persistent_group_removed == NULL)
+		return;
+
+	callbacks_pointer->p2p_persistent_group_removed(interface, persistent_group_path);
+}
+
+static void callback_p2p_sd_response(GSupplicantInterface *interface, GSupplicantPeer *peer,
+											int indicator, unsigned char *tlv, int tlv_len)
+{
+	if (callbacks_pointer == NULL)
+		return;
+
+	if (callbacks_pointer->p2p_sd_response == NULL)
+		return;
+
+	callbacks_pointer->p2p_sd_response(interface, peer, indicator, tlv, tlv_len);
+}
+
 static void callback_assoc_status_code(GSupplicantInterface *interface,
 				int status_code)
 {
@@ -725,6 +1105,13 @@ static void remove_group(gpointer data)
 		g_slist_free_full(group->members, g_free);
 
 	g_free(group->path);
+	g_free(group->bssid_no_colon);
+	g_free(group->ip_addr);
+	g_free(group->ip_mask);
+	g_free(group->go_ip_addr);
+	g_free(group->ssid);
+	g_free(group->psk);
+	g_free(group->passphrase);
 	g_free(group);
 }
 
@@ -747,6 +1134,15 @@ static void remove_interface(gpointer data)
 	g_hash_table_destroy(interface->network_table);
 	g_hash_table_destroy(interface->peer_table);
 	g_hash_table_destroy(interface->group_table);
+	if (interface->p2p_peer_path_to_network) {
+		g_hash_table_destroy(interface->p2p_peer_path_to_network);
+		interface->p2p_peer_path_to_network = NULL;
+	}
+
+	if (interface->p2p_group_path_to_group) {
+		g_hash_table_destroy(interface->p2p_group_path_to_group);
+		interface->p2p_group_path_to_group = NULL;
+	}
 
 	if (interface->scan_callback) {
 		SUPPLICANT_DBG("call interface %p callback %p scanning %d",
@@ -805,6 +1201,7 @@ static void remove_peer(gpointer data)
 {
 	GSupplicantPeer *peer = data;
 
+	SUPPLICANT_DBG("peer %p", peer);
 	callback_peer_lost(peer);
 
 	if (peer->groups)
@@ -816,10 +1213,20 @@ static void remove_peer(gpointer data)
 	if (pending_peer_connection)
 		g_hash_table_remove(pending_peer_connection, peer->path);
 
+	if (p2p_peer_table)
+		g_hash_table_remove(p2p_peer_table, peer->path);
+
+	if (peer->found_pending_signal_timeout_ref > 0){
+		g_source_remove(peer->found_pending_signal_timeout_ref);
+		peer->found_pending_signal_timeout_ref = 0;
+	}
+
 	g_free(peer->path);
 	g_free(peer->name);
 	g_free(peer->identifier);
 	g_free(peer->widi_ies);
+	g_free(peer->pri_dev_type);
+	g_free(peer->ip_addr);
 
 	g_free(peer);
 }
@@ -1196,6 +1603,19 @@ unsigned int g_supplicant_interface_get_noise(GSupplicantInterface *interface)
 	return interface->noise;
 }
 
+void g_supplicant_interface_set_p2p_persistent_group(GSupplicantInterface *interface, GSupplicantGroup *group, GSupplicantP2PPersistentGroup *persistent_group)
+{
+	group->persistent_group = persistent_group;
+	g_hash_table_replace(interface->p2p_group_path_to_group, group->path, group);
+}
+
+GSupplicantP2PPersistentGroup* g_supplicant_interface_get_p2p_persistent_group(GSupplicantInterface *interface, GSupplicantGroup *group)
+{
+	if (!group)
+		return NULL;
+
+	return group->persistent_group;
+}
 static void set_network_enabled(DBusMessageIter *iter, void *user_data)
 {
 	dbus_bool_t enable = *(dbus_bool_t *)user_data;
@@ -1401,6 +1821,14 @@ const char *g_supplicant_peer_get_path(GSupplicantPeer *peer)
 	return peer->path;
 }
 
+dbus_uint16_t g_supplicant_peer_get_config_methods(GSupplicantPeer *peer)
+{
+	if (!peer)
+		return 0;
+
+	return peer->config_methods;
+}
+
 const char *g_supplicant_peer_get_identifier(GSupplicantPeer *peer)
 {
 	if (!peer)
@@ -1425,6 +1853,14 @@ const void *g_supplicant_peer_get_iface_address(GSupplicantPeer *peer)
 	return peer->iface_address;
 }
 
+const char *g_supplicant_peer_get_ip_address(GSupplicantPeer *peer)
+{
+	if (!peer)
+		return NULL;
+
+	return peer->ip_addr;
+}
+
 const char *g_supplicant_peer_get_name(GSupplicantPeer *peer)
 {
 	if (!peer)
@@ -1443,26 +1879,50 @@ const unsigned char *g_supplicant_peer_get_widi_ies(GSupplicantPeer *peer,
 	return peer->widi_ies;
 }
 
-bool g_supplicant_peer_is_wps_pbc(GSupplicantPeer *peer)
+dbus_int32_t g_supplicant_peer_get_level(GSupplicantPeer *peer)
 {
 	if (!peer)
-		return false;
-
-	if (peer->wps_capabilities & G_SUPPLICANT_WPS_PBC)
-		return true;
+		return 0;
 
-	return false;
+	return peer->level;
 }
 
-bool g_supplicant_peer_is_wps_pin(GSupplicantPeer *peer)
+const char *g_supplicant_peer_get_pri_dev_type(GSupplicantPeer *peer)
 {
 	if (!peer)
-		return false;
-
-	if (peer->wps_capabilities & G_SUPPLICANT_WPS_PIN)
-		return true;
+		return NULL;
 
-	return false;
+	return peer->pri_dev_type;
+}
+
+int g_supplicant_peer_get_failure_status(GSupplicantPeer *peer)
+{
+	if (!peer)
+		return 0;
+
+	return peer->status;
+}
+
+bool g_supplicant_peer_is_wps_pbc(GSupplicantPeer *peer)
+{
+	if (!peer)
+		return false;
+
+	if (peer->wps_capabilities & G_SUPPLICANT_WPS_PBC)
+		return true;
+
+	return false;
+}
+
+bool g_supplicant_peer_is_wps_pin(GSupplicantPeer *peer)
+{
+	if (!peer)
+		return false;
+
+	if (peer->wps_capabilities & G_SUPPLICANT_WPS_PIN)
+		return true;
+
+	return false;
 }
 
 bool g_supplicant_peer_is_in_a_group(GSupplicantPeer *peer)
@@ -1515,6 +1975,57 @@ bool g_supplicant_peer_has_requested_connection(GSupplicantPeer *peer)
 	return peer->connection_requested;
 }
 
+const char *g_supplicant_peer_wfds_get_identifier(GSupplicantPeer *peer)
+{
+	char *id = strrchr(peer->path, '/') + 1;
+
+	char *identifier = g_strdup(id);
+
+	return identifier;
+}
+
+int g_supplicant_peer_wfds_get_asp_services(GSupplicantPeer *peer, GSupplicantP2PService** services)
+{
+	if (peer == NULL)
+		return 0;
+
+	if (services == NULL)
+		return 0;
+
+
+	*services = peer->asp_services;
+	return peer->asp_services_len;
+}
+
+const char *g_supplicant_peer_wfds_get_peer_name(GSupplicantPeer *peer)
+{
+	if (peer == NULL)
+		return 0;
+
+	return peer->name;
+}
+
+static void network_property_free(GSupplicantNetwork *network)
+{
+	if (network == NULL)
+		return;
+
+	if (network->config_table){
+		g_hash_table_destroy(network->config_table);
+		network->config_table = NULL;
+	}
+
+	if (network->path){
+		g_free(network->path);
+		network->path = NULL;
+	}
+
+	if (network){
+		g_free(network);
+		network = NULL;
+	}
+}
+
 static void merge_network(GSupplicantNetwork *network)
 {
 	GString *str;
@@ -2175,17 +2686,23 @@ static void interface_bss_added_with_keys(DBusMessageIter *iter,
 						void *user_data)
 {
 	struct g_supplicant_bss *bss;
+	GSupplicantInterface *interface = user_data;
 
 	SUPPLICANT_DBG("");
 
+	if (!g_strcmp0(interface->ifname, "p2p0"))
+		return;
+
 	bss = interface_bss_added(iter, user_data);
 	if (!bss)
 		return;
 
 	dbus_message_iter_next(iter);
 
-	if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID)
+	if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {
+		g_free(bss);
 		return;
+	}
 
 	supplicant_dbus_property_foreach(iter, bss_property, bss);
 
@@ -2198,9 +2715,13 @@ static void interface_bss_added_without_keys(DBusMessageIter *iter,
 						void *user_data)
 {
 	struct g_supplicant_bss *bss;
+	GSupplicantInterface *interface = user_data;
 
 	SUPPLICANT_DBG("");
 
+	if (!g_strcmp0(interface->ifname, "p2p0"))
+		return;
+
 	bss = interface_bss_added(iter, user_data);
 	if (!bss)
 		return;
@@ -2615,6 +3136,12 @@ static GSupplicantInterface *interface_alloc(const char *path)
 	interface->bss_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
 								NULL, NULL);
 
+	interface->p2p_peer_path_to_network = g_hash_table_new_full(g_str_hash, g_str_equal,
+								NULL, NULL);
+
+	interface->p2p_group_path_to_group = g_hash_table_new_full(g_str_hash, g_str_equal,
+								NULL, NULL);
+
 	g_hash_table_replace(interface_table, interface->path, interface);
 
 	return interface;
@@ -2761,6 +3288,7 @@ static void signal_name_owner_changed(const char *path, DBusMessageIter *iter)
 		g_hash_table_remove_all(group_mapping);
 		g_hash_table_remove_all(config_file_table);
 		g_hash_table_remove_all(interface_table);
+		g_hash_table_remove_all(p2p_peer_table);
 		callback_system_killed();
 	}
 
@@ -3232,6 +3760,14 @@ struct peer_property_data {
 	bool services_changed;
 };
 
+
+struct peer_device_data {
+	char *path;
+	char *identifier; /* Device address in string 112233445566 format */
+	unsigned char p2p_device_addr[6]; /* Device address in binary format */
+};
+
+
 static void peer_groups_relation(DBusMessageIter *iter, void *user_data)
 {
 	struct peer_property_data *data = user_data;
@@ -3258,12 +3794,73 @@ static void peer_groups_relation(DBusMessageIter *iter, void *user_data)
 	}
 }
 
+static void string_to_byte(const char *src, unsigned char *dest)
+{
+	int len = strlen(src);
+	int i=0;
+	unsigned char t = 0;
+
+	for(i=0; i<len; i++) {
+		if (src[i] >= '0' && src[i] <= '9')
+			t = src[i] - '0';
+		if (src[i] >= 'a' && src[i] <= 'f')
+			t = src[i] - 'a' + 10;
+		if (src[i] >= 'A' && src[i] <= 'F')
+			t = src[i] - 'A' + 10;
+
+		if(i%2 == 0)
+			dest[i/2] = (t << 4);
+		else
+			dest[i/2] |= t;
+	}
+}
+
+static gboolean p2p_network_fire_signals(GSupplicantPeer * peer)
+{
+	if (!peer)
+		return FALSE;
+
+	peer->found_pending_signal_timeout_ref = 0;
+
+	while (peer->pending_signals != NULL)
+	{
+		struct g_supplicant_p2p_peer_signal* signal = peer->pending_signals->data;
+
+		SUPPLICANT_DBG("Firing delayed signal for peer %s", peer->path);
+
+		signal->dispatch_function(peer->interface, peer, signal->callback_params);
+		signal->free_function(signal->callback_params);
+
+		peer->pending_signals = g_slist_remove(peer->pending_signals, signal);
+		g_free(signal);
+	}
+	return FALSE;
+}
+
+static void p2p_pending_invitation_fire_signals(GSupplicantPeer * peer)
+{
+	while (peer->pending_invitation_signals != NULL)
+	{
+		struct g_supplicant_p2p_peer_signal* signal = peer->pending_invitation_signals->data;
+
+		SUPPLICANT_DBG("Firing delayed signal for peer %s", peer->path);
+
+		signal->dispatch_function(peer->interface, peer, signal->callback_params);
+		signal->free_function(signal->callback_params);
+
+		peer->pending_invitation_signals = g_slist_remove(peer->pending_invitation_signals, signal);
+		g_free(signal);
+	}
+}
+
 static void peer_property(const char *key, DBusMessageIter *iter,
 							void *user_data)
 {
 	GSupplicantPeer *pending_peer;
 	struct peer_property_data *data = user_data;
 	GSupplicantPeer *peer = data->peer;
+	int dev_passwd_id = 0;
+	GSupplicantInterface *interface = peer->interface;
 
 	SUPPLICANT_DBG("key: %s", key);
 
@@ -3271,18 +3868,40 @@ static void peer_property(const char *key, DBusMessageIter *iter,
 		return;
 
 	if (!key) {
+		if (g_hash_table_lookup(p2p_peer_table, peer->path) == NULL)
+			return;
+
 		if (peer->name) {
+			struct peer_device_data *p2p_data;
+
+			p2p_data = g_try_new0(struct peer_device_data, 1);
+			if (p2p_data == NULL) {
+				return;
+			}
+
+			if (p2p_data->path == NULL) {
+				char *id = strrchr(peer->path, '/') + 1;
+				p2p_data->identifier = g_strdup(id);
+				p2p_data->path = g_strdup(peer->path);
+				string_to_byte(p2p_data->identifier, p2p_data->p2p_device_addr);
+			}
+			p2p_network_list = g_slist_prepend(p2p_network_list, p2p_data);
+			g_hash_table_replace(interface->p2p_peer_path_to_network, peer->path, p2p_data);
+
 			create_peer_identifier(peer);
 			callback_peer_found(peer);
 			pending_peer = g_hash_table_lookup(
 					pending_peer_connection, peer->path);
 
 			if (pending_peer && pending_peer == peer) {
-				callback_peer_request(peer);
+				callback_peer_request(peer, dev_passwd_id);
 				g_hash_table_remove(pending_peer_connection,
 						peer->path);
 			}
 
+			p2p_pending_invitation_fire_signals(peer);
+			peer->found_pending_signal_timeout_ref = g_timeout_add(500, p2p_network_fire_signals, peer);
+
 			dbus_free(data);
 		}
 
@@ -3309,6 +3928,7 @@ static void peer_property(const char *key, DBusMessageIter *iter,
 		uint16_t wps_config;
 
 		dbus_message_iter_get_basic(iter, &wps_config);
+		peer->config_methods = wps_config;
 
 		if (wps_config & G_SUPPLICANT_WPS_CONFIG_PBC)
 			peer->wps_capabilities |= G_SUPPLICANT_WPS_PBC;
@@ -3324,6 +3944,47 @@ static void peer_property(const char *key, DBusMessageIter *iter,
 			g_slist_free_full(data->old_groups, g_free);
 			data->groups_changed = true;
 		}
+
+	} else if (g_strcmp0(key, "p2ps_instance") == 0) {
+		DBusMessageIter array;
+		int len = 0;
+
+		if (peer->asp_services != NULL)
+		{
+			g_free(peer->asp_services);
+			peer->asp_services = NULL;
+			peer->asp_services_len = 0;
+		}
+
+		//get the array size
+		dbus_message_iter_recurse(iter, &array);
+		while (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_INVALID) {
+			len ++;
+			dbus_message_iter_next(&array);
+		}
+
+		if (len > 0)
+		{
+			int pos = 0;
+			peer->asp_services_len = len;
+			peer->asp_services = g_new0(GSupplicantP2PService, len);
+
+			dbus_message_iter_recurse(iter, &array);
+
+			while (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_INVALID) {
+				DBusMessageIter item;
+				const char* service_name = NULL;
+				dbus_message_iter_recurse(&array, &item);
+				dbus_message_iter_get_basic(&item, &(peer->asp_services[pos].advertisement_id));
+				dbus_message_iter_next(&item);
+				dbus_message_iter_get_basic(&item, &service_name);
+				(void)g_strlcpy(peer->asp_services[pos].service_name, service_name, 256);
+
+				pos ++;
+				dbus_message_iter_next(&array);
+			}
+		}
+
 	} else if (g_strcmp0(key, "IEs") == 0) {
 		DBusMessageIter array;
 		unsigned char *ie;
@@ -3348,6 +4009,25 @@ static void peer_property(const char *key, DBusMessageIter *iter,
 		memcpy(peer->widi_ies, ie, ie_len);
 		peer->widi_ies_length = ie_len;
 		data->services_changed = true;
+	} else if (g_strcmp0(key, "level") == 0) {
+		dbus_int32_t level = 0;
+
+		dbus_message_iter_get_basic(iter, &level);
+		peer->level = level;
+	} else if (g_strcmp0(key, "PrimaryDeviceType") == 0) {
+		DBusMessageIter array;
+		unsigned char *device_type;
+		int type_len;
+
+		dbus_message_iter_recurse(iter, &array);
+		dbus_message_iter_get_fixed_array(&array, &device_type, &type_len);
+
+		if (type_len == 8) {
+			peer->pri_dev_type = g_malloc0(type_len*2+1);
+			__connman_util_byte_to_string(device_type, peer->pri_dev_type, type_len);
+		} else {
+			SUPPLICANT_DBG("strange device type\n");
+		}
 	}
 }
 
@@ -3357,6 +4037,7 @@ static void signal_peer_found(const char *path, DBusMessageIter *iter)
 	GSupplicantInterface *interface;
 	const char *obj_path = NULL;
 	GSupplicantPeer *peer;
+	int ret;
 
 	SUPPLICANT_DBG("");
 
@@ -3380,8 +4061,13 @@ static void signal_peer_found(const char *path, DBusMessageIter *iter)
 	peer->path = g_strdup(obj_path);
 	g_hash_table_insert(interface->peer_table, peer->path, peer);
 	g_hash_table_replace(peer_mapping, peer->path, interface);
+	g_hash_table_replace(p2p_peer_table, g_strdup(peer->path), peer);
 
 	property_data = dbus_malloc0(sizeof(struct peer_property_data));
+
+	if(!property_data)
+		return;
+
 	property_data->peer = peer;
 
 	dbus_message_iter_next(iter);
@@ -3392,9 +4078,12 @@ static void signal_peer_found(const char *path, DBusMessageIter *iter)
 		return;
 	}
 
-	supplicant_dbus_property_get_all(obj_path,
+	ret=supplicant_dbus_property_get_all(obj_path,
 					SUPPLICANT_INTERFACE ".Peer",
 					peer_property, property_data, NULL);
+
+	if(ret<0)
+		dbus_free(property_data);
 }
 
 static void signal_peer_lost(const char *path, DBusMessageIter *iter)
@@ -3402,6 +4091,7 @@ static void signal_peer_lost(const char *path, DBusMessageIter *iter)
 	GSupplicantInterface *interface;
 	const char *obj_path = NULL;
 	GSupplicantPeer *peer;
+	struct peer_device_data *p2p_data;
 
 	SUPPLICANT_DBG("");
 
@@ -3417,6 +4107,21 @@ static void signal_peer_lost(const char *path, DBusMessageIter *iter)
 	if (!peer)
 		return;
 
+	if (interface->p2p_peer_path_to_network) {
+	p2p_data = g_hash_table_lookup(interface->p2p_peer_path_to_network, obj_path);
+		if (p2p_data == NULL) {
+			g_hash_table_remove(interface->peer_table, obj_path);
+			return;
+		}
+
+	g_hash_table_remove(interface->p2p_peer_path_to_network, obj_path);
+	p2p_network_list = g_slist_remove(p2p_network_list, p2p_data);
+
+	g_free(p2p_data->identifier);
+	g_free(p2p_data->path);
+	g_free(p2p_data);
+	}
+
 	g_hash_table_remove(interface->peer_table, obj_path);
 }
 
@@ -3439,12 +4144,14 @@ static void signal_peer_changed(const char *path, DBusMessageIter *iter)
 	}
 
 	property_data = dbus_malloc0(sizeof(struct peer_property_data));
+	if(!property_data)
+		return;
+
 	property_data->peer = peer;
 
 	supplicant_dbus_property_foreach(iter, peer_property, property_data);
 	if (property_data->services_changed)
-		callback_peer_changed(peer,
-					G_SUPPLICANT_PEER_SERVICES_CHANGED);
+		callback_peer_changed(peer, G_SUPPLICANT_PEER_SERVICES_CHANGED);
 
 	if (property_data->groups_changed)
 		callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_CHANGED);
@@ -3455,18 +4162,45 @@ static void signal_peer_changed(const char *path, DBusMessageIter *iter)
 		peer->connection_requested = false;
 }
 
+static void remove_colon(char *str)
+{
+	int len = strlen(str);
+	int i=0;
+	int j=0;
+
+	for(i=0; i<len; i++) {
+		if(str[i] == ':') {
+			for(j=i; j<len-1; j++) {
+				str[j] = str[j+1];
+			}
+			len--;
+			i--;
+		}
+	}
+	str[len] = '\0';
+}
+
 struct group_sig_data {
 	const char *peer_obj_path;
 	unsigned char iface_address[ETH_ALEN];
+	char dev_addr_buf[13];
 	const char *interface_obj_path;
 	const char *group_obj_path;
 	int role;
+	bool persistent;
+	int status;
+	char *ip_addr;
+	char *ip_mask;
+	char *go_ip_addr;
+	int freq;
 };
 
 static void group_sig_property(const char *key, DBusMessageIter *iter,
 							void *user_data)
 {
 	struct group_sig_data *data = user_data;
+	char *group_bssid_no_colon = NULL;
+	int addr_len;
 
 	if (!key)
 		return;
@@ -3481,7 +4215,7 @@ static void group_sig_property(const char *key, DBusMessageIter *iter,
 
 		if (len == ETH_ALEN)
 			memcpy(data->iface_address, dev_addr, len);
-	} else if (g_strcmp0(key, "role") == 0) {
+	} else if (g_strcmp0(key, "role") == 0 || g_strcmp0(key, "role_go") == 0) {
 		const char *str = NULL;
 
 		dbus_message_iter_get_basic(iter, &str);
@@ -3495,7 +4229,49 @@ static void group_sig_property(const char *key, DBusMessageIter *iter,
 		dbus_message_iter_get_basic(iter, &data->interface_obj_path);
 	else if (g_strcmp0(key, "group_object") == 0)
 		dbus_message_iter_get_basic(iter, &data->group_obj_path);
-
+	else if (g_strcmp0(key, "persistent") == 0)
+		dbus_message_iter_get_basic(iter, &data->persistent);
+	else if(g_str_equal(key, "go_dev_addr")) {
+			DBusMessageIter array;
+			dbus_message_iter_recurse(iter, &array);
+			dbus_message_iter_get_fixed_array(&array, &group_bssid_no_colon, &addr_len);
+
+			if (addr_len != 6) {
+				//Do not set the bbsid_no_colon unless we have the correct length
+				SUPPLICANT_DBG("group->bssid_no_colon: Error: array length expected to be 6, was %i", addr_len);
+			} else {
+				__connman_util_byte_to_string(group_bssid_no_colon, data->dev_addr_buf, addr_len);
+			}
+	} else if (g_strcmp0(key, "status") == 0)
+		dbus_message_iter_get_basic(iter, &data->status);
+	else if(g_str_equal(key, "IpAddr")) {
+			DBusMessageIter array;
+			char *ip_addr;
+			dbus_message_iter_recurse(iter, &array);
+			dbus_message_iter_get_fixed_array(&array, &ip_addr, &addr_len);
+
+			data->ip_addr = __connman_util_ipaddr_binary_to_string(ip_addr);
+			SUPPLICANT_DBG("ip_addr : %s\n", data->ip_addr);
+	} else if(g_str_equal(key, "IpAddrMask")) {
+			DBusMessageIter array;
+			char *ip_mask;
+			dbus_message_iter_recurse(iter, &array);
+			dbus_message_iter_get_fixed_array(&array, &ip_mask, &addr_len);
+
+			data->ip_mask = __connman_util_ipaddr_binary_to_string(ip_mask);
+			SUPPLICANT_DBG("ip_mask : %s\n", data->ip_mask);
+	} else if(g_str_equal(key, "IpAddrGo")) {
+			DBusMessageIter array;
+			char *go_ip_addr;
+			dbus_message_iter_recurse(iter, &array);
+			dbus_message_iter_get_fixed_array(&array, &go_ip_addr, &addr_len);
+
+			data->go_ip_addr = __connman_util_ipaddr_binary_to_string(go_ip_addr);
+			SUPPLICANT_DBG("go_ip_addr : %s\n", data->go_ip_addr);
+	} else if(g_str_equal(key, "freq")) {
+			dbus_message_iter_get_basic(iter, &data->freq);
+			SUPPLICANT_DBG("freq : %d\n", data->freq);
+	}
 }
 
 static void signal_group_success(const char *path, DBusMessageIter *iter)
@@ -3542,16 +4318,137 @@ static void signal_group_failure(const char *path, DBusMessageIter *iter)
 	if (!peer)
 		return;
 
+	peer->status = data.status;
+
 	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_FAILED);
 	peer->connection_requested = false;
 }
 
+static void p2p_group_property(const char *key, DBusMessageIter *iter,
+												void *user_data)
+{
+	GSupplicantGroup *group = user_data;
+
+	SUPPLICANT_DBG("key %s", key);
+
+	if (!key) {
+		callback_p2p_group_started(group);
+		return;
+	}
+
+	if (!iter)
+		return;
+
+	if (g_strcmp0(key, "SSID") == 0) {
+		DBusMessageIter array;
+		char *ssid;
+		int ssid_len;
+
+		dbus_message_iter_recurse(iter, &array);
+		dbus_message_iter_get_fixed_array(&array, &ssid, &ssid_len);
+
+		if (ssid_len > 0 && ssid_len < 33) {
+			group->ssid = g_strndup(ssid, ssid_len);
+		}
+	} else if (g_strcmp0(key, "Passphrase") == 0) {
+		char *passphrase;
+
+		dbus_message_iter_get_basic(iter, &passphrase);
+		group->passphrase = g_strdup(passphrase);
+	} else if (g_strcmp0(key, "Frequency") == 0) {
+		dbus_uint16_t frequency = 0;
+
+		dbus_message_iter_get_basic(iter, &frequency);
+		group->frequency = frequency;
+	}
+}
+
+static void p2p_group_ssid_property(const char *key, DBusMessageIter *iter,
+										void *user_data)
+{
+	GSupplicantGroup *group = user_data;
+	char *ssid;
+	int len = 0;
+	DBusMessageIter iter_array;
+	GSupplicantPeer *peer = NULL;
+
+	if(iter == NULL)
+		return;
+
+	dbus_message_iter_recurse(iter, &iter_array);
+
+	dbus_message_iter_get_fixed_array(&iter_array, &ssid, &len);
+
+	if(len >= MAX_P2P_SSID_LEN)
+		len = MAX_P2P_SSID_LEN - 1;
+
+	group->ssid = g_strndup(ssid, len);
+	callback_p2p_group_started(group);
+}
+
+static void p2p_group_psk_property(const char *key, DBusMessageIter *iter,
+										void *user_data)
+{
+	GSupplicantGroup *group = user_data;
+	int len = 0;
+	unsigned char *psk;
+	char psk_s[65];
+	DBusMessageIter iter_array;
+
+	if(iter == NULL)
+		return;
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
+	{
+		SUPPLICANT_DBG("not array %d\n", dbus_message_iter_get_arg_type(iter));
+		return;
+	}
+
+	dbus_message_iter_recurse(iter, &iter_array);
+
+	dbus_message_iter_get_fixed_array(&iter_array, &psk, &len);
+	__connman_util_byte_to_string(psk, psk_s, len);
+	group->psk = g_strdup(psk_s);
+	SUPPLICANT_DBG("psk : %s\n", group->psk);
+}
+
+static void p2p_group_passphrase_property(const char *key, DBusMessageIter *iter,
+												void *user_data)
+{
+	GSupplicantGroup *group = user_data;
+	char *passphrase;
+
+	if(iter == NULL)
+		return;
+
+	dbus_message_iter_get_basic(iter, &passphrase);
+	group->passphrase = g_strdup(passphrase);
+
+	SUPPLICANT_DBG("passphrase : %s\n", group->passphrase);
+
+}
+
+static void interface_p2p_group_started(GSupplicantGroup *group) {
+
+	if (!group->path)
+		return;
+
+	supplicant_dbus_property_get(group->path, SUPPLICANT_INTERFACE ".Group",
+							"PSK", p2p_group_psk_property, group, NULL);
+
+	supplicant_dbus_property_get(group->path, SUPPLICANT_INTERFACE ".Group",
+							"Passphrase", p2p_group_passphrase_property, group, NULL);
+
+	supplicant_dbus_property_get(group->path, SUPPLICANT_INTERFACE ".Group",
+							"SSID", p2p_group_ssid_property, group, NULL);
+}
+
 static void signal_group_started(const char *path, DBusMessageIter *iter)
 {
 	GSupplicantInterface *interface, *g_interface;
-	struct group_sig_data data = {};
+	struct group_sig_data data = {0,};
 	GSupplicantGroup *group;
-	GSupplicantPeer *peer;
+	GSupplicantPeer *peer = NULL;
 
 	SUPPLICANT_DBG("");
 
@@ -3563,11 +4460,13 @@ static void signal_group_started(const char *path, DBusMessageIter *iter)
 	if (!data.interface_obj_path || !data.group_obj_path)
 		return;
 
-	peer = g_hash_table_lookup(interface->peer_table,
-						interface->pending_peer_path);
-	interface->pending_peer_path = NULL;
-	if (!peer)
-		return;
+	if (interface->pending_peer_path) {
+		peer = g_hash_table_lookup(interface->peer_table,
+							interface->pending_peer_path);
+		interface->pending_peer_path = NULL;
+		if (!peer)
+			return;
+	}
 
 	g_interface = g_hash_table_lookup(interface_table,
 						data.interface_obj_path);
@@ -3587,12 +4486,26 @@ static void signal_group_started(const char *path, DBusMessageIter *iter)
 	group->orig_interface = interface;
 	group->path = g_strdup(data.group_obj_path);
 	group->role = data.role;
+	group->persistent = data.persistent;
+	group->bssid_no_colon = g_strdup(data.dev_addr_buf);
+	group->ip_addr = g_strdup(data.ip_addr);
+	group->ip_mask= g_strdup(data.ip_mask);
+	group->go_ip_addr = g_strdup(data.go_ip_addr);
+	group->frequency = data.freq;
 
 	g_hash_table_insert(interface->group_table, group->path, group);
 	g_hash_table_replace(group_mapping, group->path, group);
 
-	peer->current_group_iface = g_interface;
-	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_STARTED);
+	if (!peer) {
+		peer = g_supplicant_interface_peer_lookup(group->orig_interface, group->bssid_no_colon);
+	}
+
+	if (peer) {
+		peer->current_group_iface = g_interface;
+		callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_STARTED);
+	}
+
+	interface_p2p_group_started(group);
 }
 
 static void remove_peer_group_interface(GHashTable *group_table,
@@ -3620,6 +4533,40 @@ static void remove_peer_group_interface(GHashTable *group_table,
 	}
 }
 
+static void remove_peer_peertable(GSupplicantInterface *interface)
+{
+	GHashTableIter iter;
+	gpointer value, key;
+
+	g_hash_table_iter_init(&iter, interface->peer_table);
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		GSupplicantPeer *peer = value;
+		char *peer_path = key;
+		struct peer_device_data *p2p_data = NULL;
+
+		if (g_hash_table_lookup(p2p_peer_table, peer_path))
+		{
+			if (interface->p2p_peer_path_to_network) {
+				p2p_data = g_hash_table_lookup(interface->p2p_peer_path_to_network, peer_path);
+				if (p2p_data == NULL) {
+					g_hash_table_iter_remove(&iter);
+					continue;
+				}
+
+				g_hash_table_remove(interface->p2p_peer_path_to_network, peer_path);
+				p2p_network_list = g_slist_remove(p2p_network_list, p2p_data);
+
+				g_free(p2p_data->identifier);
+				g_free(p2p_data->path);
+				g_free(p2p_data);
+			}
+
+			g_hash_table_iter_remove(&iter);
+		}
+	}
+}
+
 static void signal_group_finished(const char *path, DBusMessageIter *iter)
 {
 	GSupplicantInterface *interface;
@@ -3640,6 +4587,9 @@ static void signal_group_finished(const char *path, DBusMessageIter *iter)
 	g_hash_table_remove(group_mapping, data.group_obj_path);
 
 	g_hash_table_remove(interface->group_table, data.group_obj_path);
+
+	callback_p2p_group_finished(interface);
+	remove_peer_peertable(interface);
 }
 
 static void signal_group_request(const char *path, DBusMessageIter *iter)
@@ -3647,6 +4597,7 @@ static void signal_group_request(const char *path, DBusMessageIter *iter)
 	GSupplicantInterface *interface;
 	GSupplicantPeer *peer;
 	const char *obj_path;
+	dbus_uint16_t dev_passwd_id = 0;
 
 	SUPPLICANT_DBG("");
 
@@ -3662,1692 +4613,4630 @@ static void signal_group_request(const char *path, DBusMessageIter *iter)
 	if (!peer)
 		return;
 
+	dbus_message_iter_next(iter);
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_UINT16) {
+		SUPPLICANT_DBG("not uint 16\n");
+		return;
+	}
+
+	dbus_message_iter_get_basic(iter, &dev_passwd_id);
+
 	/*
 	 * Peer has been previously found and property set,
 	 * otherwise, defer connection to when peer property
 	 * is set.
 	 */
 	if (peer->identifier)
-		callback_peer_request(peer);
+		callback_peer_request(peer, dev_passwd_id);
 	else
 		g_hash_table_replace(pending_peer_connection, peer->path, peer);
 }
 
-static void signal_group_peer_joined(const char *path, DBusMessageIter *iter)
+static void callback_p2p_invitation_result(GSupplicantInterface *interface, int status)
 {
-	const char *peer_path = NULL;
-	GSupplicantInterface *interface;
-	GSupplicantGroup *group;
-	GSupplicantPeer *peer;
-
-	SUPPLICANT_DBG("");
+	if (!callbacks_pointer)
+		return;
 
-	group = g_hash_table_lookup(group_mapping, path);
-	if (!group)
+	if (!callbacks_pointer->p2p_invitation_result)
 		return;
 
-	dbus_message_iter_get_basic(iter, &peer_path);
-	if (!peer_path)
+	callbacks_pointer->p2p_invitation_result(interface, status);
+}
+
+static void interface_p2p_invitation_result(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	DBusMessageIter dict, entry, value;
+	char *key;
+	int status = 0;
+
+	SUPPLICANT_DBG("interface_p2p_invitation_result");
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY) {
+		SUPPLICANT_DBG("not array\n");
 		return;
+	}
 
-	interface = g_hash_table_lookup(peer_mapping, peer_path);
-	if (!interface)
+	dbus_message_iter_recurse(iter, &dict);
+	if(dbus_message_iter_get_arg_type(&dict) != DBUS_TYPE_DICT_ENTRY) {
+		SUPPLICANT_DBG("not dict\n");
 		return;
+	}
 
-	peer = g_hash_table_lookup(interface->peer_table, peer_path);
-	if (!peer)
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
 		return;
+	}
 
-	group->members = g_slist_prepend(group->members, g_strdup(peer_path));
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "status")) {
+		SUPPLICANT_DBG("not status\n");
+		return;
+	}
 
-	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_JOINED);
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
+
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_get_basic(&value, &status);
+	SUPPLICANT_DBG("status : %d\n", status);
+
+	callback_p2p_invitation_result(interface, status);
 }
 
-static void signal_group_peer_disconnected(const char *path, DBusMessageIter *iter)
+static void signal_invitation_result(const char *path, DBusMessageIter *iter)
 {
-	const char *peer_path = NULL;
 	GSupplicantInterface *interface;
-	GSupplicantGroup *group;
-	GSupplicantPeer *peer;
-	GSList *elem;
 
-	SUPPLICANT_DBG("");
+	SUPPLICANT_DBG("signal invitation result");
 
-	group = g_hash_table_lookup(group_mapping, path);
-	if (!group)
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
 		return;
 
-	dbus_message_iter_get_basic(iter, &peer_path);
-	if (!peer_path)
-		return;
+	interface_p2p_invitation_result(iter, interface);
+}
 
-	for (elem = group->members; elem; elem = elem->next) {
-		if (!g_strcmp0(elem->data, peer_path))
-			break;
-	}
+static void callback_p2p_invitation_received(GSupplicantInterface *interface, GSupplicantPeer *peer, const char *go_dev_addr, bool persistent)
+{
+	if (!callbacks_pointer)
+		return;
 
-	if (!elem)
+	if (!callbacks_pointer->p2p_invitation_received)
 		return;
 
-	g_free(elem->data);
-	group->members = g_slist_delete_link(group->members, elem);
+	callbacks_pointer->p2p_invitation_received(interface, peer, go_dev_addr, persistent);
+}
 
-	interface = g_hash_table_lookup(peer_mapping, peer_path);
-	if (!interface)
+static void callback_p2p_pending_invitation_received(GSupplicantInterface *interface, GSupplicantPeer *peer, void * data)
+{
+	if (!callbacks_pointer)
 		return;
 
-	peer = g_hash_table_lookup(interface->peer_table, peer_path);
-	if (!peer)
+	if (!callbacks_pointer->p2p_invitation_received)
 		return;
 
-	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_DISCONNECTED);
-	peer->connection_requested = false;
+	struct g_supplicant_p2p_inv_recv_info *inv_recv = data;
+	callbacks_pointer->p2p_invitation_received(interface, peer, inv_recv->p2p_go_dev_addr, inv_recv->persistent);
 }
 
-static struct {
-	const char *interface;
-	const char *member;
-	void (*function) (const char *path, DBusMessageIter *iter);
-} signal_map[] = {
-	{ DBUS_INTERFACE_DBUS,  "NameOwnerChanged",  signal_name_owner_changed },
+static gboolean add_pending_invitation_for_peer(gpointer argv)
+{
+	struct g_supplicant_p2p_inv_recv_info *inv_recv = argv;
+	GSupplicantInterface *interface = inv_recv->interface;
 
-	{ SUPPLICANT_INTERFACE, "PropertiesChanged", signal_properties_changed },
-	{ SUPPLICANT_INTERFACE, "InterfaceAdded",    signal_interface_added    },
-	{ SUPPLICANT_INTERFACE, "InterfaceCreated",  signal_interface_added    },
-	{ SUPPLICANT_INTERFACE, "InterfaceRemoved",  signal_interface_removed  },
+	GSupplicantPeer *peer = g_supplicant_interface_peer_lookup(interface, inv_recv->src_addr);
 
-	{ SUPPLICANT_INTERFACE ".Interface", "PropertiesChanged", signal_interface_changed },
-	{ SUPPLICANT_INTERFACE ".Interface", "ScanDone",          signal_scan_done         },
-	{ SUPPLICANT_INTERFACE ".Interface", "BSSAdded",          signal_bss_added         },
-	{ SUPPLICANT_INTERFACE ".Interface", "BSSRemoved",        signal_bss_removed       },
-	{ SUPPLICANT_INTERFACE ".Interface", "NetworkAdded",      signal_network_added     },
-	{ SUPPLICANT_INTERFACE ".Interface", "NetworkRemoved",    signal_network_removed   },
-	{ SUPPLICANT_INTERFACE ".Interface", "StaAuthorized",     signal_sta_authorized    },
-	{ SUPPLICANT_INTERFACE ".Interface", "StaDeauthorized",   signal_sta_deauthorized  },
+	if (!peer && inv_recv->get_invitation_timer_count < 10) {
+			inv_recv_ref = g_timeout_add(100, add_pending_invitation_for_peer, inv_recv);
+			inv_recv->get_invitation_timer_count++;
+			return FALSE;
+	}
+	else if (peer)//Send the signal later
+	{
+		if (peer->path) {
+			SUPPLICANT_DBG("Added signal to list print path %s" , peer->path);
+			struct peer_device_data *p2p_data = g_hash_table_lookup(interface->p2p_peer_path_to_network, peer->path);
+
+			if (!p2p_data && inv_recv->get_invitation_timer_count < 10) {
+				inv_recv_ref = g_timeout_add(100, add_pending_invitation_for_peer, inv_recv);
+				inv_recv->get_invitation_timer_count++;
+				return FALSE;
+			}
 
-	{ SUPPLICANT_INTERFACE ".Interface", "StaAuthorized",     signal_station_connected   },
-	{ SUPPLICANT_INTERFACE ".Interface", "StaDeauthorized",   signal_station_disconnected },
+			if (p2p_data && p2p_data->path && (strcmp(peer->path, p2p_data->path) == 0)) {
+				SUPPLICANT_DBG("Added signal to list print p2p_data->path  %s" , p2p_data->path);
+				callback_p2p_invitation_received(interface, peer, inv_recv->p2p_go_dev_addr, inv_recv->persistent);
+				goto done;
+			}
+		}
 
-	{ SUPPLICANT_INTERFACE ".BSS", "PropertiesChanged", signal_bss_changed   },
+		struct g_supplicant_p2p_peer_signal* signal = g_try_new0(struct g_supplicant_p2p_peer_signal, 1);
+		if(signal == NULL)
+		{
+			goto done;
+		}
 
-	{ SUPPLICANT_INTERFACE ".Interface.WPS", "Credentials", signal_wps_credentials },
-	{ SUPPLICANT_INTERFACE ".Interface.WPS", "Event",       signal_wps_event       },
+		signal->callback_params = (void *)inv_recv;
+		signal->free_function = g_free;
+		signal->dispatch_function = callback_p2p_pending_invitation_received;
+		peer->pending_invitation_signals = g_slist_append(peer->pending_invitation_signals, signal);
 
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeviceFound", signal_peer_found },
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeviceLost",  signal_peer_lost  },
+		SUPPLICANT_DBG("Added signal to list");
+		return FALSE;
+	}
 
-	{ SUPPLICANT_INTERFACE ".Peer", "PropertiesChanged", signal_peer_changed },
+done:
+	g_free(inv_recv);
+	inv_recv_ref = -1;
+	return FALSE;
+}
 
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationSuccess", signal_group_success },
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationFailure", signal_group_failure },
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GroupStarted", signal_group_started },
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GroupFinished", signal_group_finished },
-	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationRequest", signal_group_request },
+static void interface_p2p_invitation_received(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	DBusMessageIter dict, entry, value, array;
+	char *key;
+	int status;
+	int addr_len = 6;
+	unsigned char *bssid, *go_dev_addr, *src_addr;
+	char go_dev_addr_str[13], src_addr_str[13];
+	char *p_go_dev_addr, *p_src_addr;
 
-	{ SUPPLICANT_INTERFACE ".Group", "PeerJoined", signal_group_peer_joined },
-	{ SUPPLICANT_INTERFACE ".Group", "PeerDisconnected", signal_group_peer_disconnected },
+	SUPPLICANT_DBG("interface_p2p_invitation_received");
 
-	{ }
-};
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY) {
+		SUPPLICANT_DBG("not array\n");
+		return;
+	}
 
-static DBusHandlerResult g_supplicant_filter(DBusConnection *conn,
-					DBusMessage *message, void *data)
-{
-	DBusMessageIter iter;
-	const char *path;
-	int i;
+	dbus_message_iter_recurse(iter, &dict);
+	if(dbus_message_iter_get_arg_type(&dict) != DBUS_TYPE_DICT_ENTRY) {
+		SUPPLICANT_DBG("not dict\n");
+		return;
+	}
 
-	path = dbus_message_get_path(message);
-	if (!path)
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
+	}
 
-	if (!dbus_message_iter_init(message, &iter))
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "status")) {
+		SUPPLICANT_DBG("not status\n");
+		return;
+	}
 
-	for (i = 0; signal_map[i].interface; i++) {
-		if (!dbus_message_has_interface(message, signal_map[i].interface))
-			continue;
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-		if (!dbus_message_has_member(message, signal_map[i].member))
-			continue;
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_get_basic(&value, &status);
+	SUPPLICANT_DBG("status : %d\n", status);
+/*
+	if (status == 0) //Persistent group reinvoke case
+		g_supplicant_interface_p2p_listen(interface, 0, 0);
+	else
+*/
+	if (status != 0 && status != 1)
+		return;
 
-		signal_map[i].function(path, &iter);
-		break;
+	dbus_message_iter_next(&dict);
+
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
 	}
 
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "sa")) {
+		SUPPLICANT_DBG("not sa\n");
+		return;
+	}
 
-void g_supplicant_interface_cancel(GSupplicantInterface *interface)
-{
-	SUPPLICANT_DBG("Cancelling any pending DBus calls");
-	supplicant_dbus_method_call_cancel_all(interface);
-	supplicant_dbus_property_call_cancel_all(interface);
-}
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-struct supplicant_regdom {
-	GSupplicantCountryCallback callback;
-	const char *alpha2;
-	const void *user_data;
-};
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_recurse(&value, &array);
 
-static void country_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
-{
-	struct supplicant_regdom *regdom = user_data;
-	int result = 0;
+	dbus_message_iter_get_fixed_array(&array, &src_addr, &addr_len);
 
-	SUPPLICANT_DBG("Country setting result");
+	dbus_message_iter_next(&dict);
 
-	if (!user_data)
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
 		return;
+	}
 
-	if (error) {
-		SUPPLICANT_DBG("Country setting failure %s", error);
-		result = -EINVAL;
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+
+	if(!g_str_equal(key, "go_dev_addr")) {
+		SUPPLICANT_DBG("not go_dev_addr\n");
+		return;
 	}
 
-	if (regdom->callback)
-		regdom->callback(result, regdom->alpha2,
-					(void *) regdom->user_data);
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-	g_free(regdom);
-}
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_recurse(&value, &array);
 
-static void country_params(DBusMessageIter *iter, void *user_data)
-{
-	struct supplicant_regdom *regdom = user_data;
+	dbus_message_iter_get_fixed_array(&array, &go_dev_addr, &addr_len);
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-							&regdom->alpha2);
-}
+	dbus_message_iter_next(&dict);
 
-int g_supplicant_set_country(const char *alpha2,
-				GSupplicantCountryCallback callback,
-					const void *user_data)
-{
-	struct supplicant_regdom *regdom;
-	int ret;
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
+	}
 
-	SUPPLICANT_DBG("Country setting %s", alpha2);
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "bssid")) {
+		if(status == 0)
+			goto go_next; //BSSID is not exist at persistent go case
+		SUPPLICANT_DBG("not bssid\n");
+		return;
+	}
 
-	if (!system_available)
-		return -EFAULT;
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-	regdom = dbus_malloc0(sizeof(*regdom));
-	if (!regdom)
-		return -ENOMEM;
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_recurse(&value, &array);
 
-	regdom->callback = callback;
-	regdom->alpha2 = alpha2;
-	regdom->user_data = user_data;
+	dbus_message_iter_get_fixed_array(&array, &bssid, &addr_len);
 
-	ret =  supplicant_dbus_property_set(SUPPLICANT_PATH, SUPPLICANT_INTERFACE,
-					"Country", DBUS_TYPE_STRING_AS_STRING,
-					country_params, country_result,
-					regdom, NULL);
-	if (ret < 0) {
-		dbus_free(regdom);
-		SUPPLICANT_DBG("Unable to set Country configuration");
-	}
-	return ret;
-}
+go_next:
 
-int g_supplicant_interface_set_country(GSupplicantInterface *interface,
-					GSupplicantCountryCallback callback,
-							const char *alpha2,
-							void *user_data)
-{
-	struct supplicant_regdom *regdom;
-	int ret;
+	__connman_util_byte_to_string(go_dev_addr, go_dev_addr_str, 6);
+	p_go_dev_addr = g_strdup(go_dev_addr_str);
 
-	regdom = dbus_malloc0(sizeof(*regdom));
-	if (!regdom)
-		return -ENOMEM;
+	__connman_util_byte_to_string(src_addr, src_addr_str, 6);
+	p_src_addr = g_strdup(src_addr_str);
 
-	regdom->callback = callback;
-	regdom->alpha2 = alpha2;
-	regdom->user_data = user_data;
+	if (inv_recv_ref != -1) {
+		g_free(p_src_addr);
+		g_free(p_go_dev_addr);
+		return;
+	}
 
-	ret =  supplicant_dbus_property_set(interface->path,
-				SUPPLICANT_INTERFACE ".Interface",
-				"Country", DBUS_TYPE_STRING_AS_STRING,
-				country_params, country_result,
-					regdom, NULL);
-	if (ret < 0) {
-		dbus_free(regdom);
-		SUPPLICANT_DBG("Unable to set Country configuration");
+	struct g_supplicant_p2p_inv_recv_info *inv_recv = g_try_new0(struct g_supplicant_p2p_inv_recv_info, 1);
+	if (!inv_recv) {
+		g_free(p_src_addr);
+		g_free(p_go_dev_addr);
+		return;
 	}
 
-	return ret;
+	inv_recv->interface = interface;
+	inv_recv->p2p_go_dev_addr = p_go_dev_addr;
+	inv_recv->src_addr = p_src_addr;
+	inv_recv->persistent = !status;
+
+	inv_recv_ref = g_timeout_add(100, add_pending_invitation_for_peer, inv_recv);
+
+	return;
 }
 
-bool g_supplicant_interface_has_p2p(GSupplicantInterface *interface)
+static void signal_invitation_received(const char *path, DBusMessageIter *iter)
 {
+	GSupplicantInterface *interface;
+
+	SUPPLICANT_DBG("signal invitation received");
+
+	interface = g_hash_table_lookup(interface_table, path);
 	if (!interface)
-		return false;
+		return;
 
-	return interface->p2p_support;
+	interface_p2p_invitation_received(iter, interface);
 }
 
-struct supplicant_p2p_dev_config {
-	char *device_name;
-	char *dev_type;
-};
-
-static void p2p_device_config_result(const char *error,
-					DBusMessageIter *iter, void *user_data)
+static void empty_free_function(void* ptr)
 {
-	struct supplicant_p2p_dev_config *config = user_data;
-
-	if (error)
-		SUPPLICANT_DBG("Unable to set P2P Device configuration: %s",
-									error);
-
-	g_free(config->device_name);
-	g_free(config->dev_type);
-	dbus_free(config);
+	// Does nothing
 }
 
-static int dev_type_str2bin(const char *type, unsigned char dev_type[8])
+static void fire_p2p_signal_when_network_present(GSupplicantInterface *interface,
+                                                 const char* path,
+                                                 g_supplicant_p2p_network_signal_func signal_func,
+                                                 g_supplicant_p2p_network_signal_free_func free_func,
+                                                 void* signal_params)
 {
-	int length, pos, end;
-	char b[3] = {};
-	char *e = NULL;
+	struct peer_device_data *p2p_data;
 
-	end = strlen(type);
-	for (length = pos = 0; type[pos] != '\0' && length < 8; length++) {
-		if (pos+2 > end)
-			return 0;
 
-		b[0] = type[pos];
-		b[1] = type[pos+1];
+	p2p_data = g_hash_table_lookup(interface->p2p_peer_path_to_network, path);
 
-		dev_type[length] = strtol(b, &e, 16);
-		if (e && *e != '\0')
-			return 0;
+	if (free_func == NULL)
+	{
+		free_func = empty_free_function;
+	}
 
-		pos += 2;
+	if(p2p_data != NULL)
+	{
+		//Send signal right away
+		GSupplicantPeer *peer;
+		peer = g_hash_table_lookup(interface->peer_table, p2p_data->path);
+
+		signal_func(interface, peer, signal_params);
+		free_func(signal_params);
 	}
+	else //Send the signal later
+	{
+		GSupplicantPeer *peer;
+		SUPPLICANT_DBG("network not present, delaying signal dispatch");
 
-	return 8;
-}
+		peer = g_hash_table_lookup(interface->peer_table, path);
 
-static void p2p_device_config_params(DBusMessageIter *iter, void *user_data)
-{
-	struct supplicant_p2p_dev_config *config = user_data;
-	DBusMessageIter dict;
+		if (peer == NULL)
+		{
+			free_func(signal_params);
+			SUPPLICANT_DBG("failed - no peer for path %s", path);
+			return;
+		}
 
-	supplicant_dbus_dict_open(iter, &dict);
+		struct g_supplicant_p2p_peer_signal* signal = g_try_new0(struct g_supplicant_p2p_peer_signal, 1);
+		if(signal == NULL)
+		{
+			free_func(signal_params);
+			return;
+		}
 
-	supplicant_dbus_dict_append_basic(&dict, "DeviceName",
-				DBUS_TYPE_STRING, &config->device_name);
+		signal->callback_params = signal_params;
+		signal->free_function = free_func;
+		signal->dispatch_function = signal_func;
+		peer->pending_signals = g_slist_append(peer->pending_signals, signal);
 
-	if (config->dev_type) {
-		unsigned char dev_type[8] = {}, *type;
-		int len;
+		SUPPLICANT_DBG("Added signal to list");
 
-		len = dev_type_str2bin(config->dev_type, dev_type);
-		if (len) {
-			type = dev_type;
-			supplicant_dbus_dict_append_fixed_array(&dict,
-					"PrimaryDeviceType",
-					DBUS_TYPE_BYTE, &type, len);
-		}
 	}
-
-	supplicant_dbus_dict_close(iter, &dict);
 }
 
-int g_supplicant_interface_set_p2p_device_config(GSupplicantInterface *interface,
-					const char *device_name,
-					const char *primary_dev_type)
+static void interface_p2p_prov_disc_request_or_response(DBusMessageIter *iter,
+					void *user_data, bool is_request, char *wps_method)
 {
-	struct supplicant_p2p_dev_config *config;
-	int ret;
+	GSupplicantInterface *interface = user_data;
+	char *path, *pin = NULL;
 
-	SUPPLICANT_DBG("P2P Device settings %s/%s",
-					device_name, primary_dev_type);
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_OBJECT_PATH) {
+		SUPPLICANT_DBG("not object path\n");
+		return;
+	}
 
-	config = dbus_malloc0(sizeof(*config));
-	if (!config)
-		return -ENOMEM;
+	dbus_message_iter_get_basic(iter, &path);
 
-	config->device_name = g_strdup(device_name);
-	config->dev_type = g_strdup(primary_dev_type);
+	if (g_str_equal(wps_method, "disp_pin")) {
+		dbus_message_iter_next(iter);
 
-	ret = supplicant_dbus_property_set(interface->path,
-				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
-				"P2PDeviceConfig",
-				DBUS_TYPE_ARRAY_AS_STRING
-				DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-				DBUS_TYPE_STRING_AS_STRING
-				DBUS_TYPE_VARIANT_AS_STRING
-				DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
-				p2p_device_config_params,
-				p2p_device_config_result, config, NULL);
-	if (ret < 0) {
-		g_free(config->device_name);
-		g_free(config->dev_type);
-		dbus_free(config);
-		SUPPLICANT_DBG("Unable to set P2P Device configuration");
+		if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_STRING) {
+			SUPPLICANT_DBG("not string\n");
+			return;
+		}
+
+		dbus_message_iter_get_basic(iter, &pin);
+
+		if (!pin || strlen(pin) != WPAS_P2P_WPS_PIN_LENGTH) {
+			SUPPLICANT_DBG("strange\n");
+			return;
+		}
 	}
 
-	return ret;
+	g_supplicant_p2p_prov_dics_signal_func callback_method = NULL;
+
+	if (is_request) {
+		if (g_str_equal(wps_method, "pbc"))
+			callback_method = callback_p2p_prov_disc_requested_pbc;
+		else if (g_str_equal(wps_method, "enter_pin"))
+			callback_method = callback_p2p_prov_disc_requested_enter_pin;
+		else if (g_str_equal(wps_method, "disp_pin"))
+			callback_method = callback_p2p_prov_disc_requested_display_pin;
+	}
+	else {
+		if (g_str_equal(wps_method, "enter_pin"))
+			callback_method = callback_p2p_prov_disc_response_enter_pin;
+		else if (g_str_equal(wps_method, "disp_pin"))
+			callback_method = callback_p2p_prov_disc_response_display_pin;
+	}
+
+	if (callback_method)
+	{
+		pin = g_strdup(pin);
+		fire_p2p_signal_when_network_present(interface,
+		                                     path,
+		                                     callback_method,
+		                                     g_free,
+		                                     (void *)pin);
+	}
 }
 
-static gboolean peer_lookup_by_identifier(gpointer key, gpointer value,
-							gpointer user_data)
+static void signal_prov_disc_requested_pbc(const char *path, DBusMessageIter *iter)
 {
-	const GSupplicantPeer *peer = value;
-	const char *identifier = user_data;
+	GSupplicantInterface *interface;
 
-	if (!g_strcmp0(identifier, peer->identifier))
-		return TRUE;
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
 
-	return FALSE;
+	interface_p2p_prov_disc_request_or_response(iter, interface, true, "pbc");
 }
 
-GSupplicantPeer *g_supplicant_interface_peer_lookup(GSupplicantInterface *interface,
-							const char *identifier)
+static void signal_prov_disc_requested_enter_pin(const char *path, DBusMessageIter *iter)
 {
-	GSupplicantPeer *peer;
+	GSupplicantInterface *interface;
 
-	peer = g_hash_table_find(interface->peer_table,
-					peer_lookup_by_identifier,
-					(void *) identifier);
-	return peer;
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
+
+	interface_p2p_prov_disc_request_or_response(iter, interface, true, "enter_pin");
 }
 
-static void interface_create_data_free(struct interface_create_data *data)
+static void signal_prov_disc_requested_disp_pin(const char *path, DBusMessageIter *iter)
 {
-	g_free(data->ifname);
-	g_free(data->driver);
-	g_free(data->bridge);
-	dbus_free(data);
+	GSupplicantInterface *interface;
+
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
+
+	interface_p2p_prov_disc_request_or_response(iter, interface, true, "disp_pin");
 }
 
-static bool interface_exists(GSupplicantInterface *interface,
-				const char *path)
+static void signal_prov_disc_response_enter_pin(const char *path, DBusMessageIter *iter)
 {
-	GSupplicantInterface *tmp;
+	GSupplicantInterface *interface;
 
-	tmp = g_hash_table_lookup(interface_table, path);
-	if (tmp && tmp == interface)
-		return true;
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
 
-	return false;
+	interface_p2p_prov_disc_request_or_response(iter, interface, false, "enter_pin");
 }
 
-static void interface_create_property(const char *key, DBusMessageIter *iter,
-							void *user_data)
+static void signal_prov_disc_response_disp_pin(const char *path, DBusMessageIter *iter)
 {
-	struct interface_create_data *data = user_data;
-	GSupplicantInterface *interface = data->interface;
-
-	if (!key) {
-		if (data->callback) {
-			data->callback(0, data->interface, data->user_data);
-			callback_p2p_support(interface);
-		}
+	GSupplicantInterface *interface;
 
-		interface_create_data_free(data);
-	}
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
 
-	interface_property(key, iter, interface);
+	interface_p2p_prov_disc_request_or_response(iter, interface, false, "disp_pin");
 }
 
-static void interface_create_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
+static void interface_p2p_prov_disc_fail(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_create_data *data = user_data;
-	const char *path = NULL;
-	int err;
-
-	SUPPLICANT_DBG("");
+	GSupplicantInterface *interface = user_data;
+	GSupplicantPeer *peer;
+	const char *path;
+	int status;
 
-	if (error) {
-		g_warning("error %s", error);
-		err = -EIO;
-		goto done;
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_OBJECT_PATH) {
+		SUPPLICANT_DBG("not object path\n");
+		return;
 	}
 
 	dbus_message_iter_get_basic(iter, &path);
-	if (!path) {
-		err = -EINVAL;
-		goto done;
-	}
 
-	if (!system_available) {
-		err = -EFAULT;
-		goto done;
-	}
+	dbus_message_iter_next(iter);
 
-	data->interface = g_hash_table_lookup(interface_table, path);
-	if (!data->interface) {
-		data->interface = interface_alloc(path);
-		if (!data->interface) {
-			err = -ENOMEM;
-			goto done;
-		}
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_INT32) {
+		SUPPLICANT_DBG("not int32\n");
+		return;
 	}
 
-	err = supplicant_dbus_property_get_all(path,
-					SUPPLICANT_INTERFACE ".Interface",
-					interface_create_property, data,
-					NULL);
-	if (err == 0)
-		return;
+	dbus_message_iter_get_basic(iter, &status);
 
-done:
-	if (data->callback)
-		data->callback(err, NULL, data->user_data);
+	peer = g_hash_table_lookup(interface->peer_table, path);
 
-	interface_create_data_free(data);
+	if (!peer)
+		return;
+
+	callback_p2p_prov_disc_fail(interface, peer, status);
 }
 
-static void interface_create_params(DBusMessageIter *iter, void *user_data)
+static void signal_prov_disc_fail(const char *path, DBusMessageIter *iter)
 {
-	struct interface_create_data *data = user_data;
-	DBusMessageIter dict;
-	char *config_file = NULL;
+	GSupplicantInterface *interface;
 
-	SUPPLICANT_DBG("");
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface)
+		return;
 
-	supplicant_dbus_dict_open(iter, &dict);
+	interface_p2p_prov_disc_fail(iter, interface);
+}
 
-	supplicant_dbus_dict_append_basic(&dict, "Ifname",
-					DBUS_TYPE_STRING, &data->ifname);
+static void p2p_persistent_group_property_by_added(const char *key, DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantP2PPersistentGroup *persistent_group = user_data;
 
-	if (data->driver)
-		supplicant_dbus_dict_append_basic(&dict, "Driver",
-					DBUS_TYPE_STRING, &data->driver);
+	if(persistent_group == NULL){
+		return;
+	}
 
-	if (data->bridge)
-		supplicant_dbus_dict_append_basic(&dict, "BridgeIfname",
-					DBUS_TYPE_STRING, &data->bridge);
+	if (key == NULL) {
+		callback_p2p_persistent_group_added(persistent_group->interface, persistent_group);
+		return;
+	}
 
-	config_file = g_hash_table_lookup(config_file_table, data->ifname);
-	if (config_file) {
-		SUPPLICANT_DBG("[%s] ConfigFile %s", data->ifname, config_file);
+	if(g_strcmp0(key, "bssid") == 0) {
+		char *bssid;
+		dbus_message_iter_get_basic(iter, &bssid);
+		persistent_group->bssid = g_strdup(bssid);
+		remove_colon(bssid);
+		persistent_group->bssid_no_colon = g_strdup(bssid);
+		SUPPLICANT_DBG("bssid : %s\n", persistent_group->bssid);
+	} else if(g_strcmp0(key, "binary-ssid") == 0) {
+		/*
+		 * In persistent case, when p2p-SSID is in Korean,
+		 * connman cannot save the persistent information in connman config file.
+		 * It changes string to byte array in Korean SSID which is encoded EUC-KR.
+		 */
+		const char *ssid;
+		int len = 0;
+		DBusMessageIter iter_array;
+		dbus_message_iter_recurse(iter, &iter_array);
+
+		dbus_message_iter_get_fixed_array(&iter_array, &ssid, &len);
+
+		if(len >= MAX_P2P_SSID_LEN)
+			len = MAX_P2P_SSID_LEN - 1;
+
+		persistent_group->ssid = g_strndup(ssid, len);
+		SUPPLICANT_DBG("ssid : %s\n", persistent_group->ssid);
+	} else if(g_strcmp0(key, "psk") == 0) {
+		const char *psk;
+		dbus_message_iter_get_basic(iter, &psk);
+		persistent_group->psk = g_strdup(psk);
+		SUPPLICANT_DBG("psk : %s\n", persistent_group->psk);
+	}
+}
 
-		supplicant_dbus_dict_append_basic(&dict, "ConfigFile",
-					DBUS_TYPE_STRING, &config_file);
+static void interface_persistent_group_added(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	char *pg_path;
+	int ret;
+	GSupplicantP2PPersistentGroup *persistent_group;
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_OBJECT_PATH) {
+		SUPPLICANT_DBG("not object path\n");
+		return;
 	}
 
-    if (data->config_file != NULL)
-            supplicant_dbus_dict_append_basic(&dict, "ConfigFile",
-                                    DBUS_TYPE_STRING, &data->config_file);
+	dbus_message_iter_get_basic(iter, &pg_path);
 
+	/* signal data parsed if needed */
 
-	supplicant_dbus_dict_close(iter, &dict);
+	persistent_group = g_try_new0(GSupplicantP2PPersistentGroup, 1);
+	if (persistent_group == NULL){
+		return;
+	}
+
+	persistent_group->interface = interface;
+	persistent_group->path = g_strdup(pg_path);
+
+	ret=supplicant_dbus_property_get_all(persistent_group->path,
+					SUPPLICANT_INTERFACE ".PersistentGroup",
+					p2p_persistent_group_property_by_added, persistent_group, NULL);
+	if(ret<0) {
+		g_free(persistent_group);
+	}
 }
 
-static void interface_get_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
+static void signal_persistent_group_added(const char *path, DBusMessageIter *iter)
 {
-	struct interface_create_data *data = user_data;
 	GSupplicantInterface *interface;
-	const char *path = NULL;
-	int err;
 
-	SUPPLICANT_DBG("");
+	SUPPLICANT_DBG("signal persistent group added");
 
-	if (error) {
-		SUPPLICANT_DBG("Interface not created yet");
-		goto create;
-	}
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
+		return;
 
-	dbus_message_iter_get_basic(iter, &path);
-	if (!path) {
-		err = -EINVAL;
-		goto done;
-	}
+	interface_persistent_group_added(iter, interface);
+}
 
-	interface = g_hash_table_lookup(interface_table, path);
-	if (!interface) {
-		err = -ENOENT;
-		goto done;
-	}
+static void interface_persistent_group_removed(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	char *pg_path;
 
-	if (data->callback) {
-		data->callback(0, interface, data->user_data);
-		callback_p2p_support(interface);
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_OBJECT_PATH) {
+		SUPPLICANT_DBG("not object path\n");
+		return;
 	}
 
-	interface_create_data_free(data);
+	dbus_message_iter_get_basic(iter, &pg_path);
 
-	return;
+	callback_p2p_persistent_group_removed(interface, pg_path);
+}
 
-create:
-	if (!system_available) {
-		err = -EFAULT;
-		goto done;
-	}
+static void signal_persistent_group_removed(const char *path, DBusMessageIter *iter)
+{
+	GSupplicantInterface *interface;
 
-	SUPPLICANT_DBG("Creating interface");
+	SUPPLICANT_DBG("signal persistent group removed");
 
-	err = supplicant_dbus_method_call(SUPPLICANT_PATH,
-						SUPPLICANT_INTERFACE,
-						"CreateInterface",
-						interface_create_params,
-						interface_create_result, data,
-						NULL);
-	if (err == 0)
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
 		return;
 
-done:
-	if (data->callback)
-		data->callback(err, NULL, data->user_data);
-
-	interface_create_data_free(data);
+	interface_persistent_group_removed(iter, interface);
 }
-
-static void interface_get_params(DBusMessageIter *iter, void *user_data)
+static void interface_p2p_sd_response(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_create_data *data = user_data;
+	GSupplicantInterface *interface = user_data;
+	DBusMessageIter dict, entry, value, array;
+	char *key;
+	char *peer_path;
+	dbus_uint16_t indicator;
+	int tlv_len = 0;
+	unsigned char *tlv;
 
-	SUPPLICANT_DBG("");
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY) {
+		SUPPLICANT_DBG("not array\n");
+		return;
+	}
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &data->ifname);
-}
+	dbus_message_iter_recurse(iter, &dict);
+	if(dbus_message_iter_get_arg_type(&dict) != DBUS_TYPE_DICT_ENTRY) {
+		SUPPLICANT_DBG("not dict\n");
+		return;
+	}
 
-int g_supplicant_interface_create(const char *ifname, const char *driver,
-					const char *bridge, const char *config_file,
-					GSupplicantInterfaceCallback callback,
-							void *user_data)
-{
-	struct interface_create_data *data;
-	int ret;
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
+	}
 
-	SUPPLICANT_DBG("ifname %s", ifname);
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "peer_object")) {
+		SUPPLICANT_DBG("not peer_object\n");
+		return;
+	}
 
-	if (!ifname)
-		return -EINVAL;
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-	if (!system_available)
-		return -EFAULT;
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_get_basic(&value, &peer_path);
+	SUPPLICANT_DBG("peer_path : %s\n", peer_path);
 
-	data = dbus_malloc0(sizeof(*data));
-	if (!data)
-		return -ENOMEM;
+	dbus_message_iter_next(&dict);
 
-	data->ifname = g_strdup(ifname);
-	data->driver = g_strdup(driver);
-	data->bridge = g_strdup(bridge);
-	data->config_file = g_strdup(config_file);
-	data->callback = callback;
-	data->user_data = user_data;
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
+	}
 
-	ret = supplicant_dbus_method_call(SUPPLICANT_PATH,
-						SUPPLICANT_INTERFACE,
-						"GetInterface",
-						interface_get_params,
-						interface_get_result, data,
-						NULL);
-	if (ret < 0)
-		interface_create_data_free(data);
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "update_indicator")) {
+		SUPPLICANT_DBG("not update_indicator\n");
+		return;
+	}
 
-	return ret;
-}
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-static void interface_remove_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
-{
-	struct interface_data *data = user_data;
-	int err;
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_get_basic(&value, &indicator);
+	SUPPLICANT_DBG("indicator : %d\n", indicator);
 
-	if (error) {
-		err = -EIO;
-		SUPPLICANT_DBG("error: %s", error);
-		goto done;
+	dbus_message_iter_next(&dict);
+
+	dbus_message_iter_recurse(&dict, &entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
 	}
 
-	if (!system_available) {
-		err = -EFAULT;
-		goto done;
+	dbus_message_iter_get_basic(&entry, &key);
+	SUPPLICANT_DBG("key : %s\n", key);
+	if(!g_str_equal(key, "tlvs")) {
+		SUPPLICANT_DBG("not tlvs\n");
+		return;
 	}
 
-	/*
-	 * The gsupplicant interface is already freed by the InterfaceRemoved
-	 * signal callback. Simply invoke the interface_data callback.
-	 */
-	err = 0;
+	dbus_message_iter_next(&entry);
+	if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT) {
+		SUPPLICANT_DBG("not variant\n");
+		return;
+	}
 
-done:
-	g_free(data->path);
+	dbus_message_iter_recurse(&entry, &value);
+	dbus_message_iter_recurse(&value, &array);
 
-	if (data->callback)
-		data->callback(err, NULL, data->user_data);
+	dbus_message_iter_get_fixed_array(&array, &tlv, &tlv_len);
 
-	dbus_free(data);
+	GSupplicantPeer *peer;
+	peer = g_hash_table_lookup(interface->peer_table, peer_path);
+	if (!peer)
+	   return;
+
+	callback_p2p_sd_response(interface, peer, indicator, tlv, tlv_len);
 }
 
+static void signal_sd_response(const char *path, DBusMessageIter *iter)
+{
+	GSupplicantInterface *interface;
 
-static void interface_remove_params(DBusMessageIter *iter, void *user_data)
+	SUPPLICANT_DBG("signal service discovery response");
+
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
+		return;
+
+	interface_p2p_sd_response(iter, interface);
+}
+
+static void callback_p2p_sd_asp_response(GSupplicantInterface *interface, GSupplicantPeer *peer,
+										 unsigned char transaction_id,
+										 unsigned int advertisement_id,
+										 unsigned char service_status,
+										 dbus_uint16_t config_method,
+										 const char* service_name,
+										 const char* service_info)
 {
-	struct interface_data *data = user_data;
+	if (callbacks_pointer == NULL)
+		return;
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
-							&data->interface->path);
+	if (callbacks_pointer->p2p_sd_asp_response == NULL)
+		return;
+
+	callbacks_pointer->p2p_sd_asp_response(interface, peer,
+									   transaction_id,
+									   advertisement_id,
+									   service_status,
+									   config_method,
+									   service_name,
+									   service_info);
 }
+static void interface_p2p_sd_asp_response(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	const char *peer_path;
+	unsigned char transaction_id;
+	unsigned int advertisement_id;
+	unsigned char service_status;
+	dbus_uint16_t config_method;
+	const char* service_name = NULL;
+	const char* service_info = NULL;
+
+	if (!dbus_message_get_args_from_array_of_sv(iter,
+												DBUS_TYPE_OBJECT_PATH, "peer_object", &peer_path, true,
+												DBUS_TYPE_BYTE, "service_transaction_id", &transaction_id, true,
+												DBUS_TYPE_UINT32, "adv_id", &advertisement_id, true,
+												DBUS_TYPE_BYTE, "service_status", &service_status, true,
+												DBUS_TYPE_UINT16, "config_method", &config_method, true,
+												DBUS_TYPE_STRING, "service_name", &service_name, true,
+												DBUS_TYPE_STRING, "service_info", &service_info, false,
+												DBUS_TYPE_INVALID)) {
+		SUPPLICANT_DBG("could not parse DBUS message\n");
+		return;
+	}
 
 
-int g_supplicant_interface_remove(GSupplicantInterface *interface,
-			GSupplicantInterfaceCallback callback,
-							void *user_data)
+	GSupplicantPeer *peer;
+	peer = g_hash_table_lookup(interface->peer_table, peer_path);
+	if (!peer)
+	   return;
+
+	callback_p2p_sd_asp_response(interface, peer,
+								 transaction_id,
+								 advertisement_id,
+								 service_status,
+								 config_method,
+								 service_name,
+								 service_info);
+}
+
+static void signal_sd_asp_response(const char *path, DBusMessageIter *iter)
 {
-	struct interface_data *data;
-	int ret;
+	GSupplicantInterface *interface;
 
-	if (!interface)
-		return -EINVAL;
+	SUPPLICANT_DBG("signal service discovery ASP response");
 
-	if (!system_available)
-		return -EFAULT;
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
+		return;
 
-	g_supplicant_interface_cancel(interface);
+	interface_p2p_sd_asp_response(iter, interface);
+}
 
-	data = dbus_malloc0(sizeof(*data));
-	if (!data)
-		return -ENOMEM;
 
-	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->callback = callback;
-	data->user_data = user_data;
+static void interface_p2ps_prov_done(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantInterface *interface = user_data;
+	const char *path;
+	GSupplicantP2PSProvisionSignalParams* params;
+	const char* service_mac = "";
+	const char* session_mac = "";
+	const char* group_mac = "";
+
+	params = g_try_new0(GSupplicantP2PSProvisionSignalParams, 1);
+	if(params == NULL)
+		return;
+
+	if (!dbus_message_get_args_from_array_of_sv(iter,
+												DBUS_TYPE_OBJECT_PATH, "peer_object", &path, true,
+												DBUS_TYPE_UINT32, "adv_id", &params->advertisement_id, true,
+												DBUS_TYPE_STRING, "adv_mac", &service_mac, true,
+												DBUS_TYPE_UINT32, "session_id", &params->session_id, true,
+												DBUS_TYPE_STRING, "session_mac", &session_mac, true,
+												DBUS_TYPE_UINT32, "status", &params->status, true,
+												DBUS_TYPE_UINT32, "connection_capability", &params->connection_capability, true,
+												DBUS_TYPE_UINT32, "passwd_id", &params->password_id, true,
+												DBUS_TYPE_UINT32, "persist", &params->persist, false,
+												DBUS_TYPE_STRING, "group_mac", &group_mac, false,
+												//DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, "feature_capability", &feature_capability_array, &feature_capability_len,
+												DBUS_TYPE_INVALID)) {
+		SUPPLICANT_DBG("could not parse DBUS message\n");
+		g_free(params);
+		return;
+	}
 
-	ret = supplicant_dbus_method_call(SUPPLICANT_PATH,
-						SUPPLICANT_INTERFACE,
-						"RemoveInterface",
-						interface_remove_params,
-						interface_remove_result, data,
-						NULL);
-	if (ret < 0) {
-		g_free(data->path);
-		dbus_free(data);
+	(void)g_strlcpy(params->session_mac, session_mac, 18);
+	(void)g_strlcpy(params->service_mac, service_mac, 18);
+	(void)g_strlcpy(params->group_mac, group_mac, 18);
+
+	GSupplicantPeer *peer;
+	peer = g_hash_table_lookup(interface->peer_table, path);
+	if (!peer) {
+	   g_free(params);
+	   return;
 	}
-	return ret;
+
+	fire_p2p_signal_when_network_present(interface,
+	                                     path,
+	                                     (g_supplicant_p2p_network_signal_func)callback_p2ps_prov_done,
+	                                     g_free,
+	                                     params);
+	//callback_p2ps_prov_done(interface, peer, params);
 }
 
-static void interface_scan_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
+static void interface_p2ps_prov_start(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_scan_data *data = user_data;
-	int err = 0;
+	GSupplicantInterface *interface = user_data;
+	const char *path;
+	GSupplicantP2PSProvisionSignalParams* params;
+	const char* service_mac = "";
+	const char* session_mac = "";
+	const char* session_info = "";
 
-	if (error) {
-		SUPPLICANT_DBG("error %s", error);
-		err = -EIO;
-	}
+	params = g_try_new0(GSupplicantP2PSProvisionSignalParams, 1);
+	if(params == NULL)
+		return;
 
-	/* A non ready interface cannot send/receive anything */
-	if (interface_exists(data->interface, data->path)) {
-		if (!data->interface->ready)
-			err = -ENOLINK;
+	SUPPLICANT_DBG("");
+
+	if (!dbus_message_get_args_from_array_of_sv(iter,
+												DBUS_TYPE_OBJECT_PATH, "peer_object", &path, true,
+												DBUS_TYPE_UINT32, "adv_id", &params->advertisement_id, true,
+												DBUS_TYPE_STRING, "adv_mac", &service_mac, true,
+												DBUS_TYPE_UINT32, "session_id", &params->session_id, true,
+												DBUS_TYPE_STRING, "session_mac", &session_mac, true,
+												DBUS_TYPE_UINT32, "connection_capability", &params->connection_capability, true,
+												DBUS_TYPE_UINT32, "passwd_id", &params->password_id, false,
+												DBUS_TYPE_STRING, "session_info", &session_info, false,
+												//TODO: get feature_cap
+												//DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, "feature_capability", &feature_capability_array, &feature_capability_len,
+												DBUS_TYPE_INVALID)) {
+		SUPPLICANT_DBG("could not parse DBUS message\n");
+		g_free(params);
+		return;
 	}
 
-	g_free(data->path);
+	(void)g_strlcpy(params->session_mac, session_mac, 18);
+	(void)g_strlcpy(params->service_mac, service_mac, 18);
+	(void)g_strlcpy(params->session_info, session_info, 150);
 
-	if (err != 0) {
-		if (data->callback)
-			data->callback(err, data->interface, data->user_data);
-	} else {
-		data->interface->scan_callback = data->callback;
-		data->interface->scan_data = data->user_data;
+	SUPPLICANT_DBG("");
+	GSupplicantPeer *peer;
+	peer = g_hash_table_lookup(interface->peer_table, path);
+	if (!peer) {
+	   g_free(params);
+	   return;
 	}
 
-	if (data->scan_params)
-		g_supplicant_free_scan_params(data->scan_params);
-
-	dbus_free(data);
+	fire_p2p_signal_when_network_present(interface,
+	                                     path,
+	                                     (g_supplicant_p2p_network_signal_func)callback_p2ps_prov_start,
+	                                     g_free,
+	                                     params);
 }
 
-static void add_scan_frequency(DBusMessageIter *iter, unsigned int freq)
-{
-	DBusMessageIter data;
-	unsigned int width = 0; /* Not used by wpa_supplicant atm */
 
-	dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, &data);
+static void signal_p2ps_prov_start(const char *path, DBusMessageIter *iter)
+{
+	GSupplicantInterface *interface;
+	SUPPLICANT_DBG("");
 
-	dbus_message_iter_append_basic(&data, DBUS_TYPE_UINT32, &freq);
-	dbus_message_iter_append_basic(&data, DBUS_TYPE_UINT32, &width);
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
+		return;
 
-	dbus_message_iter_close_container(iter, &data);
+	interface_p2ps_prov_start(iter, interface);
 }
 
-static void add_scan_frequencies(DBusMessageIter *iter,
-						void *user_data)
+static void signal_p2ps_prov_done(const char *path, DBusMessageIter *iter)
 {
-	GSupplicantScanParams *scan_data = user_data;
-	unsigned int freq;
-	int i;
+	GSupplicantInterface *interface;
 
-	for (i = 0; i < scan_data->num_freqs; i++) {
-		freq = scan_data->freqs[i];
-		if (!freq)
-			break;
+	interface = g_hash_table_lookup(interface_table, path);
+	if (interface == NULL)
+		return;
 
-		add_scan_frequency(iter, freq);
-	}
+	interface_p2ps_prov_done(iter, interface);
 }
+static void extract_peer_with_ip(const char *path, DBusMessageIter *iter, connman_bool_t joined, bool is_ip_present);
 
-static void append_ssid(DBusMessageIter *iter,
-			const void *ssid, unsigned int len)
+static void signal_group_peer_joined(const char *path, DBusMessageIter *iter)
 {
-	DBusMessageIter array;
+/*
+	const char *peer_path = NULL;
+	GSupplicantInterface *interface;
+	GSupplicantGroup *group;
+	GSupplicantPeer *peer;
 
-	dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
-	DBUS_TYPE_BYTE_AS_STRING, &array);
+	SUPPLICANT_DBG("");
 
-	dbus_message_iter_append_fixed_array(&array, DBUS_TYPE_BYTE,
-								&ssid, len);
-	dbus_message_iter_close_container(iter, &array);
+	group = g_hash_table_lookup(group_mapping, path);
+	if (!group)
+		return;
+
+	dbus_message_iter_get_basic(iter, &peer_path);
+	if (!peer_path)
+		return;
+
+	interface = g_hash_table_lookup(peer_mapping, peer_path);
+	if (!interface)
+		return;
+
+	peer = g_hash_table_lookup(interface->peer_table, peer_path);
+	if (!peer)
+		return;
+
+	group->members = g_slist_prepend(group->members, g_strdup(peer_path));
+
+	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_JOINED);
+*/
+	extract_peer_with_ip(path, iter, TRUE, false);
 }
 
-static void append_ssids(DBusMessageIter *iter, void *user_data)
+static gboolean peer_joined_with_ip(gpointer data)
 {
-	GSupplicantScanParams *scan_data = user_data;
-	GSList *list;
+	GSupplicantPeer *peer = data;
 
-	for (list = scan_data->ssids; list; list = list->next) {
-		struct scan_ssid *scan_ssid = list->data;
+	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_JOINED);
 
-		append_ssid(iter, scan_ssid->ssid, scan_ssid->ssid_len);
-	}
+	return FALSE;
 }
 
-static void supplicant_add_scan_frequency(DBusMessageIter *dict,
-		supplicant_dbus_array_function function,
-					void *user_data)
+static bool find_p2p_network(GSupplicantRequestedPeer *requested_peer)
 {
-	GSupplicantScanParams *scan_params = user_data;
-	DBusMessageIter entry, value, array;
-	const char *key = "Channels";
+	GSList *item;
+	struct peer_device_data *p2p_network=NULL;
+	unsigned char p2p_dev_addr_byte[6] = {0,};
+	int i;
+	bool same = false;
 
-	if (scan_params->freqs && scan_params->freqs[0] != 0) {
-		dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-						NULL, &entry);
+	if (requested_peer == NULL)
+		return false;
 
-		dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+	string_to_byte(requested_peer->requested_p2p_dev_addr, p2p_dev_addr_byte);
 
-		dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-					DBUS_TYPE_ARRAY_AS_STRING
-					DBUS_STRUCT_BEGIN_CHAR_AS_STRING
-					DBUS_TYPE_UINT32_AS_STRING
-					DBUS_TYPE_UINT32_AS_STRING
-					DBUS_STRUCT_END_CHAR_AS_STRING,
-					&value);
+	item = p2p_network_list;
 
-		dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-					DBUS_STRUCT_BEGIN_CHAR_AS_STRING
-					DBUS_TYPE_UINT32_AS_STRING
-					DBUS_TYPE_UINT32_AS_STRING
-					DBUS_STRUCT_END_CHAR_AS_STRING,
-					&array);
+	while(item) {
+		p2p_network = item->data;
+		same = true;
+		for(i = 0; i < 6; i++) {
+			if(p2p_network->p2p_device_addr[i] != p2p_dev_addr_byte[i]) {
+				same = false;
+				break;
+			}
+		}
 
-		if (function)
-			function(&array, user_data);
+		if(same)
+			break;
 
-		dbus_message_iter_close_container(&value, &array);
-		dbus_message_iter_close_container(&entry, &value);
-		dbus_message_iter_close_container(dict, &entry);
+		item = g_slist_next(item);
+		p2p_network = NULL;
 	}
+
+	requested_peer->found_p2p_network = p2p_network;
+
+	return same;
 }
 
-static void interface_scan_params(DBusMessageIter *iter, void *user_data)
+static gboolean requested_peer_joined_with_ip(gpointer data)
 {
-	DBusMessageIter dict;
-	const char *type = "passive";
-	struct interface_scan_data *data = user_data;
-
-	supplicant_dbus_dict_open(iter, &dict);
+	GSupplicantRequestedPeer *requested_peer = data;
 
-	if (data && data->scan_params) {
-		type = "active";
+	GSupplicantGroup *group;
+	GSupplicantInterface *interface;
+	GSupplicantPeer *peer;
+	struct peer_device_data *p2p_network=NULL;
 
-		supplicant_dbus_dict_append_basic(&dict, "Type",
-					DBUS_TYPE_STRING, &type);
+	if (requested_peer == NULL)
+			return FALSE;
 
+	group = g_hash_table_lookup(group_mapping, requested_peer->requested_path);
+	if (!group)
+		goto error;
 
-		if (data->scan_params->ssids) {
-			supplicant_dbus_dict_append_array(&dict, "SSIDs",
-							DBUS_TYPE_STRING,
-							append_ssids,
-							data->scan_params);
-		}
-		supplicant_add_scan_frequency(&dict, add_scan_frequencies,
-						data->scan_params);
-	} else
-		supplicant_dbus_dict_append_basic(&dict, "Type",
-					DBUS_TYPE_STRING, &type);
+	if (requested_peer->found_p2p_network == NULL){
+		if(!find_p2p_network(requested_peer))
+			goto error;
+	}
 
-	supplicant_dbus_dict_close(iter, &dict);
-}
+	p2p_network = requested_peer->found_p2p_network;
 
-static int interface_ready_to_scan(GSupplicantInterface *interface)
-{
+	interface = g_hash_table_lookup(peer_mapping, p2p_network->path);
 	if (!interface)
-		return -EINVAL;
-
-	if (!system_available)
-		return -EFAULT;
-
-	if (interface->scanning)
-		return -EALREADY;
+		goto error;
 
-	switch (interface->state) {
-	case G_SUPPLICANT_STATE_AUTHENTICATING:
-	case G_SUPPLICANT_STATE_ASSOCIATING:
-	case G_SUPPLICANT_STATE_ASSOCIATED:
-	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
-	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
-		return -EBUSY;
-	case G_SUPPLICANT_STATE_UNKNOWN:
-	case G_SUPPLICANT_STATE_DISABLED:
-	case G_SUPPLICANT_STATE_DISCONNECTED:
-	case G_SUPPLICANT_STATE_INACTIVE:
-	case G_SUPPLICANT_STATE_SCANNING:
-	case G_SUPPLICANT_STATE_COMPLETED:
-		break;
+	peer = g_hash_table_lookup(interface->peer_table, p2p_network->path);
+	if (!peer) {
+		g_hash_table_remove(peer_mapping, requested_peer->requested_path);
+		goto error;
 	}
 
-	return 0;
-}
+	peer->current_group_iface = group->interface;
+	if (requested_peer->requested_is_ip_present) {
+		peer->ip_addr = g_strdup(requested_peer->requested_ip_addr);
+	}
+	group->members = g_slist_prepend(group->members, g_strdup(p2p_network->path));
 
-int g_supplicant_interface_scan(GSupplicantInterface *interface,
-				GSupplicantScanParams *scan_data,
-				GSupplicantInterfaceCallback callback,
-							void *user_data)
-{
-	struct interface_scan_data *data;
-	int ret;
+	g_timeout_add(300, peer_joined_with_ip, peer);
 
-	ret = interface_ready_to_scan(interface);
-	if (ret)
-		return ret;
+error:
+	g_free(requested_peer->requested_p2p_dev_addr);
+	g_free(requested_peer->requested_path);
+	g_free(requested_peer->requested_ip_addr);
+	requested_peer->found_p2p_network = NULL;
 
-	data = dbus_malloc0(sizeof(*data));
-	if (!data)
-		return -ENOMEM;
+	g_free(requested_peer);
+	requested_peer = NULL;
 
-	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->callback = callback;
-	data->user_data = user_data;
-	data->scan_params = scan_data;
+	return FALSE;
+}
 
-        interface->scan_callback = callback;
-        interface->scan_data = user_data;
+GSupplicantGroup *g_supplicant_get_group(const char *path)
+{
+	GSupplicantGroup *group;
 
-	ret = supplicant_dbus_method_call(interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "Scan",
-			interface_scan_params, interface_scan_result, data,
-			interface);
+	if (!path)
+		return NULL;
 
-	if (ret < 0) {
-		g_free(data->path);
-		dbus_free(data);
-	}
+	group = g_hash_table_lookup(group_mapping, path);
+	if (!group)
+		return NULL;
 
-	return ret;
+	return group;
 }
 
-static int parse_supplicant_error(DBusMessageIter *iter)
+static void extract_peer_with_ip(const char *path, DBusMessageIter *iter, connman_bool_t joined, bool is_ip_present)
 {
-	int err = -ECONNABORTED;
-	char *key;
+	GSupplicantGroup *group;
+	GSupplicantPeer *peer;
+	GSupplicantRequestedPeer *requested_peer;
+	const char *peer_path;
+	const char *ip_addr;
+	char *intf_addr, *pintf_addr;
+	char *p2p_dev_addr = NULL;
+	char *dev_addr = NULL;
+	unsigned char intf_addr_byte[6];
 
-	if (!iter)
-		return err;
+	group = g_hash_table_lookup(group_mapping, path);
+	if (!group)
+		return;
 
-	/* If the given passphrase is malformed wpa_s returns
-	 * "invalid message format" but this error should be interpreted as
-	 * invalid-key.
-	 */
-	while (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_STRING) {
-		dbus_message_iter_get_basic(iter, &key);
-		if (strncmp(key, "psk", 3) == 0 ||
-				strncmp(key, "wep_key", 7) == 0 ||
-				strcmp(key, "invalid message format") == 0) {
-			err = -ENOKEY;
-			break;
-		}
+	dbus_message_iter_get_basic(iter, &peer_path);
+	if (!peer_path)
+		return;
+
+	if (is_ip_present) {
 		dbus_message_iter_next(iter);
+		if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_STRING) {
+			SUPPLICANT_DBG("not string\n");
+			return;
+		}
+		dbus_message_iter_get_basic(iter, &ip_addr);
 	}
 
-	return err;
-}
+	dbus_message_iter_next(iter);
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
+	}
 
-static void interface_select_network_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
-{
-	struct interface_connect_data *data = user_data;
-	int err;
+	dbus_message_iter_get_basic(iter, &p2p_dev_addr);
+	if (!p2p_dev_addr)
+		return;
 
-	SUPPLICANT_DBG("");
+	requested_peer = g_try_new0(GSupplicantRequestedPeer, 1);
+	if (requested_peer == NULL)
+		return;
 
-	err = 0;
-	if (error) {
-		SUPPLICANT_DBG("SelectNetwork error %s", error);
-		err = parse_supplicant_error(iter);
+	if (is_ip_present)
+		requested_peer->requested_ip_addr = g_strdup(ip_addr);
+
+	requested_peer->requested_path = g_strdup(path);
+	requested_peer->requested_p2p_dev_addr = g_strdup(p2p_dev_addr);
+	requested_peer->requested_is_ip_present = is_ip_present;
+
+	intf_addr = strrchr(peer_path, '/') + 1;
+
+	if(joined == TRUE) {
+		pintf_addr = g_strdup(intf_addr);
+		g_hash_table_replace(intf_addr_mapping, g_strdup(peer_path), pintf_addr);
+	} else {
+		pintf_addr = g_hash_table_lookup(intf_addr_mapping, peer_path);
+
+		if(pintf_addr == NULL)
+			goto error;
 	}
 
-	g_free(data->path);
+	dev_addr = g_hash_table_lookup(dev_addr_mapping, pintf_addr);
+	if(!dev_addr) {
+		g_hash_table_replace(dev_addr_mapping, g_strdup(pintf_addr), g_strdup(p2p_dev_addr));
+	}
 
-	if (data->callback)
-		data->callback(err, data->interface, data->user_data);
+	if (find_p2p_network(requested_peer))
+		(void)requested_peer_joined_with_ip(requested_peer);
+	else
+		g_timeout_add(200, requested_peer_joined_with_ip, requested_peer);
 
-	g_free(data->ssid);
-	dbus_free(data);
+	return;
+
+error:
+	g_free(requested_peer->requested_path);
+	g_free(requested_peer->requested_p2p_dev_addr);
+	g_free(requested_peer->requested_ip_addr);
+	requested_peer->found_p2p_network = NULL;
+
+	g_free(requested_peer);
+	requested_peer = NULL;
 }
 
-static void interface_select_network_params(DBusMessageIter *iter,
-							void *user_data)
+static void signal_peer_joined_with_ip(const char *path, DBusMessageIter *iter)
 {
-	struct interface_connect_data *data = user_data;
-	GSupplicantInterface *interface = data->interface;
+	SUPPLICANT_DBG("signal peer joined with ip");
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
-					&interface->network_path);
+	extract_peer_with_ip(path, iter, TRUE, true);
 }
 
-static void interface_add_network_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
+GSupplicantP2PNetwork* g_supplicant_find_network_from_intf_address(const char* pintf_addr, const char* p2p_dev_addr)
 {
-	struct interface_connect_data *data = user_data;
-	GSupplicantInterface *interface = data->interface;
-	const char *path;
-	int err;
-
-	if (error)
-		goto error;
-
-	dbus_message_iter_get_basic(iter, &path);
-	if (!path)
-		goto error;
-
-	SUPPLICANT_DBG("PATH: %s", path);
-
-	interface->network_path = g_strdup(path);
-
-	store_network_information(interface, data->ssid);
+	struct peer_device_data *p2p_network = NULL;
+	unsigned char intf_addr_byte[6];
+	unsigned char p2p_dev_addr_byte[6] = {0};
+	GSList *item;
+	int i;
+	bool same;
 
-	supplicant_dbus_method_call(data->interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "SelectNetwork",
-			interface_select_network_params,
-			interface_select_network_result, data,
-			interface);
+	string_to_byte(pintf_addr, intf_addr_byte);
+	string_to_byte(p2p_dev_addr, p2p_dev_addr_byte);
 
-	return;
+	item = p2p_network_list;
 
-error:
-	SUPPLICANT_DBG("AddNetwork error %s", error);
+	while(item) {
+		p2p_network = item->data;
+		same = true;
 
-	if (interface_exists(data->interface, data->interface->path)) {
-		err = parse_supplicant_error(iter);
-		if (data->callback)
-			data->callback(err, data->interface, data->user_data);
+		for(i = 0; i < 6; i++) {
+			if(p2p_network->p2p_device_addr[i] != p2p_dev_addr_byte[i]) {
+				same = false;
+				break;
+			}
+		}
+		if(same)
+			break;
 
-		g_free(interface->network_path);
-		interface->network_path = NULL;
+		item = g_slist_next(item);
+		p2p_network = NULL;
 	}
 
-	g_free(data->path);
-	g_free(data->ssid);
-	g_free(data);
+	return p2p_network;
 }
 
-static void add_network_security_none(DBusMessageIter *dict)
+/* @pintf_addr: interface mac address in the form of 0012233445a */
+const char * g_supplicant_peer_identifier_from_intf_address(const char* pintf_addr)
 {
-	const char *auth_alg = "OPEN";
-
-	supplicant_dbus_dict_append_basic(dict, "auth_alg",
-					DBUS_TYPE_STRING, &auth_alg);
-}
+	struct peer_device_data *p2p_network = NULL;
+	unsigned char intf_addr_byte[6];
+	unsigned char p2p_dev_addr_byte[6] = {0};
+	GSList *item;
+	int i;
+	bool same;
+	GSupplicantPeer *peer = NULL;
+	GSupplicantInterface *interface;
+	char *p2p_dev_addr = NULL;
 
-static void add_network_security_wep(DBusMessageIter *dict,
-					GSupplicantSSID *ssid)
-{
-	const char *auth_alg = "OPEN SHARED";
-	dbus_uint32_t key_index = 0;
+	p2p_dev_addr = g_hash_table_lookup(dev_addr_mapping, pintf_addr);
+	if(!p2p_dev_addr)
+		return peer;
 
-	supplicant_dbus_dict_append_basic(dict, "auth_alg",
-					DBUS_TYPE_STRING, &auth_alg);
+	string_to_byte(p2p_dev_addr, p2p_dev_addr_byte);
+	string_to_byte(pintf_addr, intf_addr_byte);
 
-	if (ssid->passphrase) {
-		int size = strlen(ssid->passphrase);
-		if (size == 10 || size == 26) {
-			unsigned char *key = g_try_malloc(13);
-			char tmp[3];
-			int i;
+	item = p2p_network_list;
 
-			memset(tmp, 0, sizeof(tmp));
-			if (!key)
-				size = 0;
+	while(item) {
+		p2p_network = item->data;
+		same = true;
 
-			for (i = 0; i < size / 2; i++) {
-				memcpy(tmp, ssid->passphrase + (i * 2), 2);
-				key[i] = (unsigned char) strtol(tmp, NULL, 16);
+		for(i = 0; i < 6; i++) {
+			if(p2p_network->p2p_device_addr[i] != p2p_dev_addr_byte[i]) {
+				same = false;
+				break;
 			}
+		}
 
-			supplicant_dbus_dict_append_fixed_array(dict,
-							"wep_key0",
-							DBUS_TYPE_BYTE,
-							&key, size / 2);
-			g_free(key);
-		} else if (size == 5 || size == 13) {
-			unsigned char *key = g_try_malloc(13);
-			int i;
-
-			if (!key)
-				size = 0;
-
-			for (i = 0; i < size; i++)
-				key[i] = (unsigned char) ssid->passphrase[i];
-
-			supplicant_dbus_dict_append_fixed_array(dict,
-								"wep_key0",
-								DBUS_TYPE_BYTE,
-								&key, size);
-			g_free(key);
-		} else
-			supplicant_dbus_dict_append_basic(dict,
-							"wep_key0",
-							DBUS_TYPE_STRING,
-							&ssid->passphrase);
+		if(same)
+			break;
 
-		supplicant_dbus_dict_append_basic(dict, "wep_tx_keyidx",
-					DBUS_TYPE_UINT32, &key_index);
+		item = g_slist_next(item);
+		p2p_network = NULL;
 	}
-}
-
-static dbus_bool_t is_psk_raw_key(const char *psk)
-{
-	int i;
 
-	/* A raw key is always 64 bytes length... */
-	if (strlen(psk) != 64)
-		return FALSE;
+	if(p2p_network == NULL)
+		return peer;
 
-	/* ... and its content is in hex representation */
-	for (i = 0; i < 64; i++)
-		if (!isxdigit((unsigned char) psk[i]))
-			return FALSE;
+	interface = g_hash_table_lookup(peer_mapping, p2p_network->path);
+	if (!interface)
+		return peer;
 
-	return TRUE;
-}
+	peer = g_hash_table_lookup(interface->peer_table, p2p_network->path);
 
-static unsigned char hexchar2bin(char c)
-{
-	if ((c >= '0') && (c <= '9'))
-		return c - '0';
-	else if ((c >= 'A') && (c <= 'F'))
-		return c - 'A' + 10;
-	else if ((c >= 'a') && (c <= 'f'))
-		return c - 'a' + 10;
-	else
-		return c;
+	return g_supplicant_peer_get_identifier(peer);
 }
 
-static void hexstring2bin(const char *string, unsigned char *data,
-				size_t data_len)
+static void signal_group_peer_disconnected(const char *path, DBusMessageIter *iter)
 {
-	size_t i;
-
-	for (i = 0; i < data_len; i++)
-		data[i] = (hexchar2bin(string[i * 2 + 0]) << 4 |
-			   hexchar2bin(string[i * 2 + 1]) << 0);
-}
+	const char *peer_path = NULL;
+	GSupplicantInterface *interface;
+	GSupplicantGroup *group;
+	GSupplicantPeer *peer;
+	struct peer_device_data *p2p_network = NULL;
+	char  *pintf_addr;
+	char *p2p_dev_addr = NULL;
 
-static void add_network_security_psk(DBusMessageIter *dict,
-					GSupplicantSSID *ssid)
-{
-	if (ssid->passphrase && strlen(ssid->passphrase) > 0) {
-		const char *key = "psk";
+	GSList *elem;
 
-		if (is_psk_raw_key(ssid->passphrase)) {
-			unsigned char data[32];
-			unsigned char *datap = data;
+	SUPPLICANT_DBG("");
 
-			/* The above pointer alias is required by D-Bus because
-			 * with D-Bus and GCC, non-heap-allocated arrays cannot
-			 * be passed directly by their base pointer. */
+	group = g_hash_table_lookup(group_mapping, path);
+	if (!group)
+		return;
 
-			hexstring2bin(ssid->passphrase, datap, sizeof(data));
+	dbus_message_iter_get_basic(iter, &peer_path);
+	if (!peer_path)
+		return;
 
-			supplicant_dbus_dict_append_fixed_array(dict,
-							key, DBUS_TYPE_BYTE,
-							&datap, sizeof(data));
-		} else
-			supplicant_dbus_dict_append_basic(dict,
-							key, DBUS_TYPE_STRING,
-							&ssid->passphrase);
+	dbus_message_iter_next(iter);
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_STRING) {
+		SUPPLICANT_DBG("not string\n");
+		return;
 	}
-}
 
-static void add_network_security_tls(DBusMessageIter *dict,
-					GSupplicantSSID *ssid)
-{
-	/*
-	 * For TLS, we at least need:
-	 *              The client certificate
-	 *              The client private key file
-	 *              The client private key file password
-	 *
-	 * The Authority certificate is optional.
-	 */
-	if (!ssid->client_cert_path)
+	dbus_message_iter_get_basic(iter, &p2p_dev_addr);
+	if (!p2p_dev_addr)
 		return;
 
-	if (!ssid->private_key_path)
+	pintf_addr = g_hash_table_lookup(intf_addr_mapping, peer_path);
+	if (pintf_addr == NULL)
 		return;
 
-	if (!ssid->private_key_passphrase)
+	p2p_network = g_supplicant_find_network_from_intf_address(pintf_addr, p2p_dev_addr);
+
+	if (p2p_network == NULL)
 		return;
 
-	if (ssid->ca_cert_path)
-		supplicant_dbus_dict_append_basic(dict, "ca_cert",
-					DBUS_TYPE_STRING, &ssid->ca_cert_path);
+	g_hash_table_remove(dev_addr_mapping, pintf_addr);
 
-	supplicant_dbus_dict_append_basic(dict, "private_key",
-						DBUS_TYPE_STRING,
-						&ssid->private_key_path);
-	supplicant_dbus_dict_append_basic(dict, "private_key_passwd",
-						DBUS_TYPE_STRING,
-						&ssid->private_key_passphrase);
-	supplicant_dbus_dict_append_basic(dict, "client_cert",
-						DBUS_TYPE_STRING,
-						&ssid->client_cert_path);
-}
+	for (elem = group->members; elem; elem = elem->next) {
+		if (!g_strcmp0(elem->data, p2p_network->path))
+			break;
+	}
 
-static void add_network_security_peap(DBusMessageIter *dict,
-					GSupplicantSSID *ssid)
-{
-	char *phase2_auth;
+	if (!elem)
+		return;
 
-	/*
-	 * For PEAP/TTLS, we at least need
-	 *              The authority certificate
-	 *              The 2nd phase authentication method
-	 *              The 2nd phase passphrase
-	 *
-	 * The Client certificate is optional although strongly recommended
-	 * When setting it, we need in addition
-	 *              The Client private key file
-	 *              The Client private key file password
-	 */
-	if (!ssid->passphrase)
+	g_free(elem->data);
+	group->members = g_slist_delete_link(group->members, elem);
+
+	interface = g_hash_table_lookup(peer_mapping, p2p_network->path);
+	if (!interface)
 		return;
 
-	if (!ssid->phase2_auth)
+	peer = g_hash_table_lookup(interface->peer_table, p2p_network->path);
+	if (!peer)
 		return;
 
-	if (ssid->client_cert_path) {
-		if (!ssid->private_key_path)
-			return;
+	callback_peer_changed(peer, G_SUPPLICANT_PEER_GROUP_DISCONNECTED);
+	peer->connection_requested = false;
+}
 
-		if (!ssid->private_key_passphrase)
-			return;
+static struct {
+	const char *interface;
+	const char *member;
+	void (*function) (const char *path, DBusMessageIter *iter);
+} signal_map[] = {
+	{ DBUS_INTERFACE_DBUS,  "NameOwnerChanged",  signal_name_owner_changed },
 
-		supplicant_dbus_dict_append_basic(dict, "client_cert",
-						DBUS_TYPE_STRING,
-						&ssid->client_cert_path);
+	{ SUPPLICANT_INTERFACE, "PropertiesChanged", signal_properties_changed },
+	{ SUPPLICANT_INTERFACE, "InterfaceAdded",    signal_interface_added    },
+	{ SUPPLICANT_INTERFACE, "InterfaceCreated",  signal_interface_added    },
+	{ SUPPLICANT_INTERFACE, "InterfaceRemoved",  signal_interface_removed  },
 
-		supplicant_dbus_dict_append_basic(dict, "private_key",
-						DBUS_TYPE_STRING,
-						&ssid->private_key_path);
+	{ SUPPLICANT_INTERFACE ".Interface", "PropertiesChanged", signal_interface_changed },
+	{ SUPPLICANT_INTERFACE ".Interface", "ScanDone",          signal_scan_done         },
+	{ SUPPLICANT_INTERFACE ".Interface", "BSSAdded",          signal_bss_added         },
+	{ SUPPLICANT_INTERFACE ".Interface", "BSSRemoved",        signal_bss_removed       },
+	{ SUPPLICANT_INTERFACE ".Interface", "NetworkAdded",      signal_network_added     },
+	{ SUPPLICANT_INTERFACE ".Interface", "NetworkRemoved",    signal_network_removed   },
+	{ SUPPLICANT_INTERFACE ".Interface", "StaAuthorized",     signal_sta_authorized    },
+	{ SUPPLICANT_INTERFACE ".Interface", "StaDeauthorized",   signal_sta_deauthorized  },
 
-		supplicant_dbus_dict_append_basic(dict, "private_key_passwd",
-						DBUS_TYPE_STRING,
-						&ssid->private_key_passphrase);
+	{ SUPPLICANT_INTERFACE ".Interface", "StaAuthorized",     signal_station_connected   },
+	{ SUPPLICANT_INTERFACE ".Interface", "StaDeauthorized",   signal_station_disconnected },
 
-	}
+	{ SUPPLICANT_INTERFACE ".BSS", "PropertiesChanged", signal_bss_changed   },
 
-	if(g_strcmp0(ssid->phase2_auth, "GTC") == 0 && g_strcmp0(ssid->eap, "ttls") == 0)
-		phase2_auth = g_strdup_printf("autheap=%s", ssid->phase2_auth);
-	else if (g_str_has_prefix(ssid->phase2_auth, "EAP-")) {
-		phase2_auth = g_strdup_printf("autheap=%s",
-					ssid->phase2_auth + strlen("EAP-"));
-	} else
-		phase2_auth = g_strdup_printf("auth=%s", ssid->phase2_auth);
+	{ SUPPLICANT_INTERFACE ".Interface.WPS", "Credentials", signal_wps_credentials },
+	{ SUPPLICANT_INTERFACE ".Interface.WPS", "Event",       signal_wps_event       },
 
-	supplicant_dbus_dict_append_basic(dict, "password",
-						DBUS_TYPE_STRING,
-						&ssid->passphrase);
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeviceFound", signal_peer_found },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeviceLost",  signal_peer_lost  },
 
-	if (ssid->ca_cert_path)
-		supplicant_dbus_dict_append_basic(dict, "ca_cert",
-						DBUS_TYPE_STRING,
-						&ssid->ca_cert_path);
+	{ SUPPLICANT_INTERFACE ".Peer", "PropertiesChanged", signal_peer_changed },
 
-	supplicant_dbus_dict_append_basic(dict, "phase2",
-						DBUS_TYPE_STRING,
-						&phase2_auth);
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationSuccess", signal_group_success },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationFailure", signal_group_failure },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "PersistentGroupAdded", signal_persistent_group_added	},
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "PersistentGroupRemoved", signal_persistent_group_removed	},
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GroupStarted", signal_group_started },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GroupFinished", signal_group_finished },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "GONegotiationRequest", signal_group_request },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ServiceDiscoveryResponse", signal_sd_response	},
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ServiceDiscoveryASPResponse", signal_sd_asp_response	},
 
-	g_free(phase2_auth);
-}
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "P2PSProvisionStart", signal_p2ps_prov_start	},
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "P2PSProvisionDone",	 signal_p2ps_prov_done	},
 
-static void add_network_security_eap(DBusMessageIter *dict,
-					GSupplicantSSID *ssid)
-{
-	char *eap_value;
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryPBCRequest",	signal_prov_disc_requested_pbc },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryRequestEnterPin",	signal_prov_disc_requested_enter_pin },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryRequestDisplayPin",	signal_prov_disc_requested_disp_pin },
 
-	if (!ssid->eap || !ssid->identity)
-		return;
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryResponseEnterPin",	signal_prov_disc_response_enter_pin },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryResponseDisplayPin",	signal_prov_disc_response_disp_pin },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ProvisionDiscoveryFailure",	signal_prov_disc_fail },
 
-	if (g_strcmp0(ssid->eap, "tls") == 0) {
-		add_network_security_tls(dict, ssid);
-	} else if (g_strcmp0(ssid->eap, "peap") == 0 ||
-				g_strcmp0(ssid->eap, "ttls") == 0) {
-		add_network_security_peap(dict, ssid);
-	} else
-		return;
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "InvitationResult", signal_invitation_result },
+	{ SUPPLICANT_INTERFACE ".Interface.P2PDevice", "InvitationReceived", signal_invitation_received	},
 
-	eap_value = g_ascii_strup(ssid->eap, -1);
+	{ SUPPLICANT_INTERFACE ".Group", "PeerJoined", signal_group_peer_joined },
+	{ SUPPLICANT_INTERFACE ".Group", "PeerJoinedWithIP", signal_peer_joined_with_ip },
+	{ SUPPLICANT_INTERFACE ".Group", "PeerDisconnected", signal_group_peer_disconnected },
 
-	supplicant_dbus_dict_append_basic(dict, "eap",
-						DBUS_TYPE_STRING,
-						&eap_value);
-	supplicant_dbus_dict_append_basic(dict, "identity",
-						DBUS_TYPE_STRING,
-						&ssid->identity);
-	if(ssid->anonymous_identity)
-		supplicant_dbus_dict_append_basic(dict, "anonymous_identity",
-						     DBUS_TYPE_STRING,
-						     &ssid->anonymous_identity);
+	{ }
+};
 
-	if(ssid->subject_match)
-		supplicant_dbus_dict_append_basic(dict, "subject_match",
-						     DBUS_TYPE_STRING,
-						     &ssid->subject_match);
+static DBusHandlerResult g_supplicant_filter(DBusConnection *conn,
+					DBusMessage *message, void *data)
+{
+	DBusMessageIter iter;
+	const char *path;
+	int i;
 
-	if(ssid->altsubject_match)
-		supplicant_dbus_dict_append_basic(dict, "altsubject_match",
-						     DBUS_TYPE_STRING,
-						     &ssid->altsubject_match);
+	path = dbus_message_get_path(message);
+	if (!path)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-	if(ssid->domain_suffix_match)
-		supplicant_dbus_dict_append_basic(dict, "domain_suffix_match",
-						     DBUS_TYPE_STRING,
-						     &ssid->domain_suffix_match);
+	if (!dbus_message_iter_init(message, &iter))
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-	if(ssid->domain_match)
-		supplicant_dbus_dict_append_basic(dict, "domain_match",
-						     DBUS_TYPE_STRING,
-						     &ssid->domain_match);
+	for (i = 0; signal_map[i].interface; i++) {
+		if (!dbus_message_has_interface(message, signal_map[i].interface))
+			continue;
 
-	g_free(eap_value);
+		if (!dbus_message_has_member(message, signal_map[i].member))
+			continue;
+
+		signal_map[i].function(path, &iter);
+		break;
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-static void add_network_security_ciphers(DBusMessageIter *dict,
-						GSupplicantSSID *ssid)
+struct interface_p2p_invite_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PInviteParams *p2p_invite_params;
+	void *user_data;
+};
+
+static void interface_p2p_invite_params(DBusMessageIter *iter, void *user_data)
 {
-	unsigned int p_cipher, g_cipher, i;
-	char *pairwise, *group;
-	char *pair_ciphers[4];
-	char *group_ciphers[5];
+	DBusMessageIter dict;
+	struct interface_p2p_invite_data *data = user_data;
 
-	p_cipher = ssid->pairwise_cipher;
-	g_cipher = ssid->group_cipher;
+	supplicant_dbus_dict_open(iter, &dict);
 
-	if (p_cipher == 0 && g_cipher == 0)
-		return;
+	if (data && data->p2p_invite_params) {
+		GSupplicantP2PInviteParams* params = data->p2p_invite_params;
 
-	i = 0;
+		supplicant_dbus_dict_append_basic(&dict, "peer",
+					DBUS_TYPE_OBJECT_PATH, &params->peer);
 
-	if (p_cipher & G_SUPPLICANT_PAIRWISE_CCMP)
-		pair_ciphers[i++] = "CCMP";
+		if(params->persistent_group)
+			supplicant_dbus_dict_append_basic(&dict, "persistent_group_object",
+					DBUS_TYPE_OBJECT_PATH, &params->persistent_group);
+	}
 
-	if (p_cipher & G_SUPPLICANT_PAIRWISE_TKIP)
-		pair_ciphers[i++] = "TKIP";
+	supplicant_dbus_dict_close(iter, &dict);
+}
 
-	if (p_cipher & G_SUPPLICANT_PAIRWISE_NONE)
-		pair_ciphers[i++] = "NONE";
+static void interface_p2p_invite_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_invite_data *data = user_data;
+	int err = 0;
 
-	pair_ciphers[i] = NULL;
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
 
-	i = 0;
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
 
-	if (g_cipher & G_SUPPLICANT_GROUP_CCMP)
-		group_ciphers[i++] = "CCMP";
+	dbus_free(data);
+}
 
-	if (g_cipher & G_SUPPLICANT_GROUP_TKIP)
-		group_ciphers[i++] = "TKIP";
+int g_supplicant_interface_p2p_invite(GSupplicantInterface *interface,
+				GSupplicantP2PInviteParams *invite_data,
+				GSupplicantInterfaceCallback callback, void *user_data)
+{
+	struct interface_p2p_invite_data *data;
+	int ret;
 
-	if (g_cipher & G_SUPPLICANT_GROUP_WEP104)
-		group_ciphers[i++] = "WEP104";
+	if (!interface)
+		return -EINVAL;
 
-	if (g_cipher & G_SUPPLICANT_GROUP_WEP40)
-		group_ciphers[i++] = "WEP40";
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
 
-	group_ciphers[i] = NULL;
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+	data->p2p_invite_params = invite_data;
 
-	pairwise = g_strjoinv(" ", pair_ciphers);
-	group = g_strjoinv(" ", group_ciphers);
+	SUPPLICANT_DBG("interface->path : %s\n", interface->path);
 
-	SUPPLICANT_DBG("cipher %s %s", pairwise, group);
+	ret = supplicant_dbus_method_call(interface->path,
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+					"Invite",
+					interface_p2p_invite_params,
+					interface_p2p_invite_result, data, NULL);
 
-	supplicant_dbus_dict_append_basic(dict, "pairwise",
-						DBUS_TYPE_STRING,
-						&pairwise);
-	supplicant_dbus_dict_append_basic(dict, "group",
-						DBUS_TYPE_STRING,
-						&group);
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
 
-	g_free(pairwise);
-	g_free(group);
+	return -EINPROGRESS;
 }
 
-static void add_network_security_proto(DBusMessageIter *dict,
-						GSupplicantSSID *ssid)
-{
-	unsigned int protocol, i;
-	char *proto;
-	char *protos[3];
-
-	protocol = ssid->protocol;
 
-	if (protocol == 0)
+void g_supplicant_interface_cancel(GSupplicantInterface *interface)
+{
+	if (!interface)
 		return;
 
-	i = 0;
+	SUPPLICANT_DBG("Cancelling any pending DBus calls");
+	supplicant_dbus_method_call_cancel_all(interface);
+	supplicant_dbus_property_call_cancel_all(interface);
+}
 
-	if (protocol & G_SUPPLICANT_PROTO_RSN)
-		protos[i++] = "RSN";
+struct supplicant_regdom {
+	GSupplicantCountryCallback callback;
+	const char *alpha2;
+	const void *user_data;
+};
 
-	if (protocol & G_SUPPLICANT_PROTO_WPA)
-		protos[i++] = "WPA";
+static void country_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct supplicant_regdom *regdom = user_data;
+	int result = 0;
 
-	protos[i] = NULL;
+	SUPPLICANT_DBG("Country setting result");
 
-	proto = g_strjoinv(" ", protos);
+	if (!user_data)
+		return;
 
-	SUPPLICANT_DBG("proto %s", proto);
+	if (error) {
+		SUPPLICANT_DBG("Country setting failure %s", error);
+		result = -EINVAL;
+	}
 
-	supplicant_dbus_dict_append_basic(dict, "proto",
-						DBUS_TYPE_STRING,
-						&proto);
+	if (regdom->callback)
+		regdom->callback(result, regdom->alpha2,
+					(void *) regdom->user_data);
 
-	g_free(proto);
+	g_free(regdom);
 }
 
-static void add_network_security(DBusMessageIter *dict, GSupplicantSSID *ssid)
+static void country_params(DBusMessageIter *iter, void *user_data)
 {
-	char *key_mgmt;
-
-	switch (ssid->security) {
-	case G_SUPPLICANT_SECURITY_NONE:
-		key_mgmt = "NONE";
-		add_network_security_none(dict);
-		add_network_security_ciphers(dict, ssid);
-		break;
-	case G_SUPPLICANT_SECURITY_UNKNOWN:
-	case G_SUPPLICANT_SECURITY_WEP:
-		key_mgmt = "NONE";
-		add_network_security_wep(dict, ssid);
-		add_network_security_ciphers(dict, ssid);
-		break;
-	case G_SUPPLICANT_SECURITY_PSK:
-		key_mgmt = "WPA-PSK";
-		add_network_security_psk(dict, ssid);
-		add_network_security_ciphers(dict, ssid);
-		add_network_security_proto(dict, ssid);
-		break;
-	case G_SUPPLICANT_SECURITY_IEEE8021X:
-		key_mgmt = "WPA-EAP";
-		add_network_security_eap(dict, ssid);
-		add_network_security_ciphers(dict, ssid);
-		add_network_security_proto(dict, ssid);
-		break;
-	}
+	struct supplicant_regdom *regdom = user_data;
 
-	supplicant_dbus_dict_append_basic(dict, "key_mgmt",
-				DBUS_TYPE_STRING, &key_mgmt);
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+							&regdom->alpha2);
 }
 
-static void add_network_mode(DBusMessageIter *dict, GSupplicantSSID *ssid)
+int g_supplicant_set_country(const char *alpha2,
+				GSupplicantCountryCallback callback,
+					const void *user_data)
+{
+	struct supplicant_regdom *regdom;
+	int ret;
+
+	SUPPLICANT_DBG("Country setting %s", alpha2);
+
+	if (!system_available)
+		return -EFAULT;
+
+	regdom = dbus_malloc0(sizeof(*regdom));
+	if (!regdom)
+		return -ENOMEM;
+
+	regdom->callback = callback;
+	regdom->alpha2 = alpha2;
+	regdom->user_data = user_data;
+
+	ret =  supplicant_dbus_property_set(SUPPLICANT_PATH, SUPPLICANT_INTERFACE,
+					"Country", DBUS_TYPE_STRING_AS_STRING,
+					country_params, country_result,
+					regdom, NULL);
+	if (ret < 0) {
+		dbus_free(regdom);
+		SUPPLICANT_DBG("Unable to set Country configuration");
+	}
+	return ret;
+}
+
+int g_supplicant_interface_set_country(GSupplicantInterface *interface,
+					GSupplicantCountryCallback callback,
+							const char *alpha2,
+							void *user_data)
+{
+	struct supplicant_regdom *regdom;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+	regdom = dbus_malloc0(sizeof(*regdom));
+	if (!regdom)
+		return -ENOMEM;
+
+	regdom->callback = callback;
+	regdom->alpha2 = alpha2;
+	regdom->user_data = user_data;
+
+	ret =  supplicant_dbus_property_set(interface->path,
+				SUPPLICANT_INTERFACE ".Interface",
+				"Country", DBUS_TYPE_STRING_AS_STRING,
+				country_params, country_result,
+					regdom, NULL);
+	if (ret < 0) {
+		dbus_free(regdom);
+		SUPPLICANT_DBG("Unable to set Country configuration");
+	}
+
+	return ret;
+}
+
+bool g_supplicant_interface_has_p2p(GSupplicantInterface *interface)
+{
+	if (!interface)
+		return false;
+
+	return interface->p2p_support;
+}
+
+struct supplicant_p2p_dev_config {
+	char *device_name;
+	char *dev_type;
+};
+
+static void p2p_device_config_result(const char *error,
+					DBusMessageIter *iter, void *user_data)
+{
+	struct supplicant_p2p_dev_config *config = user_data;
+
+	if (error)
+		SUPPLICANT_DBG("Unable to set P2P Device configuration: %s",
+									error);
+
+	g_free(config->device_name);
+	g_free(config->dev_type);
+	dbus_free(config);
+}
+
+int dev_type_str2bin(const char *type, unsigned char dev_type[8])
+{
+	int length, pos, end;
+	char b[3] = {};
+	char *e = NULL;
+
+	end = strlen(type);
+	for (length = pos = 0; type[pos] != '\0' && length < 8; length++) {
+		if (pos+2 > end)
+			return 0;
+
+		b[0] = type[pos];
+		b[1] = type[pos+1];
+
+		dev_type[length] = strtol(b, &e, 16);
+		if (e && *e != '\0')
+			return 0;
+
+		pos += 2;
+	}
+
+	return 8;
+}
+
+static void p2p_device_config_params(DBusMessageIter *iter, void *user_data)
+{
+	struct supplicant_p2p_dev_config *config = user_data;
+	DBusMessageIter dict;
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	supplicant_dbus_dict_append_basic(&dict, "DeviceName",
+				DBUS_TYPE_STRING, &config->device_name);
+
+	if (config->dev_type) {
+		unsigned char dev_type[8] = {}, *type;
+		int len;
+
+		len = dev_type_str2bin(config->dev_type, dev_type);
+		if (len) {
+			type = dev_type;
+			supplicant_dbus_dict_append_fixed_array(&dict,
+					"PrimaryDeviceType",
+					DBUS_TYPE_BYTE, &type, len);
+		}
+	}
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+int g_supplicant_interface_set_p2p_device_config(GSupplicantInterface *interface,
+					const char *device_name,
+					const char *primary_dev_type)
+{
+	struct supplicant_p2p_dev_config *config;
+	int ret;
+
+	SUPPLICANT_DBG("P2P Device settings %s/%s",
+					device_name, primary_dev_type);
+
+	config = dbus_malloc0(sizeof(*config));
+	if (!config)
+		return -ENOMEM;
+
+	config->device_name = g_strdup(device_name);
+	config->dev_type = g_strdup(primary_dev_type);
+
+	ret = supplicant_dbus_property_set(interface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"P2PDeviceConfig",
+				DBUS_TYPE_ARRAY_AS_STRING
+				DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+				DBUS_TYPE_STRING_AS_STRING
+				DBUS_TYPE_VARIANT_AS_STRING
+				DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+				p2p_device_config_params,
+				p2p_device_config_result, config, NULL);
+	if (ret < 0) {
+		g_free(config->device_name);
+		g_free(config->dev_type);
+		dbus_free(config);
+		SUPPLICANT_DBG("Unable to set P2P Device configuration");
+	}
+
+	return ret;
+}
+
+static void p2p_device_config_property_update(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantP2PDeviceConfigParams *p2p_device_config = user_data;
+	DBusMessageIter iter_dict, iter_dict_entry;
+	char *key = NULL;
+
+	dbus_message_iter_recurse(iter, &iter_dict);
+	dbus_message_iter_get_basic(&iter_dict, &key);
+
+	dbus_message_iter_next(&iter_dict);
+	dbus_message_iter_recurse(&iter_dict, &iter_dict_entry);
+
+	if (!key)
+		return;
+
+	if (g_strcmp0(key, "DeviceName") == 0) {
+		char *name = NULL;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &name);
+
+		if(p2p_device_config->device_name != NULL){
+			g_free(p2p_device_config->device_name);
+			p2p_device_config->device_name = NULL;
+		}
+
+		p2p_device_config->device_name = g_strdup(name);
+
+		SUPPLICANT_DBG("device_name : %s\n", p2p_device_config->device_name);
+	} else if (g_strcmp0(key, "PrimaryDeviceType") == 0) {
+		DBusMessageIter array;
+		unsigned char *device_type = NULL;
+		int type_len = 0;
+		int i=0;
+
+		dbus_message_iter_recurse(&iter_dict_entry, &array);
+		dbus_message_iter_get_fixed_array(&array, &device_type, &type_len);
+
+		if(type_len == 8) {
+			for(i=0; i<type_len; i++)
+				p2p_device_config->pri_dev_type[i] = device_type[i];
+		} else {
+			SUPPLICANT_DBG("strange device type\n");
+		}
+	} else if (g_strcmp0(key, "GOIntent") == 0) {
+		dbus_uint32_t go_intent;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &go_intent);
+		p2p_device_config->go_intent = go_intent;
+		SUPPLICANT_DBG("go_intent : %d\n", p2p_device_config->go_intent);
+	} else if (g_strcmp0(key, "PersistentReconnect") == 0) {
+		dbus_bool_t persistent_reconnect;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &persistent_reconnect);
+		p2p_device_config->persistent_reconnect = persistent_reconnect;
+		SUPPLICANT_DBG("persistent_reconnect : %d\n", p2p_device_config->persistent_reconnect);
+	} else if (g_strcmp0(key, "ListenRegClass") == 0) {
+		dbus_uint32_t listen_reg_class;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &listen_reg_class);
+		p2p_device_config->listen_reg_class = listen_reg_class;
+		SUPPLICANT_DBG("listen_reg_class : %d\n", p2p_device_config->listen_reg_class);
+	} else if (g_strcmp0(key, "ListenChannel") == 0) {
+		dbus_uint32_t listen_channel;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &listen_channel);
+		p2p_device_config->listen_channel = listen_channel;
+	} else if (g_strcmp0(key, "OperRegClass") == 0) {
+		dbus_uint32_t oper_reg_class;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &oper_reg_class);
+		p2p_device_config->oper_reg_class = oper_reg_class;
+	} else if (g_strcmp0(key, "OperChannel") == 0) {
+		dbus_uint32_t oper_channel;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &oper_channel);
+		p2p_device_config->oper_channel = oper_channel;
+	} else if (g_strcmp0(key, "SsidPostfix") == 0) {
+		char *ssid_postfix = NULL;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &ssid_postfix);
+
+		if(p2p_device_config->ssid_postfix != NULL){
+			g_free(p2p_device_config->ssid_postfix);
+			p2p_device_config->ssid_postfix = NULL;
+		}
+
+		p2p_device_config->ssid_postfix = g_strdup(ssid_postfix);
+	} else if (g_strcmp0(key, "IntraBss") == 0) {
+		dbus_bool_t intra_bss;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &intra_bss);
+		p2p_device_config->intra_bss = intra_bss;
+	} else if (g_strcmp0(key, "GroupIdle") == 0) {
+		dbus_uint32_t group_idle;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &group_idle);
+		p2p_device_config->group_idle = group_idle;
+	} else if (g_strcmp0(key, "disassoc_low_ack") == 0) {
+		dbus_uint32_t disassoc_low_ack;
+
+		dbus_message_iter_get_basic(&iter_dict_entry, &disassoc_low_ack);
+		p2p_device_config->disassoc_low_ack = disassoc_low_ack;
+	} else
+		SUPPLICANT_DBG("key %s type %c",
+					key, dbus_message_iter_get_arg_type(&iter_dict_entry));
+}
+
+static void p2p_device_config_property(const char *key, DBusMessageIter *iter,
+					void *user_data)
+{
+	GSupplicantInterface *interface;
+	GSupplicantP2PInterface *p2p_device_interface = user_data;
+	GSupplicantP2PDeviceConfigParams *p2p_device_config = p2p_device_interface->p2p_device_config_param;;
+
+	GSupplicantInterface *check_interface = NULL;
+
+	if (key){
+		check_interface = g_hash_table_lookup(interface_table, key);
+		if (check_interface == NULL)
+			return;
+
+		struct wifi_data *check_wifi = g_supplicant_interface_get_data(check_interface);
+		if (check_wifi == NULL)
+			return;
+	}
+
+	if (p2p_device_config->interface->path == NULL)
+		return;
+
+	interface = g_hash_table_lookup(interface_table, p2p_device_config->interface->path);
+	if (interface == NULL || interface != p2p_device_config->interface) {
+		g_free(p2p_device_interface->path);
+		g_free(p2p_device_interface);
+		return;
+	}
+
+	if (iter)
+		supplicant_dbus_array_foreach(iter, p2p_device_config_property_update, p2p_device_config);
+
+	callback_p2p_device_config_loaded(p2p_device_config->interface);
+
+	g_free(p2p_device_interface->path);
+	g_free(p2p_device_interface);
+}
+
+int g_supplicant_interface_get_p2p_device_config(GSupplicantInterface *interface,
+					GSupplicantP2PDeviceConfigParams *p2p_device_config_data)
+{
+	GSupplicantP2PInterface *p2p_device_interface = NULL;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	p2p_device_interface = g_try_malloc0(sizeof(GSupplicantP2PInterface));
+	if(!p2p_device_interface)
+		return -ENOMEM;
+
+	p2p_device_interface->path = g_strdup(interface->path);
+	p2p_device_interface->p2p_device_config_param = p2p_device_config_data;
+	p2p_device_interface->p2p_device_config_param->interface = interface;
+
+	ret = supplicant_dbus_property_get(interface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"P2PDeviceConfig",
+				p2p_device_config_property,
+				p2p_device_interface,
+				NULL);
+
+	if (ret < 0) {
+		g_free(p2p_device_interface->path);
+		g_free(p2p_device_interface);
+		SUPPLICANT_DBG("Unable to get P2P Device configuration");
+	}
+
+	return ret;
+}
+
+static void interface_set_p2p_device_config_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_device_config *config = user_data;
+	GSupplicantP2PDeviceConfigParams *config_params = config->p2p_device_config_params;
+	DBusMessageIter dict;
+	uint8_t *pri_dev_type = config_params->pri_dev_type;
+	uint8_t pri_dev_type_check[8] = {0,};
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if(config_params->device_name)
+		supplicant_dbus_dict_append_basic(&dict, "DeviceName", DBUS_TYPE_STRING, &config_params->device_name);
+
+	if(memcmp(&pri_dev_type_check[0], pri_dev_type, 8) != 0)
+		supplicant_dbus_dict_append_fixed_array(&dict, "PrimaryDeviceType", DBUS_TYPE_BYTE, &pri_dev_type, 8);
+
+	if(config_params->go_intent != 0)
+		supplicant_dbus_dict_append_basic(&dict, "GOIntent", DBUS_TYPE_UINT32, &config_params->go_intent);
+
+	supplicant_dbus_dict_append_basic(&dict, "PersistentReconnect", DBUS_TYPE_BOOLEAN, &config_params->persistent_reconnect);
+
+	if(config_params->listen_reg_class != 0)
+		supplicant_dbus_dict_append_basic(&dict, "ListenRegClass", DBUS_TYPE_UINT32, &config_params->listen_reg_class);
+
+	if(config_params->listen_channel != 0)
+		supplicant_dbus_dict_append_basic(&dict, "ListenChannel", DBUS_TYPE_UINT32, &config_params->listen_channel);
+
+	if(config_params->oper_reg_class != 0)
+		supplicant_dbus_dict_append_basic(&dict, "OperRegClass", DBUS_TYPE_UINT32, &config_params->oper_reg_class);
+
+	if(config_params->oper_channel != 0)
+		supplicant_dbus_dict_append_basic(&dict, "OperChannel", DBUS_TYPE_UINT32, &config_params->oper_channel);
+
+	if(config_params->ssid_postfix)
+		supplicant_dbus_dict_append_basic(&dict, "SsidPostfix", DBUS_TYPE_STRING, &config_params->ssid_postfix);
+
+	supplicant_dbus_dict_append_basic(&dict, "IntraBss", DBUS_TYPE_BOOLEAN, &config_params->intra_bss);
+
+	if(config_params->group_idle != 0)
+		supplicant_dbus_dict_append_basic(&dict, "GroupIdle", DBUS_TYPE_UINT32, &config_params->group_idle);
+
+	if(config_params->disassoc_low_ack != 0)
+		supplicant_dbus_dict_append_basic(&dict, "disassoc_low_ack", DBUS_TYPE_UINT32, &config_params->disassoc_low_ack);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void interface_set_p2p_device_config_result(const char *error,
+												DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_device_config *config = user_data;
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+	}
+
+	dbus_free(config);
+}
+
+int g_supplicant_interface_set_p2p_device_configs(GSupplicantInterface *interface,
+												GSupplicantP2PDeviceConfigParams *p2p_device_config_data,
+												void *user_data)
+{
+	struct interface_p2p_device_config *config = NULL;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	config = dbus_malloc0(sizeof(*config));
+	if (!config)
+		return -ENOMEM;
+
+	config->interface = interface;
+	config->user_data = user_data;
+	config->p2p_device_config_params = p2p_device_config_data;
+
+	ret = supplicant_dbus_property_set(interface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"P2PDeviceConfig", DBUS_TYPE_ARRAY_AS_STRING
+				DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+				DBUS_TYPE_STRING_AS_STRING
+				DBUS_TYPE_VARIANT_AS_STRING
+				DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+				interface_set_p2p_device_config_params,
+				interface_set_p2p_device_config_result, config, NULL);
+
+	if (ret < 0) {
+		dbus_free(config);
+		SUPPLICANT_DBG("Unable to set P2P Device configuration");
+	}
+
+	return ret;
+}
+
+static void set_p2p_disabled(DBusMessageIter *iter, void *user_data)
+{
+	dbus_bool_t enable = *(dbus_bool_t *)user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &enable);
+}
+
+int g_supplicant_interface_set_p2p_disabled(GSupplicantInterface *interface,
+							dbus_bool_t disabled)
+{
+	GSupplicantInterface *check_interface = NULL;
+	if (interface == NULL || interface->path == NULL)
+		return -EINVAL;
+
+	check_interface = g_hash_table_lookup(interface_table, interface->path);
+	if (check_interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	SUPPLICANT_DBG("disabled %d", disabled);
+
+	return supplicant_dbus_property_set(interface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"P2PDisabled", DBUS_TYPE_BOOLEAN_AS_STRING,
+				set_p2p_disabled, NULL, &disabled, NULL);
+}
+
+static gboolean peer_lookup_by_identifier(gpointer key, gpointer value,
+							gpointer user_data)
+{
+	const GSupplicantPeer *peer = value;
+	const char *identifier = user_data;
+
+	if (!g_strcmp0(identifier, peer->identifier))
+		return TRUE;
+
+	return FALSE;
+}
+
+GSupplicantPeer *g_supplicant_interface_peer_lookup(GSupplicantInterface *interface,
+							const char *identifier)
+{
+	GSupplicantPeer *peer;
+
+	peer = g_hash_table_find(interface->peer_table,
+					peer_lookup_by_identifier,
+					(void *) identifier);
+	return peer;
+}
+
+static void interface_create_data_free(struct interface_create_data *data)
+{
+	g_free(data->ifname);
+	g_free(data->driver);
+	g_free(data->bridge);
+	if (data->config_file)
+		g_free(data->config_file);
+	if (data->interface_path)
+		g_free(data->interface_path);
+	dbus_free(data);
+}
+
+static bool interface_exists(GSupplicantInterface *interface,
+				const char *path)
+{
+	GSupplicantInterface *tmp;
+
+	tmp = g_hash_table_lookup(interface_table, path);
+	if (tmp && tmp == interface)
+		return true;
+
+	return false;
+}
+
+static void interface_create_property(const char *key, DBusMessageIter *iter,
+							void *user_data)
+{
+	struct interface_create_data *data = user_data;
+	GSupplicantInterface *interface = data->interface;
+
+	if (!key) {
+		if (data->callback && interface_exists(data->interface, data->interface_path)) {
+			data->callback(0, data->interface, data->user_data);
+			callback_p2p_support(interface);
+		}
+
+		interface_create_data_free(data);
+	}
+
+	interface_property(key, iter, interface);
+}
+
+static void interface_create_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_create_data *data = user_data;
+	const char *path = NULL;
+	int err;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		g_warning("error %s", error);
+		err = -EIO;
+		goto done;
+	}
+
+	dbus_message_iter_get_basic(iter, &path);
+	if (!path) {
+		err = -EINVAL;
+		goto done;
+	}
+	data->interface_path = g_strdup(path);
+
+	if (!system_available) {
+		err = -EFAULT;
+		goto done;
+	}
+
+	data->interface = g_hash_table_lookup(interface_table, path);
+	if (!data->interface) {
+		data->interface = interface_alloc(path);
+		if (!data->interface) {
+			err = -ENOMEM;
+			goto done;
+		}
+	}
+
+	err = supplicant_dbus_property_get_all(path,
+					SUPPLICANT_INTERFACE ".Interface",
+					interface_create_property, data,
+					NULL);
+	if (err == 0)
+		return;
+
+done:
+	if (data->callback)
+		data->callback(err, NULL, data->user_data);
+
+	interface_create_data_free(data);
+}
+
+static void interface_create_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_create_data *data = user_data;
+	DBusMessageIter dict;
+	char *config_file = NULL;
+
+	SUPPLICANT_DBG("");
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	supplicant_dbus_dict_append_basic(&dict, "Ifname",
+					DBUS_TYPE_STRING, &data->ifname);
+
+	if (data->driver)
+		supplicant_dbus_dict_append_basic(&dict, "Driver",
+					DBUS_TYPE_STRING, &data->driver);
+
+	if (data->bridge)
+		supplicant_dbus_dict_append_basic(&dict, "BridgeIfname",
+					DBUS_TYPE_STRING, &data->bridge);
+
+	config_file = g_hash_table_lookup(config_file_table, data->ifname);
+	if (!config_file && data->config_file)
+		config_file = data->config_file;
+
+	if (config_file) {
+		SUPPLICANT_DBG("[%s] ConfigFile %s", data->ifname, config_file);
+
+		supplicant_dbus_dict_append_basic(&dict, "ConfigFile",
+					DBUS_TYPE_STRING, &config_file);
+	}
+
+    if (data->config_file != NULL)
+            supplicant_dbus_dict_append_basic(&dict, "ConfigFile",
+                                    DBUS_TYPE_STRING, &data->config_file);
+
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void interface_get_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_create_data *data = user_data;
+	GSupplicantInterface *interface;
+	const char *path = NULL;
+	int err;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		SUPPLICANT_DBG("Interface not created yet");
+
+		if ( (g_str_has_prefix(data->ifname, "p2p-wlan0-") == TRUE) && data->get_interface_timer_count < 10)
+		{
+			g_timeout_add(50, get_interface_retry, data);
+			data->get_interface_timer_count++;
+			return;
+		}
+		goto create;
+	}
+
+	dbus_message_iter_get_basic(iter, &path);
+	if (!path) {
+		err = -EINVAL;
+		goto done;
+	}
+
+	interface = g_hash_table_lookup(interface_table, path);
+	if (!interface) {
+		err = -ENOENT;
+		goto done;
+	}
+
+	if (data->callback) {
+		data->callback(0, interface, data->user_data);
+		callback_p2p_support(interface);
+	}
+
+	interface_create_data_free(data);
+
+	return;
+
+create:
+	if (!system_available) {
+		err = -EFAULT;
+		goto done;
+	}
+
+	SUPPLICANT_DBG("Creating interface");
+
+	err = supplicant_dbus_method_call(SUPPLICANT_PATH,
+						SUPPLICANT_INTERFACE,
+						"CreateInterface",
+						interface_create_params,
+						interface_create_result, data,
+						NULL);
+	if (err == 0)
+		return;
+
+done:
+	if (data->callback)
+		data->callback(err, NULL, data->user_data);
+
+	interface_create_data_free(data);
+}
+
+static void interface_get_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_create_data *data = user_data;
+
+	SUPPLICANT_DBG("");
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &data->ifname);
+}
+
+static gboolean get_interface_retry(void* user_data)
+{
+	supplicant_dbus_method_call(SUPPLICANT_PATH,
+					SUPPLICANT_INTERFACE,
+					"GetInterface",
+					interface_get_params,
+					interface_get_result, user_data,
+					NULL);
+	return FALSE;
+}
+
+int g_supplicant_interface_create(const char *ifname, const char *driver,
+					const char *bridge, const char *config_file,
+					GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_create_data *data;
+	int ret;
+
+	SUPPLICANT_DBG("ifname %s", ifname);
+
+	if (!ifname)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->ifname = g_strdup(ifname);
+	data->driver = g_strdup(driver);
+	data->bridge = g_strdup(bridge);
+	data->config_file = g_strdup(config_file);
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(SUPPLICANT_PATH,
+						SUPPLICANT_INTERFACE,
+						"GetInterface",
+						interface_get_params,
+						interface_get_result, data,
+						NULL);
+	if (ret < 0)
+		interface_create_data_free(data);
+
+	return ret;
+}
+
+static void interface_remove_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err;
+
+	if (error) {
+		err = -EIO;
+		SUPPLICANT_DBG("error: %s", error);
+		goto done;
+	}
+
+	if (!system_available) {
+		err = -EFAULT;
+		goto done;
+	}
+
+	/*
+	 * The gsupplicant interface is already freed by the InterfaceRemoved
+	 * signal callback. Simply invoke the interface_data callback.
+	 */
+	err = 0;
+
+done:
+	g_free(data->path);
+
+	if (data->callback)
+		data->callback(err, NULL, data->user_data);
+
+	dbus_free(data);
+}
+
+
+static void interface_remove_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&data->interface->path);
+}
+
+
+int g_supplicant_interface_remove(GSupplicantInterface *interface,
+			GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	g_supplicant_interface_cancel(interface);
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(SUPPLICANT_PATH,
+						SUPPLICANT_INTERFACE,
+						"RemoveInterface",
+						interface_remove_params,
+						interface_remove_result, data,
+						NULL);
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+	}
+	return ret;
+}
+
+static void interface_scan_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_scan_data *data = user_data;
+	int err = 0;
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	/* A non ready interface cannot send/receive anything */
+	if (interface_exists(data->interface, data->path)) {
+		if (!data->interface->ready)
+			err = -ENOLINK;
+	}
+
+	g_free(data->path);
+
+	if (err != 0) {
+		if (data->callback)
+			data->callback(err, data->interface, data->user_data);
+	} else {
+		data->interface->scan_callback = data->callback;
+		data->interface->scan_data = data->user_data;
+	}
+
+	if (data->scan_params)
+		g_supplicant_free_scan_params(data->scan_params);
+
+	dbus_free(data);
+}
+
+static void add_scan_frequency(DBusMessageIter *iter, unsigned int freq)
+{
+	DBusMessageIter data;
+	unsigned int width = 0; /* Not used by wpa_supplicant atm */
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, &data);
+
+	dbus_message_iter_append_basic(&data, DBUS_TYPE_UINT32, &freq);
+	dbus_message_iter_append_basic(&data, DBUS_TYPE_UINT32, &width);
+
+	dbus_message_iter_close_container(iter, &data);
+}
+
+static void add_scan_frequencies(DBusMessageIter *iter,
+						void *user_data)
+{
+	GSupplicantScanParams *scan_data = user_data;
+	unsigned int freq;
+	int i;
+
+	for (i = 0; i < scan_data->num_freqs; i++) {
+		freq = scan_data->freqs[i];
+		if (!freq)
+			break;
+
+		add_scan_frequency(iter, freq);
+	}
+}
+
+static void append_ssid(DBusMessageIter *iter,
+			const void *ssid, unsigned int len)
+{
+	DBusMessageIter array;
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
+	DBUS_TYPE_BYTE_AS_STRING, &array);
+
+	dbus_message_iter_append_fixed_array(&array, DBUS_TYPE_BYTE,
+								&ssid, len);
+	dbus_message_iter_close_container(iter, &array);
+}
+
+static void append_ssids(DBusMessageIter *iter, void *user_data)
+{
+	GSupplicantScanParams *scan_data = user_data;
+	GSList *list;
+
+	for (list = scan_data->ssids; list; list = list->next) {
+		struct scan_ssid *scan_ssid = list->data;
+
+		append_ssid(iter, scan_ssid->ssid, scan_ssid->ssid_len);
+	}
+}
+
+static void supplicant_add_scan_frequency(DBusMessageIter *dict,
+		supplicant_dbus_array_function function,
+					void *user_data)
+{
+	GSupplicantScanParams *scan_params = user_data;
+	DBusMessageIter entry, value, array;
+	const char *key = "Channels";
+
+	if (scan_params->freqs && scan_params->freqs[0] != 0) {
+		dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+						NULL, &entry);
+
+		dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+		dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_ARRAY_AS_STRING
+					DBUS_STRUCT_BEGIN_CHAR_AS_STRING
+					DBUS_TYPE_UINT32_AS_STRING
+					DBUS_TYPE_UINT32_AS_STRING
+					DBUS_STRUCT_END_CHAR_AS_STRING,
+					&value);
+
+		dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+					DBUS_STRUCT_BEGIN_CHAR_AS_STRING
+					DBUS_TYPE_UINT32_AS_STRING
+					DBUS_TYPE_UINT32_AS_STRING
+					DBUS_STRUCT_END_CHAR_AS_STRING,
+					&array);
+
+		if (function)
+			function(&array, user_data);
+
+		dbus_message_iter_close_container(&value, &array);
+		dbus_message_iter_close_container(&entry, &value);
+		dbus_message_iter_close_container(dict, &entry);
+	}
+}
+
+static void interface_scan_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	const char *type = "passive";
+	struct interface_scan_data *data = user_data;
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (data && data->scan_params) {
+		type = "active";
+
+		supplicant_dbus_dict_append_basic(&dict, "Type",
+					DBUS_TYPE_STRING, &type);
+
+
+		if (data->scan_params->ssids) {
+			supplicant_dbus_dict_append_array(&dict, "SSIDs",
+							DBUS_TYPE_STRING,
+							append_ssids,
+							data->scan_params);
+		}
+		supplicant_add_scan_frequency(&dict, add_scan_frequencies,
+						data->scan_params);
+	} else
+		supplicant_dbus_dict_append_basic(&dict, "Type",
+					DBUS_TYPE_STRING, &type);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static int interface_ready_to_scan(GSupplicantInterface *interface)
+{
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	if (interface->scanning)
+		return -EALREADY;
+
+	switch (interface->state) {
+	case G_SUPPLICANT_STATE_AUTHENTICATING:
+	case G_SUPPLICANT_STATE_ASSOCIATING:
+	case G_SUPPLICANT_STATE_ASSOCIATED:
+	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
+	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
+		return -EBUSY;
+	case G_SUPPLICANT_STATE_UNKNOWN:
+	case G_SUPPLICANT_STATE_DISABLED:
+	case G_SUPPLICANT_STATE_DISCONNECTED:
+	case G_SUPPLICANT_STATE_INACTIVE:
+	case G_SUPPLICANT_STATE_SCANNING:
+	case G_SUPPLICANT_STATE_COMPLETED:
+		break;
+	}
+
+	return 0;
+}
+
+int g_supplicant_interface_scan(GSupplicantInterface *interface,
+				GSupplicantScanParams *scan_data,
+				GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_scan_data *data;
+	int ret;
+
+	ret = interface_ready_to_scan(interface);
+	if (ret)
+		return ret;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->user_data = user_data;
+	data->scan_params = scan_data;
+
+        interface->scan_callback = callback;
+        interface->scan_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "Scan",
+			interface_scan_params, interface_scan_result, data,
+			interface);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+	}
+
+	return ret;
+}
+
+static int parse_supplicant_error(DBusMessageIter *iter)
+{
+	int err = -ECONNABORTED;
+	char *key;
+
+	if (!iter)
+		return err;
+
+	/* If the given passphrase is malformed wpa_s returns
+	 * "invalid message format" but this error should be interpreted as
+	 * invalid-key.
+	 */
+	while (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_STRING) {
+		dbus_message_iter_get_basic(iter, &key);
+		if (strncmp(key, "psk", 3) == 0 ||
+				strncmp(key, "wep_key", 7) == 0 ||
+				strcmp(key, "invalid message format") == 0) {
+			err = -ENOKEY;
+			break;
+		}
+		dbus_message_iter_next(iter);
+	}
+
+	return err;
+}
+
+static void interface_select_network_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	int err;
+
+	SUPPLICANT_DBG("");
+
+	err = 0;
+	if (error) {
+		SUPPLICANT_DBG("SelectNetwork error %s", error);
+		err = parse_supplicant_error(iter);
+	}
+
+	g_free(data->path);
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data->ssid);
+	dbus_free(data);
+}
+
+static void interface_select_network_params(DBusMessageIter *iter,
+							void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	GSupplicantInterface *interface = data->interface;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+					&interface->network_path);
+}
+
+static void interface_add_network_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	GSupplicantInterface *interface = data->interface;
+	const char *path;
+	int err;
+
+	if (error)
+		goto error;
+
+	dbus_message_iter_get_basic(iter, &path);
+	if (!path)
+		goto error;
+
+	SUPPLICANT_DBG("PATH: %s", path);
+
+	if (interface->network_path)
+		g_free(interface->network_path);
+	interface->network_path = g_strdup(path);
+
+	store_network_information(interface, data->ssid);
+
+	supplicant_dbus_method_call(data->interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "SelectNetwork",
+			interface_select_network_params,
+			interface_select_network_result, data,
+			interface);
+
+	return;
+
+error:
+	SUPPLICANT_DBG("AddNetwork error %s", error);
+
+	if (interface_exists(data->interface, data->interface->path)) {
+		err = parse_supplicant_error(iter);
+		if (data->callback)
+			data->callback(err, data->interface, data->user_data);
+
+		g_free(interface->network_path);
+		interface->network_path = NULL;
+	}
+
+	g_free(data->path);
+	g_free(data->ssid);
+	g_free(data);
+}
+
+static void add_network_security_none(DBusMessageIter *dict)
+{
+	const char *auth_alg = "OPEN";
+
+	supplicant_dbus_dict_append_basic(dict, "auth_alg",
+					DBUS_TYPE_STRING, &auth_alg);
+}
+
+static void add_network_security_wep(DBusMessageIter *dict,
+					GSupplicantSSID *ssid)
+{
+	const char *auth_alg = "OPEN SHARED";
+	dbus_uint32_t key_index = 0;
+
+	supplicant_dbus_dict_append_basic(dict, "auth_alg",
+					DBUS_TYPE_STRING, &auth_alg);
+
+	if (ssid->passphrase) {
+		int size = strlen(ssid->passphrase);
+		if (size == 10 || size == 26) {
+			unsigned char *key = g_try_malloc(13);
+			char tmp[3];
+			int i;
+
+			memset(tmp, 0, sizeof(tmp));
+			if (!key)
+				size = 0;
+
+			for (i = 0; i < size / 2; i++) {
+				memcpy(tmp, ssid->passphrase + (i * 2), 2);
+				key[i] = (unsigned char) strtol(tmp, NULL, 16);
+			}
+
+			supplicant_dbus_dict_append_fixed_array(dict,
+							"wep_key0",
+							DBUS_TYPE_BYTE,
+							&key, size / 2);
+			g_free(key);
+		} else if (size == 5 || size == 13) {
+			unsigned char *key = g_try_malloc(13);
+			int i;
+
+			if (!key)
+				size = 0;
+
+			for (i = 0; i < size; i++)
+				key[i] = (unsigned char) ssid->passphrase[i];
+
+			supplicant_dbus_dict_append_fixed_array(dict,
+								"wep_key0",
+								DBUS_TYPE_BYTE,
+								&key, size);
+			g_free(key);
+		} else
+			supplicant_dbus_dict_append_basic(dict,
+							"wep_key0",
+							DBUS_TYPE_STRING,
+							&ssid->passphrase);
+
+		supplicant_dbus_dict_append_basic(dict, "wep_tx_keyidx",
+					DBUS_TYPE_UINT32, &key_index);
+	}
+}
+
+static dbus_bool_t is_psk_raw_key(const char *psk)
+{
+	int i;
+
+	/* A raw key is always 64 bytes length... */
+	if (strlen(psk) != 64)
+		return FALSE;
+
+	/* ... and its content is in hex representation */
+	for (i = 0; i < 64; i++)
+		if (!isxdigit((unsigned char) psk[i]))
+			return FALSE;
+
+	return TRUE;
+}
+
+static unsigned char hexchar2bin(char c)
+{
+	if ((c >= '0') && (c <= '9'))
+		return c - '0';
+	else if ((c >= 'A') && (c <= 'F'))
+		return c - 'A' + 10;
+	else if ((c >= 'a') && (c <= 'f'))
+		return c - 'a' + 10;
+	else
+		return c;
+}
+
+static void hexstring2bin(const char *string, unsigned char *data,
+				size_t data_len)
+{
+	size_t i;
+
+	for (i = 0; i < data_len; i++)
+		data[i] = (hexchar2bin(string[i * 2 + 0]) << 4 |
+			   hexchar2bin(string[i * 2 + 1]) << 0);
+}
+
+static void add_network_security_psk(DBusMessageIter *dict,
+					GSupplicantSSID *ssid)
+{
+	if (ssid->passphrase && strlen(ssid->passphrase) > 0) {
+		const char *key = "psk";
+
+		if (is_psk_raw_key(ssid->passphrase)) {
+			unsigned char data[32];
+			unsigned char *datap = data;
+
+			/* The above pointer alias is required by D-Bus because
+			 * with D-Bus and GCC, non-heap-allocated arrays cannot
+			 * be passed directly by their base pointer. */
+
+			hexstring2bin(ssid->passphrase, datap, sizeof(data));
+
+			supplicant_dbus_dict_append_fixed_array(dict,
+							key, DBUS_TYPE_BYTE,
+							&datap, sizeof(data));
+		} else
+			supplicant_dbus_dict_append_basic(dict,
+							key, DBUS_TYPE_STRING,
+							&ssid->passphrase);
+	}
+}
+
+static void add_network_security_tls(DBusMessageIter *dict,
+					GSupplicantSSID *ssid)
+{
+	/*
+	 * For TLS, we at least need:
+	 *              The client certificate
+	 *              The client private key file
+	 *              The client private key file password
+	 *
+	 * The Authority certificate is optional.
+	 */
+	if (!ssid->client_cert_path)
+		return;
+
+	if (!ssid->private_key_path)
+		return;
+
+	if (!ssid->private_key_passphrase)
+		return;
+
+	if (ssid->ca_cert_path)
+		supplicant_dbus_dict_append_basic(dict, "ca_cert",
+					DBUS_TYPE_STRING, &ssid->ca_cert_path);
+
+	supplicant_dbus_dict_append_basic(dict, "private_key",
+						DBUS_TYPE_STRING,
+						&ssid->private_key_path);
+	supplicant_dbus_dict_append_basic(dict, "private_key_passwd",
+						DBUS_TYPE_STRING,
+						&ssid->private_key_passphrase);
+	supplicant_dbus_dict_append_basic(dict, "client_cert",
+						DBUS_TYPE_STRING,
+						&ssid->client_cert_path);
+}
+
+static void add_network_security_peap(DBusMessageIter *dict,
+					GSupplicantSSID *ssid)
+{
+	char *phase2_auth;
+
+	/*
+	 * For PEAP/TTLS, we at least need
+	 *              The authority certificate
+	 *              The 2nd phase authentication method
+	 *              The 2nd phase passphrase
+	 *
+	 * The Client certificate is optional although strongly recommended
+	 * When setting it, we need in addition
+	 *              The Client private key file
+	 *              The Client private key file password
+	 */
+	if (!ssid->passphrase)
+		return;
+
+	if (!ssid->phase2_auth)
+		return;
+
+	if (ssid->client_cert_path) {
+		if (!ssid->private_key_path)
+			return;
+
+		if (!ssid->private_key_passphrase)
+			return;
+
+		supplicant_dbus_dict_append_basic(dict, "client_cert",
+						DBUS_TYPE_STRING,
+						&ssid->client_cert_path);
+
+		supplicant_dbus_dict_append_basic(dict, "private_key",
+						DBUS_TYPE_STRING,
+						&ssid->private_key_path);
+
+		supplicant_dbus_dict_append_basic(dict, "private_key_passwd",
+						DBUS_TYPE_STRING,
+						&ssid->private_key_passphrase);
+
+	}
+
+	if(g_strcmp0(ssid->phase2_auth, "GTC") == 0 && g_strcmp0(ssid->eap, "ttls") == 0)
+		phase2_auth = g_strdup_printf("autheap=%s", ssid->phase2_auth);
+	else if (g_str_has_prefix(ssid->phase2_auth, "EAP-")) {
+		phase2_auth = g_strdup_printf("autheap=%s",
+					ssid->phase2_auth + strlen("EAP-"));
+	} else
+		phase2_auth = g_strdup_printf("auth=%s", ssid->phase2_auth);
+
+	supplicant_dbus_dict_append_basic(dict, "password",
+						DBUS_TYPE_STRING,
+						&ssid->passphrase);
+
+	if (ssid->ca_cert_path)
+		supplicant_dbus_dict_append_basic(dict, "ca_cert",
+						DBUS_TYPE_STRING,
+						&ssid->ca_cert_path);
+
+	supplicant_dbus_dict_append_basic(dict, "phase2",
+						DBUS_TYPE_STRING,
+						&phase2_auth);
+
+	g_free(phase2_auth);
+}
+
+static void add_network_security_eap(DBusMessageIter *dict,
+					GSupplicantSSID *ssid)
+{
+	char *eap_value;
+
+	if (!ssid->eap || !ssid->identity)
+		return;
+
+	if (g_strcmp0(ssid->eap, "tls") == 0) {
+		add_network_security_tls(dict, ssid);
+	} else if (g_strcmp0(ssid->eap, "peap") == 0 ||
+				g_strcmp0(ssid->eap, "ttls") == 0) {
+		add_network_security_peap(dict, ssid);
+	} else
+		return;
+
+	eap_value = g_ascii_strup(ssid->eap, -1);
+
+	supplicant_dbus_dict_append_basic(dict, "eap",
+						DBUS_TYPE_STRING,
+						&eap_value);
+	supplicant_dbus_dict_append_basic(dict, "identity",
+						DBUS_TYPE_STRING,
+						&ssid->identity);
+	if(ssid->anonymous_identity)
+		supplicant_dbus_dict_append_basic(dict, "anonymous_identity",
+						     DBUS_TYPE_STRING,
+						     &ssid->anonymous_identity);
+
+	if(ssid->subject_match)
+		supplicant_dbus_dict_append_basic(dict, "subject_match",
+						     DBUS_TYPE_STRING,
+						     &ssid->subject_match);
+
+	if(ssid->altsubject_match)
+		supplicant_dbus_dict_append_basic(dict, "altsubject_match",
+						     DBUS_TYPE_STRING,
+						     &ssid->altsubject_match);
+
+	if(ssid->domain_suffix_match)
+		supplicant_dbus_dict_append_basic(dict, "domain_suffix_match",
+						     DBUS_TYPE_STRING,
+						     &ssid->domain_suffix_match);
+
+	if(ssid->domain_match)
+		supplicant_dbus_dict_append_basic(dict, "domain_match",
+						     DBUS_TYPE_STRING,
+						     &ssid->domain_match);
+
+	g_free(eap_value);
+}
+
+static void add_network_security_ciphers(DBusMessageIter *dict,
+						GSupplicantSSID *ssid)
+{
+	unsigned int p_cipher, g_cipher, i;
+	char *pairwise, *group;
+	char *pair_ciphers[4];
+	char *group_ciphers[5];
+
+	p_cipher = ssid->pairwise_cipher;
+	g_cipher = ssid->group_cipher;
+
+	if (p_cipher == 0 && g_cipher == 0)
+		return;
+
+	i = 0;
+
+	if (p_cipher & G_SUPPLICANT_PAIRWISE_CCMP)
+		pair_ciphers[i++] = "CCMP";
+
+	if (p_cipher & G_SUPPLICANT_PAIRWISE_TKIP)
+		pair_ciphers[i++] = "TKIP";
+
+	if (p_cipher & G_SUPPLICANT_PAIRWISE_NONE)
+		pair_ciphers[i++] = "NONE";
+
+	pair_ciphers[i] = NULL;
+
+	i = 0;
+
+	if (g_cipher & G_SUPPLICANT_GROUP_CCMP)
+		group_ciphers[i++] = "CCMP";
+
+	if (g_cipher & G_SUPPLICANT_GROUP_TKIP)
+		group_ciphers[i++] = "TKIP";
+
+	if (g_cipher & G_SUPPLICANT_GROUP_WEP104)
+		group_ciphers[i++] = "WEP104";
+
+	if (g_cipher & G_SUPPLICANT_GROUP_WEP40)
+		group_ciphers[i++] = "WEP40";
+
+	group_ciphers[i] = NULL;
+
+	pairwise = g_strjoinv(" ", pair_ciphers);
+	group = g_strjoinv(" ", group_ciphers);
+
+	SUPPLICANT_DBG("cipher %s %s", pairwise, group);
+
+	supplicant_dbus_dict_append_basic(dict, "pairwise",
+						DBUS_TYPE_STRING,
+						&pairwise);
+	supplicant_dbus_dict_append_basic(dict, "group",
+						DBUS_TYPE_STRING,
+						&group);
+
+	g_free(pairwise);
+	g_free(group);
+}
+
+static void add_network_security_proto(DBusMessageIter *dict,
+						GSupplicantSSID *ssid)
+{
+	unsigned int protocol, i;
+	char *proto;
+	char *protos[3];
+
+	protocol = ssid->protocol;
+
+	if (protocol == 0)
+		return;
+
+	i = 0;
+
+	if (protocol & G_SUPPLICANT_PROTO_RSN)
+		protos[i++] = "RSN";
+
+	if (protocol & G_SUPPLICANT_PROTO_WPA)
+		protos[i++] = "WPA";
+
+	protos[i] = NULL;
+
+	proto = g_strjoinv(" ", protos);
+
+	SUPPLICANT_DBG("proto %s", proto);
+
+	supplicant_dbus_dict_append_basic(dict, "proto",
+						DBUS_TYPE_STRING,
+						&proto);
+
+	g_free(proto);
+}
+
+static void add_network_security(DBusMessageIter *dict, GSupplicantSSID *ssid)
+{
+	char *key_mgmt;
+
+	switch (ssid->security) {
+	case G_SUPPLICANT_SECURITY_NONE:
+		key_mgmt = "NONE";
+		add_network_security_none(dict);
+		add_network_security_ciphers(dict, ssid);
+		break;
+	case G_SUPPLICANT_SECURITY_UNKNOWN:
+	case G_SUPPLICANT_SECURITY_WEP:
+		key_mgmt = "NONE";
+		add_network_security_wep(dict, ssid);
+		add_network_security_ciphers(dict, ssid);
+		break;
+	case G_SUPPLICANT_SECURITY_PSK:
+		key_mgmt = "WPA-PSK";
+		add_network_security_psk(dict, ssid);
+		add_network_security_ciphers(dict, ssid);
+		add_network_security_proto(dict, ssid);
+		break;
+	case G_SUPPLICANT_SECURITY_IEEE8021X:
+		key_mgmt = "WPA-EAP";
+		add_network_security_eap(dict, ssid);
+		add_network_security_ciphers(dict, ssid);
+		add_network_security_proto(dict, ssid);
+		break;
+	}
+
+	supplicant_dbus_dict_append_basic(dict, "key_mgmt",
+				DBUS_TYPE_STRING, &key_mgmt);
+}
+
+static void add_network_mode(DBusMessageIter *dict, GSupplicantSSID *ssid)
+{
+	dbus_uint32_t mode;
+
+	switch (ssid->mode) {
+	case G_SUPPLICANT_MODE_UNKNOWN:
+	case G_SUPPLICANT_MODE_INFRA:
+		mode = 0;
+		break;
+	case G_SUPPLICANT_MODE_IBSS:
+		mode = 1;
+		break;
+	case G_SUPPLICANT_MODE_MASTER:
+		mode = 2;
+		break;
+	}
+
+	supplicant_dbus_dict_append_basic(dict, "mode",
+				DBUS_TYPE_UINT32, &mode);
+}
+
+static void interface_add_network_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	struct interface_connect_data *data = user_data;
+	GSupplicantSSID *ssid = data->ssid;
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (ssid->scan_ssid)
+		supplicant_dbus_dict_append_basic(&dict, "scan_ssid",
+					 DBUS_TYPE_UINT32, &ssid->scan_ssid);
+
+	if (ssid->freq)
+		supplicant_dbus_dict_append_basic(&dict, "frequency",
+					 DBUS_TYPE_UINT32, &ssid->freq);
+
+	if (ssid->bgscan)
+		supplicant_dbus_dict_append_basic(&dict, "bgscan",
+					DBUS_TYPE_STRING, &ssid->bgscan);
+
+	add_network_mode(&dict, ssid);
+
+	add_network_security(&dict, ssid);
+
+	supplicant_dbus_dict_append_fixed_array(&dict, "ssid",
+					DBUS_TYPE_BYTE, &ssid->ssid,
+						ssid->ssid_len);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void interface_wps_start_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	int err;
+
+	SUPPLICANT_DBG("");
+
+	err = 0;
+	if (error) {
+		SUPPLICANT_DBG("error: %s", error);
+		err = parse_supplicant_error(iter);
+	}
+
+	if(data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data->path);
+	g_free(data->ssid);
+	dbus_free(data);
+}
+
+static void interface_add_wps_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	GSupplicantSSID *ssid = data->ssid;
+	const char *role = "enrollee", *type;
+	DBusMessageIter dict;
+
+	SUPPLICANT_DBG("");
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	supplicant_dbus_dict_append_basic(&dict, "Role",
+						DBUS_TYPE_STRING, &role);
+
+	type = "pbc";
+	if (ssid->pin_wps) {
+		type = "pin";
+		supplicant_dbus_dict_append_basic(&dict, "Pin",
+					DBUS_TYPE_STRING, &ssid->pin_wps);
+	}
+
+	supplicant_dbus_dict_append_basic(&dict, "Type",
+					DBUS_TYPE_STRING, &type);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void wps_start(const char *error, DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		SUPPLICANT_DBG("error: %s", error);
+		g_free(data->path);
+		g_free(data->ssid);
+		dbus_free(data);
+		return;
+	}
+
+	supplicant_dbus_method_call(data->interface->path,
+			SUPPLICANT_INTERFACE ".Interface.WPS", "Start",
+			interface_add_wps_params,
+			interface_wps_start_result, data, NULL);
+}
+
+static void wps_process_credentials(DBusMessageIter *iter, void *user_data)
+{
+	dbus_bool_t credentials = TRUE;
+
+	SUPPLICANT_DBG("");
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &credentials);
+}
+
+
+int g_supplicant_interface_connect(GSupplicantInterface *interface,
+				GSupplicantSSID *ssid,
+				GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_connect_data *data;
+	struct interface_data *intf_data;
+	int ret = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	/* TODO: Check if we're already connected and switch */
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->ssid = ssid;
+	data->user_data = user_data;
+
+	if (ssid->use_wps) {
+		g_free(interface->wps_cred.key);
+		memset(&interface->wps_cred, 0,
+				sizeof(struct _GSupplicantWpsCredentials));
+
+		ret = supplicant_dbus_property_set(interface->path,
+			SUPPLICANT_INTERFACE ".Interface.WPS",
+			"ProcessCredentials", DBUS_TYPE_BOOLEAN_AS_STRING,
+			wps_process_credentials, wps_start, data, interface);
+	} else {
+		/* By the time there is a request for connect and the network
+		 * path is not NULL it means that connman has not removed the
+		 * previous network pointer. This can happen in the case AP
+		 * deauthenticated client and connman does not remove the
+		 * previously connected network pointer. This causes supplicant
+		 * to reallocate the memory for struct wpa_ssid again even if it
+		 * is the same SSID. This causes memory usage of wpa_supplicnat
+		 * to go high. The idea here is that if the previously connected
+		 * network is not removed at the time of next connection attempt
+		 * check if the network path is not NULL. In case it is non-NULL
+		 * first remove the network and then once removal is successful, add
+		 * the network.
+		 */
+
+		if (interface->network_path != NULL) {
+			g_free(data->path);
+			dbus_free(data);
+
+			/*
+			 * If this add network is for the same network for
+			 * which wpa_supplicant already has a profile then do
+			 * not need to add another profile. Only if the
+			 * profile that needs to get added is different from
+			 * what is there in wpa_s delete the current one. A
+			 * network is identified by its SSID, security_type
+			 * and passphrase (private passphrase in case security
+			 * type is 802.11x).
+			 */
+			if (compare_network_parameters(interface, ssid)) {
+				return -EALREADY;
+			}
+
+			intf_data = dbus_malloc0(sizeof(*intf_data));
+			if (!intf_data)
+				return -ENOMEM;
+
+			intf_data->interface = interface;
+			intf_data->path = g_strdup(interface->path);
+			intf_data->callback = callback;
+			intf_data->ssid = ssid;
+			intf_data->user_data = user_data;
+			intf_data->network_remove_in_progress = TRUE;
+			network_remove(intf_data);
+		} else {
+			ret = supplicant_dbus_method_call(interface->path,
+					SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
+					interface_add_network_params,
+					interface_add_network_result, data,
+					interface);
+		}
+        }
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void interface_wps_cancel_result(const char *error,
+		DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error != NULL) {
+		SUPPLICANT_DBG("error: %s", error);
+		err = parse_supplicant_error(iter);
+	}
+
+	if (data->callback != NULL)
+		data->callback(err, data->interface, data->user_data);
+
+	dbus_free(data);
+}
+
+int g_supplicant_interface_wps_cancel(GSupplicantInterface *interface,
+		GSupplicantInterfaceCallback callback,
+			void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+		SUPPLICANT_INTERFACE ".Interface.WPS", "Cancel",
+		NULL,
+		interface_wps_cancel_result, data, interface);
+
+	if (ret < 0) {
+		g_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void network_remove_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	struct interface_connect_data *connect_data;
+	int result = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		result = -EIO;
+		SUPPLICANT_DBG("error: %s", error);
+
+		if (g_strcmp0("org.freedesktop.DBus.Error.UnknownMethod",
+						error) == 0)
+			result = -ECONNABORTED;
+	}
+
+	g_free(data->interface->network_path);
+	data->interface->network_path = NULL;
+
+	remove_network_information(data->interface);
+
+	if (data->network_remove_in_progress == TRUE) {
+		data->network_remove_in_progress = FALSE;
+		connect_data = dbus_malloc0(sizeof(*connect_data));
+		if (!connect_data)
+			return;
+
+		connect_data->interface = data->interface;
+		connect_data->path = g_strdup(data->path);
+		connect_data->callback = data->callback;
+		connect_data->ssid = data->ssid;
+		connect_data->user_data = data->user_data;
+
+		supplicant_dbus_method_call(data->interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
+			interface_add_network_params,
+			interface_add_network_result, connect_data,
+			connect_data->interface);
+	} else {
+		if (data->callback)
+			data->callback(result, data->interface, data->user_data);
+	}
+	g_free(data->path);
+	dbus_free(data);
+}
+
+static void network_remove_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	const char *path = data->interface->network_path;
+
+	SUPPLICANT_DBG("path %s", path);
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
+}
+
+static int network_remove(struct interface_data *data)
+{
+	GSupplicantInterface *interface = data->interface;
+
+	SUPPLICANT_DBG("");
+
+	return supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "RemoveNetwork",
+			network_remove_params, network_remove_result, data,
+			interface);
+}
+
+static void interface_disconnect_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int result = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		result = -EIO;
+		SUPPLICANT_DBG("error: %s", error);
+
+		if (g_strcmp0("org.freedesktop.DBus.Error.UnknownMethod",
+						error) == 0)
+			result = -ECONNABORTED;
+	}
+
+	/* If we are disconnecting from previous WPS successful
+	 * association. i.e.: it did not went through AddNetwork,
+	 * and interface->network_path was never set. */
+	if (!data->interface->network_path) {
+		if (data->callback)
+			data->callback(result, data->interface,
+							data->user_data);
+
+		g_free(data->path);
+		dbus_free(data);
+		return;
+	}
+
+	if (result < 0 && data->callback) {
+		data->callback(result, data->interface, data->user_data);
+		data->callback = NULL;
+	}
+
+	if (result != -ECONNABORTED) {
+		if (network_remove(data) < 0) {
+			g_free(data->path);
+			dbus_free(data);
+		}
+	} else {
+		g_free(data->path);
+		dbus_free(data);
+	}
+}
+
+int g_supplicant_interface_disconnect(GSupplicantInterface *interface,
+					GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "Disconnect",
+			NULL, interface_disconnect_result, data,
+			interface);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+	}
+
+	return ret;
+}
+
+struct interface_p2p_find_data {
+	GSupplicantInterface *interface;
+	char *path;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PFindParams *p2p_find_params;
+	void *user_data;
+};
+
+static void interface_p2p_find_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_find_data *data = user_data;
+	int err = 0;
+
+	if (error != NULL) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+	if (interface_exists(data->interface, data->path)) {
+		if (!data->interface->ready)
+			err = -ENOLINK;
+		if (!err) {
+			data->interface->p2p_finding = true;
+		}
+	}
+
+	if (data->callback != NULL)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data->path);
+	dbus_free(data);
+}
+
+static void interface_p2p_find_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	struct interface_p2p_find_data *data = user_data;
+	int timeout = 0;
+	char *disc_type = "social";
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (data && data->p2p_find_params) {
+		GSupplicantP2PFindParams* params = data->p2p_find_params;
+		supplicant_dbus_dict_append_basic(&dict, "Timeout",
+												DBUS_TYPE_INT32, &params->timeout);
+
+		if(params->disc_type == G_SUPPLICANT_P2P_FIND_START_WITH_FULL) {
+			disc_type = "start_with_full";
+		}
+		else if(params->disc_type == G_SUPPLICANT_P2P_FIND_PROGRESSIVE) {
+			disc_type = "progressive";
+		}
+		else {
+			disc_type = "social";
+		}
+
+		supplicant_dbus_dict_append_basic(&dict, "DiscoveryType",
+											DBUS_TYPE_STRING, &disc_type);
+
+		if (params->frequency != 0)
+			supplicant_dbus_dict_append_basic(&dict, "Frequency",
+											  DBUS_TYPE_INT32, &params->frequency);
+
+		if (params->seek_array != NULL){
+
+			DBusMessageIter entry;
+			DBusMessageIter value;
+			DBusMessageIter array;
+			const char** seek = params->seek_array;
+			const char* key = "Seek";
+
+			dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY, NULL, &entry);
+			dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+			dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+											 DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_STRING_AS_STRING, &value);
+			dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY, DBUS_TYPE_STRING_AS_STRING, &array);
+
+			// Append items from null terminated array
+			while(*seek)
+			{
+				dbus_message_iter_append_basic(&array, DBUS_TYPE_STRING, seek);
+				seek++;
+			}
+
+			dbus_message_iter_close_container(&value, &array);
+			dbus_message_iter_close_container(&entry, &value);
+
+			dbus_message_iter_close_container(&dict, &entry);
+		}
+	} else
+		supplicant_dbus_dict_append_basic(&dict, "Timeout",
+					DBUS_TYPE_INT32, &timeout);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+int g_supplicant_interface_p2p_find(GSupplicantInterface *interface,
+				GSupplicantP2PFindParams *find_data,
+				GSupplicantInterfaceCallback callback,
+							void *user_data)
+{
+	struct interface_p2p_find_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->user_data = user_data;
+	data->p2p_find_params = find_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+										SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Find",
+										interface_p2p_find_params, interface_p2p_find_result, data, NULL);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+	}
+	return ret;
+}
+
+bool g_supplicant_interface_is_p2p_finding(GSupplicantInterface *interface)
+{
+	if (!interface)
+		return false;
+
+	return interface->p2p_finding;
+}
+
+int g_supplicant_interface_p2p_stop_find(GSupplicantInterface *interface)
+{
+	if (!interface)
+		return 0;
+
+	SUPPLICANT_DBG("");
+
+	interface->p2p_finding = false;
+
+	return supplicant_dbus_method_call(interface->path,
+		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "StopFind",
+		NULL, NULL, NULL, NULL);
+}
+
+static void interface_p2p_connect_result(const char *error,
+					DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	int err = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		SUPPLICANT_DBG("error: %s", error);
+		err = parse_supplicant_error(iter);
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data->path);
+	g_free(data->peer->wps_pin);
+	g_free(data->peer->wps_method);
+	g_free(data->peer->path);
+	g_free(data->peer);
+	g_free(data);
+}
+
+static void interface_p2p_connect_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_connect_data *data = user_data;
+	const char *wps = data->peer->wps_method?data->peer->wps_method:"pbc";
+	DBusMessageIter dict;
+	int go_intent = 7;
+
+	SUPPLICANT_DBG("");
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (data->peer->master)
+		go_intent = 15;
+
+	if (data->peer->wps_method==NULL && data->peer->wps_pin)
+		wps = "pin";
+
+	supplicant_dbus_dict_append_basic(&dict, "peer",
+				DBUS_TYPE_OBJECT_PATH, &data->peer->path);
+	supplicant_dbus_dict_append_basic(&dict, "wps_method",
+				DBUS_TYPE_STRING, &wps);
+	if (data->peer->wps_pin) {
+		supplicant_dbus_dict_append_basic(&dict, "pin",
+				DBUS_TYPE_STRING, &data->peer->wps_pin);
+	}
+
+	supplicant_dbus_dict_append_basic(&dict, "persistent",
+				DBUS_TYPE_BOOLEAN, &data->peer->persistent);
+
+	if (data->peer->go_intent)
+		go_intent = data->peer->go_intent;
+
+	supplicant_dbus_dict_append_basic(&dict, "go_intent",
+				DBUS_TYPE_INT32, &go_intent);
+
+	supplicant_dbus_dict_append_basic(&dict, "join",
+				DBUS_TYPE_BOOLEAN, &data->peer->join);
+
+	supplicant_dbus_dict_append_basic(&dict, "authorize_only",
+				DBUS_TYPE_BOOLEAN, &data->peer->authorize_only);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+int g_supplicant_interface_p2p_connect(GSupplicantInterface *interface,
+					GSupplicantPeerParams *peer_params,
+					GSupplicantInterfaceCallback callback,
+					void *user_data)
+{
+	struct interface_connect_data *data;
+	int ret;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface->p2p_support)
+		return -ENOTSUP;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->peer = peer_params;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Connect",
+		interface_p2p_connect_params, interface_p2p_connect_result,
+		data, interface);
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+int g_supplicant_interface_p2p_disconnect(GSupplicantInterface *interface,
+					GSupplicantPeerParams *peer_params)
 {
-	dbus_uint32_t mode;
+	GSupplicantPeer *peer;
+	int count = 0;
+	GSList *list;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface->p2p_support)
+		return -ENOTSUP;
+
+	peer = g_hash_table_lookup(interface->peer_table, peer_params->path);
+	if (!peer)
+		return -ENODEV;
+
+	for (list = peer->groups; list; list = list->next, count++) {
+		const char *group_obj_path = list->data;
+		GSupplicantInterface *g_interface;
+		GSupplicantGroup *group;
+
+		group = g_hash_table_lookup(group_mapping, group_obj_path);
+		if (!group || !group->interface)
+			continue;
+
+		g_interface = group->interface;
+		supplicant_dbus_method_call(g_interface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"Disconnect", NULL, NULL, NULL, g_interface);
+	}
+
+	if (count == 0 && peer->current_group_iface) {
+		supplicant_dbus_method_call(peer->current_group_iface->path,
+				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+				"Disconnect", NULL, NULL, NULL,
+				peer->current_group_iface->path);
+	}
+
+	peer->current_group_iface = NULL;
+
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_disconnect_result(const char *error,
+													DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err = 0;
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	dbus_free(data);
+}
+
+int g_supplicant_interface_p2p_group_disconnect(GSupplicantInterface *interface,
+													GSupplicantInterfaceCallback callback,
+													void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	SUPPLICANT_DBG("interface->path : %s\n", interface->path);
+
+	ret = supplicant_dbus_method_call(interface->path,
+									SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+									"Disconnect", NULL,
+									interface_p2p_disconnect_result, data, NULL);
+
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_client_remove_result(const char *error,
+							DBusMessageIter *iter, void *user_data)
+{
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+	}
+}
+
+static void interface_p2p_client_remove_params(DBusMessageIter *iter, void *user_data)
+{
+	char* peer_path = user_data;
+	DBusMessageIter dict;
+
+	supplicant_dbus_dict_open(iter, &dict);
+	supplicant_dbus_dict_append_basic(&dict, "peer",
+					DBUS_TYPE_OBJECT_PATH, &peer_path);
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+int g_supplicant_interface_p2p_client_remove(GSupplicantInterface *interface,
+					GSupplicantInterfaceCallback callback,
+					char* peer_path)
+{
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	SUPPLICANT_DBG("interface->path : %s\n", interface->path);
+
+	ret = supplicant_dbus_method_call(interface->path,
+									SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+									"RemoveClient", interface_p2p_client_remove_params,
+									interface_p2p_client_remove_result, (void*) peer_path, NULL);
+
+	if (ret < 0) {
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_cancel_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data->path);
+	dbus_free(data);
+}
+
+int g_supplicant_interface_p2p_cancel(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback,
+				void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	if (!interface->p2p_support)
+		return -ENOTSUP;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Cancel",
+			NULL, interface_p2p_cancel_result, data, NULL);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_flush_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err = 0;
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	dbus_free(data);
+}
+
+int g_supplicant_interface_p2p_flush(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback,
+				void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Flush",
+					NULL, interface_p2p_flush_result, data, NULL);
+
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_reject_peer_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_reject_data *data = user_data;
+	int err = 0;
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	dbus_free(data);
+}
+
+static void interface_p2p_reject_params(DBusMessageIter *iter, void *user_data)
+{
+	struct interface_reject_data *data = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&data->peer->path);
+}
+
+int g_supplicant_interface_p2p_reject(GSupplicantInterface *interface,
+					GSupplicantPeerParams *peer_params,
+					GSupplicantInterfaceCallback callback,
+					void *user_data)
+{
+	struct interface_reject_data* data;
+	int ret;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface || !peer_params || !peer_params->path)
+		return -EINVAL;
+
+	if (!interface->p2p_support)
+		return -ENOTSUP;
 
-	switch (ssid->mode) {
-	case G_SUPPLICANT_MODE_UNKNOWN:
-	case G_SUPPLICANT_MODE_INFRA:
-		mode = 0;
-		break;
-	case G_SUPPLICANT_MODE_IBSS:
-		mode = 1;
-		break;
-	case G_SUPPLICANT_MODE_MASTER:
-		mode = 2;
-		break;
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->peer = peer_params;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface.P2PDevice", "RejectPeer",
+			interface_p2p_reject_params, interface_p2p_reject_peer_result, data, NULL);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+		return ret;
 	}
 
-	supplicant_dbus_dict_append_basic(dict, "mode",
-				DBUS_TYPE_UINT32, &mode);
+	return -EINPROGRESS;
 }
 
-static void interface_add_network_params(DBusMessageIter *iter, void *user_data)
+struct interface_p2p_sd_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PSDParams *p2p_sd_params;
+	void *user_data;
+};
+
+static void interface_p2p_sd_request_params(DBusMessageIter *iter, void *user_data)
 {
 	DBusMessageIter dict;
-	struct interface_connect_data *data = user_data;
-	GSupplicantSSID *ssid = data->ssid;
+	struct interface_p2p_sd_data *data = user_data;
 
 	supplicant_dbus_dict_open(iter, &dict);
 
-	if (ssid->scan_ssid)
-		supplicant_dbus_dict_append_basic(&dict, "scan_ssid",
-					 DBUS_TYPE_UINT32, &ssid->scan_ssid);
+	if (data && data->p2p_sd_params) {
+		GSupplicantP2PSDParams* params = data->p2p_sd_params;
+
+		if(params->peer)
+			supplicant_dbus_dict_append_basic(&dict, "peer_object",
+												DBUS_TYPE_OBJECT_PATH, &params->peer);
+
+		if(params->service_type)
+			supplicant_dbus_dict_append_basic(&dict, "service_type",
+												DBUS_TYPE_STRING, &params->service_type);
+
+		if(params->version > 0)
+			supplicant_dbus_dict_append_basic(&dict, "version",
+												DBUS_TYPE_INT32, &params->version);
+
+		if(params->desc)
+			supplicant_dbus_dict_append_basic(&dict, "service",
+												DBUS_TYPE_STRING, &params->desc);
+
+		if(params->query_len > 0)
+			supplicant_dbus_dict_append_fixed_array(&dict, "tlv",
+														DBUS_TYPE_BYTE, &params->query, params->query_len);
+		if(params->service_info != NULL)
+			supplicant_dbus_dict_append_basic(&dict, "service_info",
+												DBUS_TYPE_STRING, &params->service_info);
+		if(params->service_transaction_id != 0)
+			supplicant_dbus_dict_append_basic(&dict, "service_transaction_id",
+												DBUS_TYPE_BYTE, &params->service_transaction_id);
+	}
 
-	if (ssid->freq)
-		supplicant_dbus_dict_append_basic(&dict, "frequency",
-					 DBUS_TYPE_UINT32, &ssid->freq);
+	supplicant_dbus_dict_close(iter, &dict);
+}
 
-	if (ssid->bgscan)
-		supplicant_dbus_dict_append_basic(&dict, "bgscan",
-					DBUS_TYPE_STRING, &ssid->bgscan);
+static void interface_p2p_sd_request_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_sd_data *data = user_data;
+	int err = 0;
+	dbus_uint64_t ref = 0;
 
-	add_network_mode(&dict, ssid);
+	if (error != NULL) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
 
-	add_network_security(&dict, ssid);
+	if (data->callback != NULL)
+	{
+		if(err == 0) {
+			dbus_message_iter_get_basic(iter, &ref);
+			((GSupplicantInterfaceCallbackWithData)data->callback)(0, data->interface, data->user_data, &ref);
+		} else {
+			((GSupplicantInterfaceCallbackWithData)data->callback)(err, data->interface, data->user_data, NULL);
+		}
+	}
 
-	supplicant_dbus_dict_append_fixed_array(&dict, "ssid",
-					DBUS_TYPE_BYTE, &ssid->ssid,
-						ssid->ssid_len);
+	dbus_free(data);
+}
 
-	supplicant_dbus_dict_close(iter, &dict);
+int g_supplicant_interface_p2p_sd_request(GSupplicantInterface *interface,
+				GSupplicantP2PSDParams *sd_data,
+				GSupplicantInterfaceCallbackWithData callback,
+				void *user_data)
+{
+	struct interface_p2p_sd_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = (GSupplicantInterfaceCallback) callback;
+	data->user_data = user_data;
+	data->p2p_sd_params = sd_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+										SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ServiceDiscoveryRequest",
+										interface_p2p_sd_request_params, interface_p2p_sd_request_result, data, NULL);
+
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
 }
 
-static void interface_wps_start_result(const char *error,
+static void interface_p2p_sd_cancel_request_result(const char *error,
 				DBusMessageIter *iter, void *user_data)
 {
-	struct interface_connect_data *data = user_data;
-	int err;
-
-	SUPPLICANT_DBG("");
+	struct interface_p2p_sd_data *data = user_data;
+	int err = 0;
 
-	err = 0;
-	if (error) {
-		SUPPLICANT_DBG("error: %s", error);
-		err = parse_supplicant_error(iter);
+	if (error != NULL) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
 	}
 
-	if(data->callback)
+	if (data->callback != NULL)
+	{
 		data->callback(err, data->interface, data->user_data);
+	}
 
-	g_free(data->path);
-	g_free(data->ssid);
 	dbus_free(data);
 }
 
-static void interface_add_wps_params(DBusMessageIter *iter, void *user_data)
+static void interface_p2p_sd_cancel_request_params(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_connect_data *data = user_data;
-	GSupplicantSSID *ssid = data->ssid;
-	const char *role = "enrollee", *type;
+	struct interface_p2p_sd_data *data = user_data;
+	if (data && data->p2p_sd_params) {
+		uint64_t *request_id = (uint64_t*)data->p2p_sd_params;
+		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT64, request_id);
+	}
+}
+
+int g_supplicant_interface_p2p_sd_cancel_request(GSupplicantInterface *interface,
+				dbus_uint64_t request_id,
+				GSupplicantInterfaceCallback callback,
+				void *user_data)
+{
+	struct interface_p2p_sd_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+	data->p2p_sd_params = (void*)&request_id;
+
+	ret = supplicant_dbus_method_call(interface->path,
+									  SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ServiceDiscoveryCancelRequest",
+									  interface_p2p_sd_cancel_request_params, interface_p2p_sd_cancel_request_result, data, NULL);
+
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
+struct p2p_service_data {
+	bool registration;
+	GSupplicantInterface *interface;
+	GSupplicantP2PServiceParams *service;
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
+};
+
+static void interface_p2p_service_result(const char *error,
+					DBusMessageIter *iter, void *user_data)
+{
+	struct p2p_service_data *data = user_data;
+	int result = 0;
+
+	SUPPLICANT_DBG("%s result - %s", data->registration ?
+				"Registration" : "Deletion",
+				error ? error : "Success");
+	if (error)
+		result = -EINVAL;
+
+	if (data->callback)
+		data->callback(result, data->interface, data->user_data);
+
+	g_free(data->service->query);
+	g_free(data->service->response);
+	g_free(data->service->service);
+	g_free(data->service->wfd_ies);
+	g_free(data->service);
+	dbus_free(data);
+}
+
+static void interface_p2p_service_params(DBusMessageIter *iter,
+							void *user_data)
+{
+	struct p2p_service_data *data = user_data;
+	GSupplicantP2PServiceParams *service;
+	DBusMessageIter dict;
+	const char *type;
+
+	SUPPLICANT_DBG("");
+
+	service = data->service;
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (service->query && service->response) {
+		type = "bonjour";
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
+		supplicant_dbus_dict_append_fixed_array(&dict, "query",
+					DBUS_TYPE_BYTE, &service->query,
+					service->query_length);
+		supplicant_dbus_dict_append_fixed_array(&dict, "response",
+					DBUS_TYPE_BYTE, &service->response,
+					service->response_length);
+	} else if (service->version && service->service) {
+		type = "upnp";
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
+		supplicant_dbus_dict_append_basic(&dict, "version",
+					DBUS_TYPE_INT32, &service->version);
+		supplicant_dbus_dict_append_basic(&dict, "service",
+					DBUS_TYPE_STRING, &service->service);
+	} else if (service->adv_id > 0) {
+		type = "asp";
+
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
+
+		if (service->service)
+			supplicant_dbus_dict_append_basic(&dict, "service",
+					DBUS_TYPE_STRING, &service->service);
+
+		if(service->adv_id != 0)
+			supplicant_dbus_dict_append_basic(&dict, "adv_id",
+			             DBUS_TYPE_UINT32, &service->adv_id);
+
+		supplicant_dbus_dict_append_basic(&dict, "auto_accept",
+		                                  DBUS_TYPE_UINT32, &service->auto_accept);
+
+		supplicant_dbus_dict_append_basic(&dict, "service_state",
+		                                  DBUS_TYPE_BYTE, &service->service_state);
+
+		supplicant_dbus_dict_append_basic(&dict, "config_method",
+		                                  DBUS_TYPE_UINT16, &service->config_method);
+
+		if(service->service_info)
+			supplicant_dbus_dict_append_basic(&dict, "service_info",
+							DBUS_TYPE_STRING, &service->service_info);
+	}
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void interface_p2p_delete_service_params(DBusMessageIter *iter,
+							void *user_data)
+{
+	struct p2p_service_data *data = user_data;
+	GSupplicantP2PServiceParams *service;
 	DBusMessageIter dict;
+	const char *type;
+
+	SUPPLICANT_DBG("");
+
+	service = data->service;
+
+	supplicant_dbus_dict_open(iter, &dict);
+
+	if (service->query && service->response) {
+		type = "bonjour";
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
+		supplicant_dbus_dict_append_fixed_array(&dict, "query",
+					DBUS_TYPE_BYTE, &service->query,
+					service->query_length);
+		supplicant_dbus_dict_append_fixed_array(&dict, "response",
+					DBUS_TYPE_BYTE, &service->response,
+					service->response_length);
+	} else if (service->version && service->service) {
+		type = "upnp";
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
+		supplicant_dbus_dict_append_basic(&dict, "version",
+					DBUS_TYPE_INT32, &service->version);
+		supplicant_dbus_dict_append_basic(&dict, "service",
+					DBUS_TYPE_STRING, &service->service);
+	} else if (service->adv_id > 0) {
+		type = "asp";
+
+		supplicant_dbus_dict_append_basic(&dict, "service_type",
+						DBUS_TYPE_STRING, &type);
 
-	SUPPLICANT_DBG("");
+		if (service->service)
+			supplicant_dbus_dict_append_basic(&dict, "service",
+					DBUS_TYPE_STRING, &service->service);
 
-	supplicant_dbus_dict_open(iter, &dict);
+		if(service->adv_id != 0)
+			supplicant_dbus_dict_append_basic(&dict, "adv_id",
+			             DBUS_TYPE_UINT32, &service->adv_id);
 
-	supplicant_dbus_dict_append_basic(&dict, "Role",
-						DBUS_TYPE_STRING, &role);
+		supplicant_dbus_dict_append_basic(&dict, "auto_accept",
+		                                  DBUS_TYPE_UINT32, &service->auto_accept);
 
-	type = "pbc";
-	if (ssid->pin_wps) {
-		type = "pin";
-		supplicant_dbus_dict_append_basic(&dict, "Pin",
-					DBUS_TYPE_STRING, &ssid->pin_wps);
-	}
+		supplicant_dbus_dict_append_basic(&dict, "service_state",
+		                                  DBUS_TYPE_BYTE, &service->service_state);
 
-	supplicant_dbus_dict_append_basic(&dict, "Type",
-					DBUS_TYPE_STRING, &type);
+		supplicant_dbus_dict_append_basic(&dict, "config_method",
+		                                  DBUS_TYPE_UINT16, &service->config_method);
 
+		if(service->service_info)
+			supplicant_dbus_dict_append_basic(&dict, "service_info",
+							DBUS_TYPE_STRING, &service->service_info);
+	}
 	supplicant_dbus_dict_close(iter, &dict);
 }
 
-static void wps_start(const char *error, DBusMessageIter *iter, void *user_data)
+int g_supplicant_interface_p2p_add_service(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback,
+				GSupplicantP2PServiceParams *p2p_service_params,
+				void *user_data)
 {
-	struct interface_connect_data *data = user_data;
+	struct p2p_service_data *data;
+	int ret;
 
 	SUPPLICANT_DBG("");
 
-	if (error) {
-		SUPPLICANT_DBG("error: %s", error);
-		g_free(data->path);
-		g_free(data->ssid);
-		dbus_free(data);
-		return;
-	}
+	if (!interface->p2p_support)
+		return -ENOTSUP;
 
-	supplicant_dbus_method_call(data->interface->path,
-			SUPPLICANT_INTERFACE ".Interface.WPS", "Start",
-			interface_add_wps_params,
-			interface_wps_start_result, data, NULL);
-}
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
 
-static void wps_process_credentials(DBusMessageIter *iter, void *user_data)
-{
-	dbus_bool_t credentials = TRUE;
+	data->registration = true;
+	data->interface = interface;
+	data->service = p2p_service_params;
+	data->callback = callback;
+	data->user_data = user_data;
 
-	SUPPLICANT_DBG("");
+	ret = supplicant_dbus_method_call(interface->path,
+		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "AddService",
+		interface_p2p_service_params, interface_p2p_service_result,
+		data, interface);
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &credentials);
+	return -EINPROGRESS;
 }
 
-
-int g_supplicant_interface_connect(GSupplicantInterface *interface,
-				GSupplicantSSID *ssid,
-				GSupplicantInterfaceCallback callback,
-							void *user_data)
+int g_supplicant_interface_p2p_del_service(GSupplicantInterface *interface,
+				GSupplicantP2PServiceParams *p2p_service_params)
 {
-	struct interface_connect_data *data;
-	struct interface_data *intf_data;
-	int ret = 0;
+	struct p2p_service_data *data;
+	int ret;
 
 	SUPPLICANT_DBG("");
 
-	if (!interface)
-		return -EINVAL;
-
-	if (!system_available)
-		return -EFAULT;
-
-	/* TODO: Check if we're already connected and switch */
+	if (!interface->p2p_support)
+		return -ENOTSUP;
 
 	data = dbus_malloc0(sizeof(*data));
 	if (!data)
 		return -ENOMEM;
 
 	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->callback = callback;
-	data->ssid = ssid;
-	data->user_data = user_data;
+	data->service = p2p_service_params;
 
-	if (ssid->use_wps) {
-		g_free(interface->wps_cred.key);
-		memset(&interface->wps_cred, 0,
-				sizeof(struct _GSupplicantWpsCredentials));
+	ret = supplicant_dbus_method_call(interface->path,
+		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeleteService",
+		interface_p2p_delete_service_params, interface_p2p_service_result,
+		data, interface);
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
 
-		ret = supplicant_dbus_property_set(interface->path,
-			SUPPLICANT_INTERFACE ".Interface.WPS",
-			"ProcessCredentials", DBUS_TYPE_BOOLEAN_AS_STRING,
-			wps_process_credentials, wps_start, data, interface);
-	} else {
-		/* By the time there is a request for connect and the network
-		 * path is not NULL it means that connman has not removed the
-		 * previous network pointer. This can happen in the case AP
-		 * deauthenticated client and connman does not remove the
-		 * previously connected network pointer. This causes supplicant
-		 * to reallocate the memory for struct wpa_ssid again even if it
-		 * is the same SSID. This causes memory usage of wpa_supplicnat
-		 * to go high. The idea here is that if the previously connected
-		 * network is not removed at the time of next connection attempt
-		 * check if the network path is not NULL. In case it is non-NULL
-		 * first remove the network and then once removal is successful, add
-		 * the network.
-		 */
+	return -EINPROGRESS;
+}
 
-		if (interface->network_path != NULL) {
-			g_free(data->path);
-			dbus_free(data);
+struct interface_p2p_group_add_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PGroupAddParams *p2p_group_add_params;
+	void *user_data;
+};
 
-			/*
-			 * If this add network is for the same network for
-			 * which wpa_supplicant already has a profile then do
-			 * not need to add another profile. Only if the
-			 * profile that needs to get added is different from
-			 * what is there in wpa_s delete the current one. A
-			 * network is identified by its SSID, security_type
-			 * and passphrase (private passphrase in case security
-			 * type is 802.11x).
-			 */
-			if (compare_network_parameters(interface, ssid)) {
-				return -EALREADY;
-			}
+static void interface_p2p_group_add_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	struct interface_p2p_group_add_data *data = user_data;
 
-			intf_data = dbus_malloc0(sizeof(*intf_data));
-			if (!intf_data)
-				return -ENOMEM;
+	supplicant_dbus_dict_open(iter, &dict);
 
-			intf_data->interface = interface;
-			intf_data->path = g_strdup(interface->path);
-			intf_data->callback = callback;
-			intf_data->ssid = ssid;
-			intf_data->user_data = user_data;
-			intf_data->network_remove_in_progress = TRUE;
-			network_remove(intf_data);
-		} else {
-			ret = supplicant_dbus_method_call(interface->path,
-					SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
-					interface_add_network_params,
-					interface_add_network_result, data,
-					interface);
+
+	if (data && data->p2p_group_add_params) {
+		GSupplicantP2PGroupAddParams* params = data->p2p_group_add_params;
+
+		if(params->persistent == TRUE) {
+			supplicant_dbus_dict_append_basic(&dict, "persistent",
+												DBUS_TYPE_BOOLEAN, &params->persistent);
 		}
-        }
 
-	if (ret < 0) {
-		g_free(data->path);
-		dbus_free(data);
-		return ret;
+		if(params->persistent_group_object != NULL)	{
+			supplicant_dbus_dict_append_basic(&dict, "persistent_group_object",
+												DBUS_TYPE_OBJECT_PATH, &params->persistent_group_object);
+		}
+
+		if(params->frequency >= 0) {
+			supplicant_dbus_dict_append_basic(&dict, "frequency",
+												DBUS_TYPE_INT32, &params->frequency);
+		}
 	}
 
-	return -EINPROGRESS;
+	supplicant_dbus_dict_close(iter, &dict);
 }
 
-static void interface_wps_cancel_result(const char *error,
-		DBusMessageIter *iter, void *user_data)
+static void interface_p2p_group_add_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
 {
-	struct interface_data *data = user_data;
+	struct interface_p2p_group_add_data *data = user_data;
 	int err = 0;
 
-	SUPPLICANT_DBG("");
-
 	if (error != NULL) {
-		SUPPLICANT_DBG("error: %s", error);
-		err = parse_supplicant_error(iter);
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
 	}
 
 	if (data->callback != NULL)
@@ -5356,18 +9245,19 @@ static void interface_wps_cancel_result(const char *error,
 	dbus_free(data);
 }
 
-int g_supplicant_interface_wps_cancel(GSupplicantInterface *interface,
-		GSupplicantInterfaceCallback callback,
-			void *user_data)
+int g_supplicant_interface_p2p_group_add(GSupplicantInterface *interface,
+				GSupplicantP2PGroupAddParams *group_data,
+				GSupplicantInterfaceCallback callback,
+							void *user_data)
 {
-	struct interface_data *data;
+	struct interface_p2p_group_add_data *data;
 	int ret;
 
-	if (interface == NULL)
+	if (!interface)
 		return -EINVAL;
 
-	if (system_available == FALSE)
-		return -EFAULT;
+	if (!interface->p2p_support)
+		return -ENOTSUP;
 
 	data = dbus_malloc0(sizeof(*data));
 	if (data == NULL)
@@ -5376,327 +9266,388 @@ int g_supplicant_interface_wps_cancel(GSupplicantInterface *interface,
 	data->interface = interface;
 	data->callback = callback;
 	data->user_data = user_data;
+	data->p2p_group_add_params = group_data;
 
 	ret = supplicant_dbus_method_call(interface->path,
-		SUPPLICANT_INTERFACE ".Interface.WPS", "Cancel",
-		NULL,
-		interface_wps_cancel_result, data, interface);
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+					"GroupAdd",
+					interface_p2p_group_add_params, interface_p2p_group_add_result,
+					data, NULL);
 
-	if (ret < 0) {
-		g_free(data);
-		return ret;
-	}
+	if (ret < 0)
+		dbus_free(data);
 
-	return -EINPROGRESS;
+	return ret;
 }
 
-static void network_remove_result(const char *error,
+struct interface_p2p_wps_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantP2PWPSParams *p2p_wps_params;
+	void *user_data;
+};
+
+static void interface_p2p_wps_start_result(const char *error,
 				DBusMessageIter *iter, void *user_data)
 {
-	struct interface_data *data = user_data;
-	struct interface_connect_data *connect_data;
-	int result = 0;
+	struct interface_wps_connect_data *data = user_data;
+	int err;
 
 	SUPPLICANT_DBG("");
 
-	if (error) {
-		result = -EIO;
+	err = 0;
+	if (error != NULL) {
 		SUPPLICANT_DBG("error: %s", error);
-
-		if (g_strcmp0("org.freedesktop.DBus.Error.UnknownMethod",
-						error) == 0)
-			result = -ECONNABORTED;
+		err = parse_supplicant_error(iter);
 	}
 
-	g_free(data->interface->network_path);
-	data->interface->network_path = NULL;
-
-	remove_network_information(data->interface);
-
-	if (data->network_remove_in_progress == TRUE) {
-		data->network_remove_in_progress = FALSE;
-		connect_data = dbus_malloc0(sizeof(*connect_data));
-		if (!connect_data)
-			return;
-
-		connect_data->interface = data->interface;
-		connect_data->path = g_strdup(data->path);
-		connect_data->callback = data->callback;
-		connect_data->ssid = data->ssid;
-		connect_data->user_data = data->user_data;
-
-		supplicant_dbus_method_call(data->interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
-			interface_add_network_params,
-			interface_add_network_result, connect_data,
-			connect_data->interface);
-	} else {
-		if (data->callback)
-			data->callback(result, data->interface, data->user_data);
+	if (error != NULL) {
+		if (data->callback != NULL)
+			data->callback(err, data->interface, data->user_data);
 	}
-	g_free(data->path);
+
+	g_free(data->ssid);
 	dbus_free(data);
 }
 
-static void network_remove_params(DBusMessageIter *iter, void *user_data)
+static void interface_p2p_wps_start(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_data *data = user_data;
-	const char *path = data->interface->network_path;
+	struct interface_p2p_wps_data *data = user_data;
+	GSupplicantP2PWPSParams *params = data->p2p_wps_params;
+
+	DBusMessageIter dict;
 
-	SUPPLICANT_DBG("path %s", path);
+	supplicant_dbus_dict_open(iter, &dict);
 
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
-}
+	supplicant_dbus_dict_append_basic(&dict, "Role",
+											DBUS_TYPE_STRING, &params->role);
 
-static int network_remove(struct interface_data *data)
-{
-	GSupplicantInterface *interface = data->interface;
+	supplicant_dbus_dict_append_basic(&dict, "Type",
+											DBUS_TYPE_STRING, &params->type);
 
-	SUPPLICANT_DBG("");
+	if (params->pin != NULL) {
+		supplicant_dbus_dict_append_basic(&dict, "Pin",
+												DBUS_TYPE_STRING, &params->pin);
+	}
 
-	return supplicant_dbus_method_call(interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "RemoveNetwork",
-			network_remove_params, network_remove_result, data,
-			interface);
+	if(params->p2p_dev_addr != NULL) {
+		unsigned char *dev_addr = g_try_malloc(6);
+		string_to_byte(params->p2p_dev_addr, dev_addr);
+		supplicant_dbus_dict_append_fixed_array(&dict, "P2PDeviceAddress", DBUS_TYPE_BYTE, &dev_addr, 6);
+		g_free(dev_addr);
+	}
+
+	supplicant_dbus_dict_close(iter, &dict);
 }
 
-static void interface_disconnect_result(const char *error,
-				DBusMessageIter *iter, void *user_data)
+
+int g_supplicant_interface_p2p_wps_start(GSupplicantInterface *interface,
+													GSupplicantP2PWPSParams *wps_data,
+													GSupplicantInterfaceCallback callback,
+													void *user_data)
 {
-	struct interface_data *data = user_data;
-	int result = 0;
+	struct interface_p2p_wps_data *data;
+	int ret;
 
-	SUPPLICANT_DBG("");
+	if (interface == NULL)
+		return -EINVAL;
 
-	if (error) {
-		result = -EIO;
-		SUPPLICANT_DBG("error: %s", error);
+	if (system_available == FALSE)
+		return -EFAULT;
 
-		if (g_strcmp0("org.freedesktop.DBus.Error.UnknownMethod",
-						error) == 0)
-			result = -ECONNABORTED;
-	}
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
 
-	/* If we are disconnecting from previous WPS successful
-	 * association. i.e.: it did not went through AddNetwork,
-	 * and interface->network_path was never set. */
-	if (!data->interface->network_path) {
-		if (data->callback)
-			data->callback(result, data->interface,
-							data->user_data);
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+	data->p2p_wps_params = wps_data;
 
-		g_free(data->path);
-		dbus_free(data);
-		return;
-	}
+	SUPPLICANT_DBG("interface->path : %s\n", interface->path);
 
-	if (result < 0 && data->callback) {
-		data->callback(result, data->interface, data->user_data);
-		data->callback = NULL;
-	}
+	ret = supplicant_dbus_method_call(interface->path,
+										SUPPLICANT_INTERFACE ".Interface.WPS", "Start",
+										interface_p2p_wps_start, interface_p2p_wps_start_result, data, NULL);
 
-	if (result != -ECONNABORTED) {
-		if (network_remove(data) < 0) {
-			g_free(data->path);
-			dbus_free(data);
-		}
-	} else {
-		g_free(data->path);
+	if (ret < 0) {
 		dbus_free(data);
+		return ret;
 	}
+
+	return -EINPROGRESS;
 }
 
-int g_supplicant_interface_disconnect(GSupplicantInterface *interface,
-					GSupplicantInterfaceCallback callback,
-							void *user_data)
+struct interface_p2p_persistent_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantSSID *ssid;
+	void *user_data;
+};
+
+static void interface_p2p_remove_persistent_group_params(DBusMessageIter *iter, void *user_data)
 {
-	struct interface_data *data;
-	int ret;
+	struct interface_p2p_persistent_data *data = user_data;
+	const char *path = data->user_data;
 
-	SUPPLICANT_DBG("");
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
+}
 
-	if (!interface)
+int g_supplicant_interface_p2p_remove_persistent_group(GSupplicantInterface *interface,
+																		void *user_data)
+{
+	struct interface_p2p_persistent_data *data;
+	int ret;
+
+	if (interface == NULL)
 		return -EINVAL;
 
-	if (!system_available)
+	if (system_available == FALSE)
 		return -EFAULT;
 
 	data = dbus_malloc0(sizeof(*data));
-	if (!data)
+	if (data == NULL)
 		return -ENOMEM;
 
 	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->callback = callback;
 	data->user_data = user_data;
 
 	ret = supplicant_dbus_method_call(interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "Disconnect",
-			NULL, interface_disconnect_result, data,
-			interface);
-
+										SUPPLICANT_INTERFACE ".Interface.P2PDevice", "RemovePersistentGroup",
+										interface_p2p_remove_persistent_group_params,
+										NULL, data, NULL);
 	if (ret < 0) {
-		g_free(data->path);
 		dbus_free(data);
+		return ret;
 	}
 
-	return ret;
+	return -EINPROGRESS;
 }
 
-static void interface_p2p_find_result(const char *error,
-					DBusMessageIter *iter, void *user_data)
+static void remove_quote(char *str)
 {
-	struct interface_scan_data *data = user_data;
-	int err = 0;
+	int len = strlen(str);
+	int i=0;
 
-	SUPPLICANT_DBG("error %s", error);
+	for(i=0; i<len-2; i++) {
+		str[i] = str[i+1];
+	}
+	str[len-2] = '\0';
+}
 
-	if (error)
-		err = -EIO;
+int g_supplicant_interface_p2p_remove_all_persistent_groups(GSupplicantInterface *interface)
+{
+	int ret;
 
-	if (interface_exists(data->interface, data->path)) {
-		if (!data->interface->ready)
-			err = -ENOLINK;
-		if (!err)
-			data->interface->p2p_finding = true;
+	if (interface == NULL)
+		return -EINVAL;
+
+	SUPPLICANT_DBG("interface path : %s", interface->path);
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	ret = supplicant_dbus_method_call(interface->path,
+						SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+						"RemoveAllPersistentGroups",
+						NULL, NULL, NULL, NULL);
+	if (ret < 0) {
+		return ret;
 	}
 
-	if (data->callback)
+	return -EINPROGRESS;
+}
+
+static void interface_p2p_add_persistent_group_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_group_add_data *data = user_data;
+	int err = 0;
+
+	if (error != NULL) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback != NULL)
 		data->callback(err, data->interface, data->user_data);
 
-	g_free(data->path);
 	dbus_free(data);
 }
 
-static void interface_p2p_find_params(DBusMessageIter *iter, void *user_data)
+static void interface_p2p_add_persistent_group_params(DBusMessageIter *iter, void *user_data)
 {
 	DBusMessageIter dict;
+	struct interface_p2p_persistent_data *data = user_data;
+	GSupplicantSSID *ssid = data->ssid;
+	dbus_uint32_t disabled=2;
+	const char *auth_alg = "OPEN";
 
 	supplicant_dbus_dict_open(iter, &dict);
+
+	supplicant_dbus_dict_append_basic(&dict, "mode", DBUS_TYPE_UINT32, &ssid->mode);
+
+	supplicant_dbus_dict_append_basic(&dict, "disabled", DBUS_TYPE_UINT32, &disabled);
+
+	supplicant_dbus_dict_append_basic(&dict, "auth_alg", DBUS_TYPE_STRING, &auth_alg);
+
+	supplicant_dbus_dict_append_basic(&dict, "bssid", DBUS_TYPE_STRING, &ssid->bssid);
+
+	supplicant_dbus_dict_append_fixed_array(&dict, "ssid",
+						DBUS_TYPE_BYTE, &ssid->ssid, ssid->ssid_len);
+
+	if(ssid->passphrase != NULL && ssid->passphrase[0] == '\"') {
+		char *passphrase = g_strdup(ssid->passphrase);
+		remove_quote(passphrase);
+		g_free(ssid->passphrase);
+		ssid->passphrase = passphrase;
+	}
+
+	add_network_security(&dict, ssid);
+
 	supplicant_dbus_dict_close(iter, &dict);
 }
 
-int g_supplicant_interface_p2p_find(GSupplicantInterface *interface,
-					GSupplicantInterfaceCallback callback,
-							void *user_data)
+int g_supplicant_interface_p2p_add_persistent_group(GSupplicantInterface *interface,
+							GSupplicantSSID *ssid, void *user_data)
 {
-	struct interface_scan_data *data;
+	struct interface_p2p_persistent_data *data;
 	int ret;
 
-	if (!interface->p2p_support)
-		return -ENOTSUP;
+	if (interface == NULL)
+		return -EINVAL;
 
-	ret = interface_ready_to_scan(interface);
-	if (ret && ret != -EALREADY)
-		return ret;
+	if (system_available == FALSE)
+		return -EFAULT;
 
 	data = dbus_malloc0(sizeof(*data));
-	if (!data)
+	if (data == NULL)
 		return -ENOMEM;
 
 	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->callback = callback;
+	data->ssid = ssid;
 	data->user_data = user_data;
+	data->callback = NULL;
 
 	ret = supplicant_dbus_method_call(interface->path,
-			SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Find",
-			interface_p2p_find_params, interface_p2p_find_result,
-			data, interface);
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice", "AddPersistentGroup",
+					interface_p2p_add_persistent_group_params,
+					interface_p2p_add_persistent_group_result, data, NULL);
 	if (ret < 0) {
-		g_free(data->path);
 		dbus_free(data);
+		return ret;
 	}
 
-	return ret;
-}
-
-bool g_supplicant_interface_is_p2p_finding(GSupplicantInterface *interface)
-{
-	if (!interface)
-		return false;
-
-	return interface->p2p_finding;
+	return -EINPROGRESS;
 }
 
-int g_supplicant_interface_p2p_stop_find(GSupplicantInterface *interface)
+static void interface_p2p_persistent_group_add_params(DBusMessageIter *iter,
+							void *user_data)
 {
-	if (!interface->p2p_finding)
-		return 0;
+	DBusMessageIter dict;
+	struct interface_connect_data *data = user_data;
+	GSupplicantInterface *interface = data->interface;
 
-	SUPPLICANT_DBG("");
+	supplicant_dbus_dict_open(iter, &dict);
 
-	interface->p2p_finding = false;
+	supplicant_dbus_dict_append_basic(&dict, "persistent_group_object",
+						DBUS_TYPE_OBJECT_PATH, &interface->network_path);
 
-	return supplicant_dbus_method_call(interface->path,
-		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "StopFind",
-		NULL, NULL, NULL, NULL);
+	supplicant_dbus_dict_close(iter, &dict);
 }
 
-static void interface_p2p_connect_result(const char *error,
-					DBusMessageIter *iter, void *user_data)
+static void interface_p2p_persistent_group_add_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
 {
 	struct interface_connect_data *data = user_data;
-	int err = 0;
-
-	SUPPLICANT_DBG("");
+	int err;
 
+	err = 0;
 	if (error) {
-		SUPPLICANT_DBG("error: %s", error);
+		SUPPLICANT_DBG("Group add error %s", error);
 		err = parse_supplicant_error(iter);
 	}
 
 	if (data->callback)
 		data->callback(err, data->interface, data->user_data);
 
-	g_free(data->path);
-	g_free(data->peer->wps_pin);
-	g_free(data->peer->path);
-	g_free(data->peer);
-	g_free(data);
+	dbus_free(data);
 }
 
-static void interface_p2p_connect_params(DBusMessageIter *iter, void *user_data)
+static void interface_p2p_persistent_group_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
 {
 	struct interface_connect_data *data = user_data;
-	const char *wps = "pbc";
-	DBusMessageIter dict;
-	int go_intent = 7;
+	GSupplicantInterface *interface = data->interface;
+	const char *path = NULL;
+	int err;
 
-	SUPPLICANT_DBG("");
+	if (error)
+		goto error;
 
-	supplicant_dbus_dict_open(iter, &dict);
+	dbus_message_iter_get_basic(iter, &path);
+	if (!path)
+		goto error;
 
-	if (data->peer->master)
-		go_intent = 15;
+	g_free(interface->network_path);
+	interface->network_path = g_strdup(path);
 
-	if (data->peer->wps_pin)
-		wps = "pin";
+	SUPPLICANT_DBG("data->interface->path : %s\n", data->interface->path);
 
-	supplicant_dbus_dict_append_basic(&dict, "peer",
-				DBUS_TYPE_OBJECT_PATH, &data->peer->path);
-	supplicant_dbus_dict_append_basic(&dict, "wps_method",
-				DBUS_TYPE_STRING, &wps);
-	if (data->peer->wps_pin) {
-		supplicant_dbus_dict_append_basic(&dict, "pin",
-				DBUS_TYPE_STRING, &data->peer->wps_pin);
-	}
+	supplicant_dbus_method_call(data->interface->path,
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+					"GroupAdd",
+					interface_p2p_persistent_group_add_params,
+					interface_p2p_persistent_group_add_result,
+					data, NULL);
+	return;
+
+	error:
+		SUPPLICANT_DBG("GroupAdd error %s", error);
+		err = parse_supplicant_error(iter);
+		if (data->callback)
+			data->callback(err, data->interface, data->user_data);
+
+		g_free(interface->network_path);
+		interface->network_path = NULL;
+		g_free(data);
+}
+
+static void interface_p2p_persistent_group_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	struct interface_connect_data *data = user_data;
+	GSupplicantSSID *ssid = data->ssid;
+	dbus_uint32_t mode = 3;
+	dbus_uint32_t disabled = 2;
 
-	supplicant_dbus_dict_append_basic(&dict, "go_intent",
-					DBUS_TYPE_INT32, &go_intent);
+	supplicant_dbus_dict_open(iter, &dict);
+
+	supplicant_dbus_dict_append_basic(&dict, "mode", DBUS_TYPE_UINT32, &mode);
+	supplicant_dbus_dict_append_basic(&dict, "disabled",
+						DBUS_TYPE_UINT32, &disabled);
+
+	add_network_security(&dict, ssid);
+
+	//The data structure is set up as a byte buffer, however
+	//SSID->SSID is created by ssid_ap_init - it is a null terminated string.
+	supplicant_dbus_dict_append_basic(&dict, "ssid",
+					DBUS_TYPE_STRING,
+					&(ssid->ssid));
 
 	supplicant_dbus_dict_close(iter, &dict);
 }
 
-int g_supplicant_interface_p2p_connect(GSupplicantInterface *interface,
-					GSupplicantPeerParams *peer_params,
-					GSupplicantInterfaceCallback callback,
-					void *user_data)
+int g_supplicant_interface_p2p_persistent_group_add(GSupplicantInterface *interface,
+				GSupplicantSSID *ssid,
+				GSupplicantInterfaceCallback callback,
+							void *user_data)
 {
 	struct interface_connect_data *data;
 	int ret;
 
-	SUPPLICANT_DBG("");
+	if (!interface)
+		return -EINVAL;
 
 	if (!interface->p2p_support)
 		return -ENOTSUP;
@@ -5706,17 +9657,18 @@ int g_supplicant_interface_p2p_connect(GSupplicantInterface *interface,
 		return -ENOMEM;
 
 	data->interface = interface;
-	data->path = g_strdup(interface->path);
-	data->peer = peer_params;
 	data->callback = callback;
+	data->ssid = ssid;
 	data->user_data = user_data;
 
 	ret = supplicant_dbus_method_call(interface->path,
-		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "Connect",
-		interface_p2p_connect_params, interface_p2p_connect_result,
-		data, interface);
+					SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+					"AddPersistentGroup",
+					interface_p2p_persistent_group_params,
+					interface_p2p_persistent_group_result,
+					data, NULL);
+
 	if (ret < 0) {
-		g_free(data->path);
 		dbus_free(data);
 		return ret;
 	}
@@ -5724,144 +9676,160 @@ int g_supplicant_interface_p2p_connect(GSupplicantInterface *interface,
 	return -EINPROGRESS;
 }
 
-int g_supplicant_interface_p2p_disconnect(GSupplicantInterface *interface,
-					GSupplicantPeerParams *peer_params)
+int g_supplicant_interface_p2p_replace_service(GSupplicantInterface *interface,
+				GSupplicantInterfaceCallback callback,
+				GSupplicantP2PServiceParams *p2p_service_params,
+				void *user_data)
 {
-	GSupplicantPeer *peer;
-	int count = 0;
-	GSList *list;
+      struct p2p_service_data *data;
+	int ret;
 
 	SUPPLICANT_DBG("");
 
 	if (!interface->p2p_support)
 		return -ENOTSUP;
 
-	peer = g_hash_table_lookup(interface->peer_table, peer_params->path);
-	if (!peer)
-		return -ENODEV;
-
-	for (list = peer->groups; list; list = list->next, count++) {
-		const char *group_obj_path = list->data;
-		GSupplicantInterface *g_interface;
-		GSupplicantGroup *group;
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
 
-		group = g_hash_table_lookup(group_mapping, group_obj_path);
-		if (!group || !group->interface)
-			continue;
+	data->registration = true;
+	data->interface = interface;
+	data->service = p2p_service_params;
+	data->callback = callback;
+	data->user_data = user_data;
 
-		g_interface = group->interface;
-		supplicant_dbus_method_call(g_interface->path,
-				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
-				"Disconnect", NULL, NULL, NULL, g_interface);
-	}
+	ret = supplicant_dbus_method_call(interface->path,
+										SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ReplaceService",
+										interface_p2p_service_params, interface_p2p_service_result,
+		                                                   data, interface);
 
-	if (count == 0 && peer->current_group_iface) {
-		supplicant_dbus_method_call(peer->current_group_iface->path,
-				SUPPLICANT_INTERFACE ".Interface.P2PDevice",
-				"Disconnect", NULL, NULL, NULL,
-				peer->current_group_iface->path);
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
 	}
 
-	peer->current_group_iface = NULL;
-
 	return -EINPROGRESS;
 }
 
-struct p2p_service_data {
-	bool registration;
+struct interface_p2p_asp_provision_data {
 	GSupplicantInterface *interface;
-	GSupplicantP2PServiceParams *service;
 	GSupplicantInterfaceCallback callback;
+	void *params; //Either request or response params
 	void *user_data;
 };
 
-static void interface_p2p_service_result(const char *error,
-					DBusMessageIter *iter, void *user_data)
+static void interface_p2p_asp_provision_result(const char *error,
+											 DBusMessageIter *iter, void *user_data)
 {
-	struct p2p_service_data *data = user_data;
-	int result = 0;
+	struct interface_p2p_asp_provision_data *data = user_data;
+	int err = 0;
 
-	SUPPLICANT_DBG("%s result - %s", data->registration ?
-				"Registration" : "Deletion",
-				error ? error : "Success");
-	if (error)
-		result = -EINVAL;
+	if (error != NULL) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
 
-	if (data->callback)
-		data->callback(result, data->interface, data->user_data);
+	if (data->callback != NULL)
+		data->callback(err, data->interface, data->user_data);
 
-	g_free(data->service->query);
-	g_free(data->service->response);
-	g_free(data->service->service);
-	g_free(data->service->wfd_ies);
-	g_free(data->service);
 	dbus_free(data);
 }
 
-static void interface_p2p_service_params(DBusMessageIter *iter,
-							void *user_data)
+static void interface_p2p_asp_provision_request_params(DBusMessageIter *iter, void *user_data)
 {
-	struct p2p_service_data *data = user_data;
-	GSupplicantP2PServiceParams *service;
 	DBusMessageIter dict;
-	const char *type;
+	struct interface_p2p_asp_provision_data *data = user_data;
+	GSupplicantP2PASPProvisionRequestParams* params = data->params;
 
-	SUPPLICANT_DBG("");
+	supplicant_dbus_dict_open(iter, &dict);
 
-	service = data->service;
+	if(params->peer)
+		supplicant_dbus_dict_append_basic(&dict, "peer",
+										  DBUS_TYPE_OBJECT_PATH, &params->peer);
+	if(params->config_method)
+		supplicant_dbus_dict_append_basic(&dict, "config_method",
+										  DBUS_TYPE_UINT16, &params->config_method);
+	if(params->advertisement_id)
+		supplicant_dbus_dict_append_basic(&dict, "adv_id",
+										  DBUS_TYPE_UINT32, &params->advertisement_id);
+	if(params->service_mac)
+		supplicant_dbus_dict_append_basic(&dict, "adv_mac",
+										  DBUS_TYPE_STRING, &params->service_mac);
+	if(params->role)
+		supplicant_dbus_dict_append_basic(&dict, "role",
+										  DBUS_TYPE_BYTE, &params->role);
+	if(params->session_id)
+		supplicant_dbus_dict_append_basic(&dict, "session_id",
+										  DBUS_TYPE_UINT32, &params->session_id);
+	if(params->session_mac)
+		supplicant_dbus_dict_append_basic(&dict, "session_mac",
+										  DBUS_TYPE_STRING, &params->session_mac);
+	if(params->service_info)
+		supplicant_dbus_dict_append_basic(&dict, "service_info",
+										  DBUS_TYPE_STRING, &params->service_info);
+
+	supplicant_dbus_dict_close(iter, &dict);
+}
+
+static void interface_p2p_asp_provision_response_params(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+	struct interface_p2p_asp_provision_data *data = user_data;
+	GSupplicantP2PASPProvisionResponseParams* params = data->params;
 
 	supplicant_dbus_dict_open(iter, &dict);
 
-	if (service->query && service->response) {
-		type = "bonjour";
-		supplicant_dbus_dict_append_basic(&dict, "service_type",
-						DBUS_TYPE_STRING, &type);
-		supplicant_dbus_dict_append_fixed_array(&dict, "query",
-					DBUS_TYPE_BYTE, &service->query,
-					service->query_length);
-		supplicant_dbus_dict_append_fixed_array(&dict, "response",
-					DBUS_TYPE_BYTE, &service->response,
-					service->response_length);
-	} else if (service->version && service->service) {
-		type = "upnp";
-		supplicant_dbus_dict_append_basic(&dict, "service_type",
-						DBUS_TYPE_STRING, &type);
-		supplicant_dbus_dict_append_basic(&dict, "version",
-					DBUS_TYPE_INT32, &service->version);
-		supplicant_dbus_dict_append_basic(&dict, "service",
-					DBUS_TYPE_STRING, &service->service);
-	}
+	if(params->peer)
+		supplicant_dbus_dict_append_basic(&dict, "peer",
+										  DBUS_TYPE_OBJECT_PATH, &params->peer);
+	if(params->advertisement_id)
+		supplicant_dbus_dict_append_basic(&dict, "adv_id",
+										  DBUS_TYPE_UINT32, &params->advertisement_id);
+	if(params->service_mac)
+		supplicant_dbus_dict_append_basic(&dict, "adv_mac",
+										  DBUS_TYPE_STRING, &params->service_mac);
+	supplicant_dbus_dict_append_basic(&dict, "status",
+	                                  DBUS_TYPE_INT32, &params->status);
+	supplicant_dbus_dict_append_basic(&dict, "role",
+										  DBUS_TYPE_BYTE, &params->role);
+	if(params->session_id)
+		supplicant_dbus_dict_append_basic(&dict, "session_id",
+										  DBUS_TYPE_UINT32, &params->session_id);
+	if(params->session_mac)
+		supplicant_dbus_dict_append_basic(&dict, "session_mac",
+										  DBUS_TYPE_STRING, &params->session_mac);
 
 	supplicant_dbus_dict_close(iter, &dict);
 }
 
-int g_supplicant_interface_p2p_add_service(GSupplicantInterface *interface,
-				GSupplicantInterfaceCallback callback,
-				GSupplicantP2PServiceParams *p2p_service_params,
-				void *user_data)
+int g_supplicant_interface_p2p_asp_provision_request(GSupplicantInterface *interface,
+													 GSupplicantP2PASPProvisionRequestParams *params,
+													 GSupplicantInterfaceCallback callback,
+													 void *user_data)
 {
-	struct p2p_service_data *data;
+	struct interface_p2p_asp_provision_data *data;
 	int ret;
 
-	SUPPLICANT_DBG("");
+	if (interface == NULL)
+		return -EINVAL;
 
-	if (!interface->p2p_support)
-		return -ENOTSUP;
+	if (system_available == FALSE)
+		return -EFAULT;
 
 	data = dbus_malloc0(sizeof(*data));
-	if (!data)
+	if (data == NULL)
 		return -ENOMEM;
 
-	data->registration = true;
 	data->interface = interface;
-	data->service = p2p_service_params;
+	data->params = params;
 	data->callback = callback;
 	data->user_data = user_data;
 
 	ret = supplicant_dbus_method_call(interface->path,
-		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "AddService",
-		interface_p2p_service_params, interface_p2p_service_result,
-		data, interface);
+									  SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ASPProvisionRequest",
+									  interface_p2p_asp_provision_request_params, interface_p2p_asp_provision_result, data, NULL);
+
 	if (ret < 0) {
 		dbus_free(data);
 		return ret;
@@ -5870,28 +9838,33 @@ int g_supplicant_interface_p2p_add_service(GSupplicantInterface *interface,
 	return -EINPROGRESS;
 }
 
-int g_supplicant_interface_p2p_del_service(GSupplicantInterface *interface,
-				GSupplicantP2PServiceParams *p2p_service_params)
+int g_supplicant_interface_p2p_asp_provision_response(GSupplicantInterface *interface,
+                                                      GSupplicantP2PASPProvisionResponseParams *params,
+													 GSupplicantInterfaceCallback callback,
+													 void *user_data)
 {
-	struct p2p_service_data *data;
+	struct interface_p2p_asp_provision_data *data;
 	int ret;
 
-	SUPPLICANT_DBG("");
+	if (interface == NULL)
+		return -EINVAL;
 
-	if (!interface->p2p_support)
-		return -ENOTSUP;
+	if (system_available == FALSE)
+		return -EFAULT;
 
 	data = dbus_malloc0(sizeof(*data));
-	if (!data)
+	if (data == NULL)
 		return -ENOMEM;
 
 	data->interface = interface;
-	data->service = p2p_service_params;
+	data->params = params;
+	data->callback = callback;
+	data->user_data = user_data;
 
 	ret = supplicant_dbus_method_call(interface->path,
-		SUPPLICANT_INTERFACE ".Interface.P2PDevice", "DeleteService",
-		interface_p2p_service_params, interface_p2p_service_result,
-		data, interface);
+									  SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ASPProvisionResponse",
+									  interface_p2p_asp_provision_response_params, interface_p2p_asp_provision_result, data, NULL);
+
 	if (ret < 0) {
 		dbus_free(data);
 		return ret;
@@ -5900,42 +9873,147 @@ int g_supplicant_interface_p2p_del_service(GSupplicantInterface *interface,
 	return -EINPROGRESS;
 }
 
-struct p2p_listen_data {
+static void p2p_dev_address_update_cb(const char *key,
+                                  DBusMessageIter *iter, void *user_data)
+{
+	struct interface_data *data = user_data;
+	int err = 0;
+	unsigned char *mac_bin;
+	int mac_bin_len = 0;
+	DBusMessageIter array;
+
+	if (iter == NULL)
+		return;
+
+	dbus_message_iter_recurse(iter, &array);
+	dbus_message_iter_get_fixed_array(&array, &mac_bin, &mac_bin_len);
+
+	if (mac_bin_len == 6) {
+		memcpy(data->interface->p2p_device_address, mac_bin, mac_bin_len);
+		err = 0;
+	}
+	else {
+		err = -1;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	g_free(data);
+}
+
+int g_supplicant_interface_p2p_read_device_address(GSupplicantInterface *interface,
+                                                   GSupplicantInterfaceCallback callback, void *user_data)
+{
+	struct interface_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EINVAL;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_property_get(interface->path,
+	                                    SUPPLICANT_INTERFACE ".Interface.P2PDevice",
+	                                    "DeviceAddress",
+	                                    p2p_dev_address_update_cb, data, NULL);
+
+	if (ret < 0)
+		dbus_free(data);
+
+	return ret;
+}
+
+const unsigned char *g_supplicant_interface_p2p_get_device_address(GSupplicantInterface *interface)
+{
+	return interface->p2p_device_address;
+}
+
+struct interface_p2p_listen_data {
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
 	int period;
 	int interval;
 };
 
 static void interface_p2p_listen_params(DBusMessageIter *iter, void *user_data)
 {
-	struct p2p_listen_data *params = user_data;
+	struct interface_p2p_listen_data *data = user_data;
 	DBusMessageIter dict;
 
 	supplicant_dbus_dict_open(iter, &dict);
 
 	supplicant_dbus_dict_append_basic(&dict, "period",
-					DBUS_TYPE_INT32, &params->period);
+					DBUS_TYPE_INT32, &data->period);
 	supplicant_dbus_dict_append_basic(&dict, "interval",
-					DBUS_TYPE_INT32, &params->interval);
+					DBUS_TYPE_INT32, &data->interval);
 	supplicant_dbus_dict_close(iter, &dict);
 }
 
+static void interface_p2p_listen_result(const char *error,
+				DBusMessageIter *iter, void *user_data)
+{
+	struct interface_p2p_listen_data *data = user_data;
+	int err = 0;
+
+	SUPPLICANT_DBG("");
+
+	if (error) {
+		SUPPLICANT_DBG("error %s", error);
+		err = -EIO;
+	}
+
+	if (data->callback)
+		data->callback(err, data->interface, data->user_data);
+
+	dbus_free(data);
+}
+
 int g_supplicant_interface_p2p_listen(GSupplicantInterface *interface,
-						int period, int interval)
+						int period, int interval, GSupplicantInterfaceCallback callback,
+						void *user_data)
 {
-	struct p2p_listen_data params;
+	struct interface_p2p_listen_data *data;
+	int ret=0;
 
 	SUPPLICANT_DBG("");
 
+	if (!interface)
+		return -EINVAL;
+
+	if (!system_available)
+		return -EFAULT;
+
 	if (!interface->p2p_support)
 		return -ENOTSUP;
 
-	params.period = period;
-	params.interval = interval;
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
 
-	return supplicant_dbus_method_call(interface->path,
+	data->interface = interface;
+	data->callback = callback;
+	data->period = period;
+	data->interval = interval;
+	data->user_data = user_data;
+
+	ret=supplicant_dbus_method_call(interface->path,
 			SUPPLICANT_INTERFACE ".Interface.P2PDevice",
 			"ExtendedListen", interface_p2p_listen_params,
-			NULL, &params, NULL);
+			interface_p2p_listen_result, data, NULL);
+	if(ret<0)
+		dbus_free(data);
+	return ret;
 }
 
 static void widi_ies_params(DBusMessageIter *iter, void *user_data)
@@ -6065,6 +10143,12 @@ int g_supplicant_register(const GSupplicantCallbacks *callbacks)
 								NULL, NULL);
 	config_file_table = g_hash_table_new_full(g_str_hash, g_str_equal,
 								g_free, g_free);
+	intf_addr_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, NULL);
+	dev_addr_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, g_free);
+	p2p_peer_table = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, NULL);
 
 	supplicant_dbus_setup(connection);
 
@@ -6168,6 +10252,15 @@ void g_supplicant_unregister(const GSupplicantCallbacks *callbacks)
 		connection = NULL;
 	}
 
+	if (intf_addr_mapping){
+		g_hash_table_destroy(intf_addr_mapping);
+		intf_addr_mapping = NULL;
+	}
+	if (p2p_peer_table != NULL){
+		g_hash_table_destroy(p2p_peer_table);
+		p2p_peer_table = NULL;
+	}
+
 	callbacks_pointer = NULL;
 	eap_methods = 0;
 }
diff --git a/include/dbus.h b/include/dbus.h
index bcab4189..13f8c700 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -45,6 +45,9 @@ extern "C" {
 #define CONNMAN_SESSION_INTERFACE	CONNMAN_SERVICE ".Session"
 #define CONNMAN_NOTIFICATION_INTERFACE	CONNMAN_SERVICE ".Notification"
 #define CONNMAN_PEER_INTERFACE		CONNMAN_SERVICE ".Peer"
+#define CONNMAN_SD_INTERFACE	CONNMAN_SERVICE ".ServiceDiscovery"
+#define CONNMAN_SD_PATH			"/"
+#define CONNMAN_GROUP_INTERFACE		CONNMAN_SERVICE ".Group"
 
 #define CONNMAN_PRIVILEGE_MODIFY	1
 #define CONNMAN_PRIVILEGE_SECRET	2
diff --git a/include/device.h b/include/device.h
index 082c1a3d..3b65365b 100644
--- a/include/device.h
+++ b/include/device.h
@@ -153,6 +153,8 @@ struct connman_device_driver {
 						const char *alpha2);
 	int (*start_wps) (struct connman_device *device, const char *pin);
 	int (*cancel_wps) (struct connman_device *device);
+	int (*cancel_p2p) (struct connman_device *device);
+	int (*get_driver_info) (struct connman_device *device);
 	int (*get_signal_info)(struct connman_device *device, connman_device_request_signal_info_cb cb, void *user_data);
 };
 
diff --git a/include/group.h b/include/group.h
new file mode 100644
index 00000000..6d092843
--- /dev/null
+++ b/include/group.h
@@ -0,0 +1,74 @@
+#ifndef __CONNMAN_GROUP_H
+#define __CONNMAN_GROUP_H
+
+#include <gsupplicant/gsupplicant.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct connman_group {
+	int refcount;
+	char *identifier;
+	char *path;
+	GSupplicantInterface *interface;
+	GSupplicantInterface *orig_interface;
+
+	char *name;
+	char *passphrase;
+	char *peer_ip;
+	bool is_group_owner;
+	bool is_persistent;
+	bool tethering;
+	bool autonomous;
+	int freq;
+	bool is_static_ip;
+
+	const char *group_owner;
+	GSList *peer_list;
+	GHashTable *peer_hash;
+	GHashTable *peer_intf;
+};
+
+#define connman_group_ref(group) \
+	connman_group_ref_debug(group, __FILE__, __LINE__, __func__)
+
+#define connman_group_unref(group) \
+	connman_group_unref_debug(group, __FILE__, __LINE__, __func__)
+
+#define P2P_WILDCARD_SSID "DIRECT-"
+#define P2P_WILDCARD_SSID_LEN 7
+#define P2P_MAX_SSID 32
+
+struct connman_group *__connman_group();
+const char* __connman_group_get_path(struct connman_group *group);
+const char* __connman_group_get_identifier(struct connman_group *group);
+const char* __connman_group_get_group_owner(struct connman_group *group);
+int  __connman_group_get_list_length(struct connman_group *group);
+bool __connman_group_is_autonomous(struct connman_group *group);
+
+int __connman_group_accept_connection(struct connman_group *group, GSupplicantP2PWPSParams *wps_params);
+
+bool __connman_group_exist(void);
+void __connman_group_peer_failed(struct connman_group *group);
+
+struct connman_group *__connman_group_lookup_from_ident(const char *identifier);
+
+void __connman_group_list_struct(DBusMessageIter *iter);
+
+struct connman_group* __connman_group_create(GSupplicantInterface *iface, const char *ifname, const char *ssid, const char *passphrase,
+														bool go, bool persistent, const char *go_path, bool autonomous, int freq);
+void __connman_group_remove(GSupplicantInterface *interface);
+void __connman_group_peer_joined(struct connman_group *group, const char *_peer_ident, char *intf_addr, const char *peer_path);
+bool __connman_group_peer_disconnected(struct connman_group *group, char *peer_ident);
+void __connman_group_client_dhcp_ip_assigned(struct connman_group *group);
+
+void __connman_group_init(void);
+void __connman_group_cleanup(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_GROUP_H */
diff --git a/include/network.h b/include/network.h
index ad764e64..8b4f56db 100644
--- a/include/network.h
+++ b/include/network.h
@@ -30,6 +30,7 @@
 #include <connman/device.h>
 #include <connman/ipconfig.h>
 #include <glib.h>
+#include <connman/types.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -158,6 +159,8 @@ int connman_network_set_blob(struct connman_network *network,
 			const char *key, const void *data, unsigned int size);
 const void *connman_network_get_blob(struct connman_network *network,
 					const char *key, unsigned int *size);
+connman_bool_t connman_network_get_p2p_network(struct connman_network *network);
+void connman_network_set_p2p_network(struct connman_network *network, connman_bool_t is_p2p_network);
 
 struct connman_device *connman_network_get_device(struct connman_network *network);
 
diff --git a/include/peer.h b/include/peer.h
index 80663932..9a968f36 100644
--- a/include/peer.h
+++ b/include/peer.h
@@ -40,6 +40,9 @@ enum connman_peer_wps_method {
 	CONNMAN_PEER_WPS_UNKNOWN         = 0,
 	CONNMAN_PEER_WPS_PBC             = 1,
 	CONNMAN_PEER_WPS_PIN             = 2,
+	CONNMAN_PEER_WPS_DISPLAY            = 3,
+	CONNMAN_PEER_WPS_KEYBOARD         = 4,
+	CONNMAN_PEER_WPS_P2PS                 = 5
 };
 
 enum connman_peer_service_type {
@@ -68,13 +71,24 @@ void connman_peer_set_iface_address(struct connman_peer *peer,
 					const unsigned char *iface_address);
 void connman_peer_set_device(struct connman_peer *peer,
 				struct connman_device *device);
+void connman_peer_set_config_methods(struct connman_peer *peer,
+				dbus_uint16_t config_methods);
+void connman_peer_set_pri_dev_type(struct connman_peer *peer,
+				const char* pri_dev_type);
+int connman_peer_set_ipaddress(struct connman_peer *peer,
+				const char *address, const char *netmask, const char *gateway);
 struct connman_device *connman_peer_get_device(struct connman_peer *peer);
 void connman_peer_set_sub_device(struct connman_peer *peer,
 					struct connman_device *device);
 void connman_peer_set_as_master(struct connman_peer *peer, bool master);
+void connman_peer_set_as_go(struct connman_peer *peer, bool go);
 int connman_peer_set_state(struct connman_peer *peer,
 					enum connman_peer_state new_state);
-int connman_peer_request_connection(struct connman_peer *peer);
+enum connman_peer_state connman_peer_get_state(struct connman_peer *peer);
+void connman_peer_state_change_by_cancelled(void);
+void connman_peer_request_connection(struct connman_peer *peer, int dev_passwd_id);
+void connman_peer_invitation_request(const char* peer_path,
+					const char* signal, const char* go_dev_addr);
 void connman_peer_reset_services(struct connman_peer *peer);
 void connman_peer_add_service(struct connman_peer *peer,
 				enum connman_peer_service_type type,
@@ -86,6 +100,10 @@ void connman_peer_unregister(struct connman_peer *peer);
 
 struct connman_peer *connman_peer_get(struct connman_device *device,
 						const char *identifier);
+struct connman_peer *connman_peer_get_by_path(const char *path);
+void connman_peer_get_local_address(gpointer user_data, DBusMessageIter *iter);
+
+void __connman_peer_get_properties_struct(DBusMessageIter *iter, gpointer user_data);
 
 typedef void (* peer_service_registration_cb_t) (int result, void *user_data);
 
@@ -104,12 +122,14 @@ struct connman_peer_driver {
 					int specification_length,
 					const unsigned char *query,
 					int query_length, int version);
+	int (*reject) (struct connman_peer *peer);
 };
 
 int connman_peer_driver_register(struct connman_peer_driver *driver);
 void connman_peer_driver_unregister(struct connman_peer_driver *driver);
 
 bool connman_peer_service_is_master(void);
+const char *connman_peer_wps_method2string(enum connman_peer_wps_method method);
 
 #ifdef __cplusplus
 }
diff --git a/include/sd.h b/include/sd.h
new file mode 100644
index 00000000..c8b6530a
--- /dev/null
+++ b/include/sd.h
@@ -0,0 +1,25 @@
+#ifndef __CONNMAN_SD_H
+#define __CONNMAN_SD_H
+
+#include <connman/types.h>
+#include <stdbool.h>
+#include <gsupplicant/gsupplicant.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct connman_service_discovery;
+
+void __connman_sd_init(GSupplicantInterface *interface, const char *dev_ident);
+void __connman_sd_cleanup(void);
+
+void __connman_sd_response_from_p2p_peer(const char *peer_ident, int reference,
+								unsigned char *tlv, int tlv_len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_SD_H */
diff --git a/include/technology.h b/include/technology.h
index 8b4f159c..445174d0 100644
--- a/include/technology.h
+++ b/include/technology.h
@@ -23,6 +23,7 @@
 #define __CONNMAN_TECHNOLOGY_H
 
 #include <connman/service.h>
+#include <gdbus.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -51,8 +52,26 @@ bool connman_technology_get_wifi_tethering(const char **ssid,
 							const char **psk);
 unsigned int connman_technology_get_wifi_tethering_channel(void);
 bool connman_technology_is_tethering_allowed(enum connman_service_type type);
+bool is_technology_enabled(struct connman_technology *technology);
+
+void connman_technology_set_p2p(struct connman_technology *technology, bool enabled);
+void connman_technology_set_p2p_identifier(struct connman_technology *technology,
+							const char *p2p_identifier);
+bool connman_technology_get_enable_p2p_listen(struct connman_technology *technology);
+bool connman_technology_get_p2p_listen(struct connman_technology *technology);
+void connman_technology_set_p2p_listen(struct connman_technology *technology,
+							bool enabled);
+void __connman_technology_p2p_invitation_result(struct connman_technology *technology,
+							int status);
+void connman_technology_set_p2p_listen_params(struct connman_technology *technology,
+						int period, int interval);
+unsigned int connman_technology_get_p2p_listen_channel(struct connman_technology *technology);
+void connman_technology_set_p2p_listen_channel(struct connman_technology *technology,
+									unsigned int listen_channel);
 
 void connman_technology_wps_failed_notify(struct connman_technology *technology);
+bool connman_technology_get_p2p_persistent(struct connman_technology *technology);
+void connman_technology_set_p2p_persistent(struct connman_technology *technology, bool enabled);
 
 struct connman_technology_driver {
 	const char *name;
@@ -65,11 +84,30 @@ struct connman_technology_driver {
 							const char *ident);
 	void (*remove_interface) (struct connman_technology *technology,
 								int index);
+	int (*set_p2p_enable) (struct connman_technology *technology,
+								bool status);
 	int (*set_tethering) (struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
 				const char *bridge, bool enabled);
 	int (*set_regdom) (struct connman_technology *technology,
 						const char *alpha2);
+	int (*set_p2p_identifier) (struct connman_technology *technology,
+						const char *p2p_identifier);
+	int (*set_p2p_persistent) (struct connman_technology *technology,
+						bool persistent_reconnect);
+	int (*set_p2p_listen_channel) (struct connman_technology *technology,
+						unsigned int listen_channel);
+	int (*set_p2p_go_intent) (struct connman_technology *technology,
+						unsigned int go_intent);
+	int (*set_p2p_listen) (struct connman_technology *technology,
+						bool enable);
+	int (*set_p2p_listen_params) (struct connman_technology *technology,
+						int period, int interval);
+	int (*set_p2p_go) (DBusMessage *msg, struct connman_technology *technology,
+						const char *identifier, const char *passphrase);
+	int (*remove_persistent_info) (struct connman_technology *technology,
+						const char *identifier);
+	int (*remove_persistent_info_all) (struct connman_technology *technology);
 };
 
 int connman_technology_driver_register(struct connman_technology_driver *driver);
diff --git a/include/types.h b/include/types.h
new file mode 100644
index 00000000..0f671ec3
--- /dev/null
+++ b/include/types.h
@@ -0,0 +1,45 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2012  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_TYPES_H
+#define __CONNMAN_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+typedef int		connman_bool_t;
+typedef unsigned char	connman_uint8_t;
+typedef unsigned short	connman_uint16_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_TYPES_H */
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 429a50c4..22696291 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -33,6 +33,8 @@
 #include <net/ethernet.h>
 #include <linux/wireless.h>
 
+#include <connman/types.h>
+
 #ifndef IFF_LOWER_UP
 #define IFF_LOWER_UP	0x10000
 #endif
@@ -59,6 +61,10 @@
 
 #include <gsupplicant/gsupplicant.h>
 
+#include "src/connman.h"
+
+#include "include/group.h"
+
 #include "src/shared/util.h"
 
 #define CLEANUP_TIMEOUT   8	/* in seconds */
@@ -69,15 +75,29 @@
 #define BGSCAN_DEFAULT "simple:30:-65:300"
 #define AUTOSCAN_EXPONENTIAL "exponential:3:300"
 #define AUTOSCAN_SINGLE "single:3"
+#define P2P_PERSISTENT_INFO		"P2PPersistentInfo"
 
 #define P2P_FIND_TIMEOUT 30
-#define P2P_CONNECTION_TIMEOUT 100
-#define P2P_LISTEN_PERIOD 500
-#define P2P_LISTEN_INTERVAL 2000
+#define P2P_CONNECTION_TIMEOUT 60
+#define P2P_LISTEN_PERIOD 450
+#define P2P_LISTEN_INTERVAL 500
+#define P2P_PERSISTENT_MAX_COUNT 20
 
 #define ASSOC_STATUS_NO_CLIENT 17
 #define LOAD_SHAPING_MAX_RETRIES 3
 
+static char *p2p_go_identifier = NULL;
+static char *p2p_group_if_prefix = "p2p-";
+static char *p2p_group_ifname = NULL;
+static int p2p_group_ifindex = -1;
+static int pin_requested_ref = -1;
+static int pbc_requested_ref = -1;
+static int p2p_find_ref = -1;
+static int p2p_listen_ref = -1;
+
+struct p2p_listen_data params = { .period = P2P_LISTEN_PERIOD, .interval = P2P_LISTEN_INTERVAL };
+
+static DBusConnection *connection;
 static struct connman_technology *wifi_technology = NULL;
 static struct connman_technology *p2p_technology = NULL;
 
@@ -157,12 +177,14 @@ struct wifi_data {
 	struct autoscan_params *autoscan;
 	enum wifi_scanning_type scanning_type;
 	GSupplicantScanParams *scan_params;
+	GSupplicantP2PDeviceConfigParams p2p_device_config;
 	unsigned int p2p_find_timeout;
 	unsigned int p2p_connection_timeout;
 	struct connman_peer *pending_peer;
 	GSList *peers;
 	bool p2p_connecting;
 	bool p2p_device;
+	bool p2p_listen_suppressed;
 	int servicing;
 	int disconnect_code;
 	int assoc_code;
@@ -171,6 +193,12 @@ struct wifi_data {
 	GSupplicantSSID *wps_ssid;
 	guint wps_timeout;
 	bool wps_start_deferred;
+
+	const char *generated_pin;
+	const char *pin_requested_path;
+	const char *invited_path;
+	GSList *persistent_groups;
+	GHashTable *persistent_peer_ssid;
 };
 
 struct wifi_cb_data {
@@ -185,10 +213,23 @@ static GList *pending_wifi_device = NULL;
 static GList *p2p_iface_list = NULL;
 static bool wfd_service_registered = false;
 
+static DBusMessage *group_msg;
+static bool create_group_flag = false;
+
+static int peer_disconnect(struct connman_peer *peer);
+static void p2p_group_finished(GSupplicantInterface *interface);
+static void remove_peers(struct wifi_data *wifi);
 static void start_autoscan(struct connman_device *device);
+static gboolean p2p_find_stop(gpointer data);
+static GSupplicantSSID *ssid_ap_init(const char *ssid, const char *passphrase);
 static int tech_set_tethering(struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
 				const char *bridge, bool enabled);
+static int apply_p2p_listen_on_iface(gpointer data, gpointer user_data);
+static void leave_p2p_listen_on_iface(gpointer data);
+static int add_persistent_group_info(struct wifi_data *wifi);
+static int p2p_persistent_info_load(GSupplicantInterface *interface,
+		const char *persistent_dir, GSupplicantP2PPersistentGroup *persistent_group);
 
 static void bss_foreach(gpointer key, gpointer value, gpointer user_data)
 {
@@ -223,3453 +264,5621 @@ static void p2p_tech_remove(struct connman_technology *technology)
 	p2p_technology = NULL;
 }
 
-static struct connman_technology_driver p2p_tech_driver = {
-	.name		= "p2p",
-	.type		= CONNMAN_SERVICE_TYPE_P2P,
-	.probe		= p2p_tech_probe,
-	.remove		= p2p_tech_remove,
-};
-
-static bool is_p2p_connecting(void)
+static const char *load_p2p_identifier()
 {
-	GList *list;
+	GKeyFile *keyfile = NULL;
+	gchar *identifier = NULL;
+	const char *p2p_identifier = NULL;
 
-	for (list = iface_list; list; list = list->next) {
-		struct wifi_data *wifi = list->data;
+	keyfile = __connman_storage_load_global();
+	if(!keyfile)
+		return NULL;
 
-		if (wifi->p2p_connecting)
-			return true;
+	identifier = g_strdup_printf("%s", "WiFi");
+	if (!identifier) {
+		g_key_file_free(keyfile);
+		return NULL;
 	}
 
-	return false;
-}
+	p2p_identifier = g_key_file_get_string(keyfile, identifier, "P2PIdentifier", NULL);
+	g_free(identifier);
 
-static void enable_auto_connect_block(bool block)
-{
-	DBG("block %d", block);
-	if (block)
-		block_auto_connect = true;
-	else {
-		block_auto_connect = false;
-		__connman_service_auto_connect(CONNMAN_SERVICE_CONNECT_REASON_AUTO);
+	if(!p2p_identifier) {
+		g_key_file_free(keyfile);
+		return NULL;
 	}
+
+	if(strlen(p2p_identifier) > 32)
+		p2p_identifier = NULL;
+
+	g_key_file_free(keyfile);
+
+	return p2p_identifier;
 }
 
-static void add_pending_wifi_device(struct wifi_data *wifi)
+static void save_p2p_identifier(const char *p2p_identifier)
 {
-	if (g_list_find(pending_wifi_device, wifi))
+	GKeyFile *keyfile = NULL;
+	gchar *identifier = NULL;
+
+	keyfile = __connman_storage_load_global();
+	if(!keyfile)
 		return;
 
-	pending_wifi_device = g_list_append(pending_wifi_device, wifi);
+	identifier = g_strdup_printf("%s", "WiFi");
+	if (!identifier) {
+		g_key_file_free(keyfile);
+		return;
+	}
+
+	g_key_file_set_string(keyfile, identifier, "P2PIdentifier", p2p_identifier);
+	g_free(identifier);
+
+	__connman_storage_save_global(keyfile);
+
+	g_key_file_free(keyfile);
 }
 
-static struct wifi_data *get_pending_wifi_data(const char *ifname)
+static int tech_set_p2p_enable(struct connman_technology *technology, bool status)
 {
-	GList *list;
+	GList *list = NULL;
+	int err = 0;
+	struct connman_peer *connmanpeer;
 
-	for (list = pending_wifi_device; list; list = list->next) {
-		struct wifi_data *wifi;
-		const char *dev_name;
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-		wifi = list->data;
-		if (!wifi || !wifi->device)
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
+
+		if (!g_supplicant_interface_has_p2p(iface))
 			continue;
+		err = g_supplicant_interface_set_p2p_disabled(iface, !status);
 
-		dev_name = connman_device_get_string(wifi->device, "Interface");
-		if (!g_strcmp0(ifname, dev_name)) {
-			pending_wifi_device = g_list_delete_link(
-						pending_wifi_device, list);
-			return wifi;
+		if (err == 0 && status) {
+			if (connman_technology_get_p2p_listen(technology)) {
+				err = apply_p2p_listen_on_iface(wifi, &params);
+			}
+			if(err == 0)
+				g_supplicant_interface_get_p2p_device_config(iface, &wifi->p2p_device_config);
+		} else if(err == 0 && !status) {
+			if (connman_technology_get_p2p_listen(technology)) {
+				leave_p2p_listen_on_iface(wifi);
+			}
+			if(__connman_peer_get_connected_exists()) {
+				connman_technology_set_p2p(p2p_technology, false);
+				connmanpeer = __connman_get_connected_peer();
+				peer_disconnect(connmanpeer);
+				p2p_group_finished(iface);
+				remove_peers(wifi);
+			}
 		}
 	}
 
-	return NULL;
+	return err;
 }
 
-static void remove_pending_wifi_device(struct wifi_data *wifi)
+static int tech_set_p2p_identifier(struct connman_technology *technology, const char *p2p_identifier)
 {
-	GList *link;
+	GList *list = NULL;
+	char *old_device_name = NULL;
+	char *old_ssid_postfix = NULL;
+	int err = -EOPNOTSUPP;
 
-	link = g_list_find(pending_wifi_device, wifi);
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	if (!link)
-		return;
+	if (is_technology_enabled(p2p_technology)) {
+		for (list = iface_list; list; list = list->next) {
+			struct wifi_data *wifi = list->data;
+			GSupplicantInterface *iface = wifi->interface;
 
-	pending_wifi_device = g_list_delete_link(pending_wifi_device, link);
-}
+			if (!g_supplicant_interface_has_p2p(iface))
+				continue;
 
-static void peer_cancel_timeout(struct wifi_data *wifi)
-{
-	if (wifi->p2p_connection_timeout > 0)
-		g_source_remove(wifi->p2p_connection_timeout);
+			if (wifi->p2p_device_config.device_name)
+				old_device_name = wifi->p2p_device_config.device_name;
 
-	wifi->p2p_connection_timeout = 0;
-	wifi->p2p_connecting = false;
+			if (wifi->p2p_device_config.ssid_postfix)
+				old_ssid_postfix = wifi->p2p_device_config.ssid_postfix;
 
-	if (wifi->pending_peer) {
-		connman_peer_unref(wifi->pending_peer);
-		wifi->pending_peer = NULL;
+			wifi->p2p_device_config.device_name = g_strdup(p2p_identifier);
+			wifi->p2p_device_config.ssid_postfix = g_strdup_printf("-%s", p2p_identifier);
+
+			err = g_supplicant_interface_set_p2p_device_configs(iface, &wifi->p2p_device_config, NULL);
+
+			if(err < 0) {
+				g_free(wifi->p2p_device_config.device_name);
+				g_free(wifi->p2p_device_config.ssid_postfix);
+
+				wifi->p2p_device_config.device_name = old_device_name;
+				wifi->p2p_device_config.ssid_postfix = old_ssid_postfix;
+			} else {
+				connman_technology_set_p2p_identifier(technology, wifi->p2p_device_config.device_name);
+				save_p2p_identifier(wifi->p2p_device_config.device_name);
+
+				g_free(old_device_name);
+				g_free(old_ssid_postfix);
+			}
+		}
+	} else {
+		connman_technology_set_p2p_identifier(technology, p2p_identifier);
+		save_p2p_identifier(p2p_identifier);
+		err = 0;
 	}
+	return err;
 }
 
-static gboolean peer_connect_timeout(gpointer data)
+static int tech_set_p2p_persistent(struct connman_technology *technology, bool persistent_reconnect)
 {
-	struct wifi_data *wifi = data;
+	GList *list = NULL;
+	int err = 0;
 
-	DBG("");
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	if (wifi->p2p_connecting) {
-		enum connman_peer_state state = CONNMAN_PEER_STATE_FAILURE;
-		GSupplicantPeer *gs_peer =
-			g_supplicant_interface_peer_lookup(wifi->interface,
-				connman_peer_get_identifier(wifi->pending_peer));
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-		if (g_supplicant_peer_has_requested_connection(gs_peer))
-			state = CONNMAN_PEER_STATE_IDLE;
+		if (!g_supplicant_interface_has_p2p(iface))
+			continue;
 
-		connman_peer_set_state(wifi->pending_peer, state);
+		wifi->p2p_device_config.persistent_reconnect = persistent_reconnect;
+
+		err = g_supplicant_interface_set_p2p_device_configs(iface, &wifi->p2p_device_config, NULL);
 	}
 
-	peer_cancel_timeout(wifi);
+	return err;
+}
 
-	return FALSE;
+static int listen_reg_class_by_channel(int channel)
+{
+	int listen_reg_class = 0;
+
+	if (channel >= 1 && channel <= 13)
+		listen_reg_class = 81;
+	else if(channel == 14)
+		listen_reg_class = 82;
+	else if(channel >= 36 && channel <= 48)
+		listen_reg_class = 115;
+	else if(channel >= 52 && channel <= 64)
+		listen_reg_class = 118;
+	else if(channel >= 149 && channel <= 161)
+		listen_reg_class = 124;
+	else if(channel >= 165 && channel <= 169)
+		listen_reg_class = 125;
+
+	return listen_reg_class;
 }
 
-static void peer_connect_callback(int result, GSupplicantInterface *interface,
-							void *user_data)
+static int tech_set_p2p_listen_channel(struct connman_technology *technology, unsigned int listen_channel)
 {
-	struct wifi_data *wifi = user_data;
-	struct connman_peer *peer = wifi->pending_peer;
+	GList *list = NULL;
+	int err = 0;
 
-	DBG("peer %p - %d", peer, result);
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	if (!peer)
-		return;
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-	if (result < 0) {
-		peer_connect_timeout(wifi);
-		return;
-	}
+		if (!g_supplicant_interface_has_p2p(iface))
+			continue;
 
-	connman_peer_set_state(peer, CONNMAN_PEER_STATE_ASSOCIATION);
+		DBG("listen channel %d", listen_channel);
 
-	wifi->p2p_connection_timeout = g_timeout_add_seconds(
-						P2P_CONNECTION_TIMEOUT,
-						peer_connect_timeout, wifi);
+		wifi->p2p_device_config.listen_reg_class = listen_reg_class_by_channel(listen_channel);
+		wifi->p2p_device_config.listen_channel = listen_channel;
+
+		err = g_supplicant_interface_set_p2p_device_configs(iface, &wifi->p2p_device_config, NULL);
+	}
+
+	return err;
 }
 
-static int peer_connect(struct connman_peer *peer,
-			enum connman_peer_wps_method wps_method,
-			const char *wps_pin)
+static int tech_set_p2p_go_intent(struct connman_technology *technology, unsigned int go_intent)
 {
-	struct connman_device *device = connman_peer_get_device(peer);
-	GSupplicantPeerParams *peer_params;
-	GSupplicantPeer *gs_peer;
-	struct wifi_data *wifi;
-	bool pbc, pin;
-	int ret;
-
-	DBG("peer %p", peer);
+	GList *list = NULL;
+	int err = 0;
 
-	if (!device)
-		return -ENODEV;
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	wifi = connman_device_get_data(device);
-	if (!wifi || !wifi->interface)
-		return -ENODEV;
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-	if (wifi->p2p_connecting)
-		return -EBUSY;
+		if (!iface || !g_supplicant_interface_has_p2p(iface))
+			continue;
 
-	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
-					connman_peer_get_identifier(peer));
-	if (!gs_peer)
-		return -EINVAL;
+		DBG("go intent value : %d", go_intent);
 
-	pbc = g_supplicant_peer_is_wps_pbc(gs_peer);
-	pin = g_supplicant_peer_is_wps_pin(gs_peer);
+		wifi->p2p_device_config.go_intent = go_intent;
 
-	switch (wps_method) {
-	case CONNMAN_PEER_WPS_UNKNOWN:
-		if ((pbc && pin) || pin)
-			return -ENOKEY;
-		break;
-	case CONNMAN_PEER_WPS_PBC:
-		if (!pbc)
-			return -EINVAL;
-		wps_pin = NULL;
-		break;
-	case CONNMAN_PEER_WPS_PIN:
-		if (!pin || !wps_pin)
-			return -EINVAL;
-		break;
+		err = g_supplicant_interface_set_p2p_device_configs(iface, &wifi->p2p_device_config, NULL);
 	}
 
-	peer_params = g_try_malloc0(sizeof(GSupplicantPeerParams));
-	if (!peer_params)
-		return -ENOMEM;
+	return err;
+}
 
-	peer_params->path = g_strdup(g_supplicant_peer_get_path(gs_peer));
-	if (wps_pin)
-		peer_params->wps_pin = g_strdup(wps_pin);
+static int set_p2p_listen_without_state_change(struct connman_technology *technology, bool enable)
+{
+	GList *list = NULL;
+	int ret = 0;
 
-	peer_params->master = connman_peer_service_is_master();
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	ret = g_supplicant_interface_p2p_connect(wifi->interface, peer_params,
-						peer_connect_callback, wifi);
-	if (ret == -EINPROGRESS) {
-		wifi->pending_peer = connman_peer_ref(peer);
-		wifi->p2p_connecting = true;
-	} else if (ret < 0) {
-		g_free(peer_params->path);
-		g_free(peer_params->wps_pin);
-		g_free(peer_params);
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
+
+		if (!iface || !g_supplicant_interface_has_p2p(iface))
+			continue;
+
+		if (enable) {
+			if (!connman_technology_get_enable_p2p_listen(technology))
+				return -EOPNOTSUPP;
+
+			ret = apply_p2p_listen_on_iface(wifi, &params);
+		}
+		else
+			leave_p2p_listen_on_iface(wifi);
 	}
 
 	return ret;
 }
 
-static int peer_disconnect(struct connman_peer *peer)
-{
-	struct connman_device *device = connman_peer_get_device(peer);
-	GSupplicantPeerParams peer_params = {};
-	GSupplicantPeer *gs_peer;
-	struct wifi_data *wifi;
-	int ret;
-
-	DBG("peer %p", peer);
-
-	if (!device)
-		return -ENODEV;
 
-	wifi = connman_device_get_data(device);
-	if (!wifi)
-		return -ENODEV;
+static int tech_set_p2p_listen(struct connman_technology *technology, bool enable)
+{
+	GList *list = NULL;
+	int ret = 0;
 
-	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
-					connman_peer_get_identifier(peer));
-	if (!gs_peer)
-		return -EINVAL;
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	peer_params.path = g_strdup(g_supplicant_peer_get_path(gs_peer));
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-	ret = g_supplicant_interface_p2p_disconnect(wifi->interface,
-							&peer_params);
-	g_free(peer_params.path);
+		if (!iface || !g_supplicant_interface_has_p2p(iface))
+			continue;
 
-	if (ret == -EINPROGRESS) {
-		peer_cancel_timeout(wifi);
-		wifi->p2p_device = false;
+		if (p2p_find_ref == -1) {
+			if (enable) {
+				ret = apply_p2p_listen_on_iface(wifi, &params);
+				if (!ret)
+					connman_technology_set_p2p_listen(technology, true);
+			} else {
+				leave_p2p_listen_on_iface(wifi);
+				connman_technology_set_p2p_listen(technology, false);
+			}
+		} else {
+			if (enable)
+				connman_technology_set_p2p_listen(technology, true);
+			else {
+				p2p_find_stop(wifi->device);
+				start_autoscan(wifi->device);
+			}
+		}
 	}
 
 	return ret;
 }
 
-struct peer_service_registration {
-	peer_service_registration_cb_t callback;
-	void *user_data;
-};
+static int tech_set_p2p_listen_params(struct connman_technology *technology,
+					int period, int interval)
+{
+	GList *list = NULL;
+	struct wifi_data *wifi = NULL;
+	bool params_changed = false;
+	int ret = 0;
 
-static bool is_service_wfd(const unsigned char *specs, int length)
-{
-	if (length < 9 || specs[0] != 0 || specs[1] != 0 || specs[2] != 6)
-		return false;
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	return true;
-}
+	DBG("period %d interval %d", period, interval);
 
-static void apply_p2p_listen_on_iface(gpointer data, gpointer user_data)
-{
-	struct wifi_data *wifi = data;
+	if ((params.period != period) || (params.interval != interval)) {
+		params_changed = true;
+		params.period = period;
+		params.interval = interval;
+	}
 
-	if (!wifi->interface ||
+	if (!connman_technology_get_enable_p2p_listen(technology))
+		return 0;
+
+	for (list = iface_list; list; list = list->next) {
+		wifi = list->data;
+
+		if (!wifi->interface ||
 			!g_supplicant_interface_has_p2p(wifi->interface))
-		return;
+			continue;
 
-	if (!wifi->servicing) {
-		g_supplicant_interface_p2p_listen(wifi->interface,
-				P2P_LISTEN_PERIOD, P2P_LISTEN_INTERVAL);
+		// Decrement the count if listen is already set
+		if (wifi->servicing && params_changed)
+			wifi->servicing--;
+
+		ret = apply_p2p_listen_on_iface(wifi, &params);
+		if (ret != 0)
+			continue;
+		if (!connman_technology_get_p2p_listen(p2p_technology))
+			connman_technology_set_p2p_listen(p2p_technology, true);
 	}
 
-	wifi->servicing++;
+	return 0;
 }
 
-static void register_wfd_service_cb(int result,
-				GSupplicantInterface *iface, void *user_data)
+static void remove_persistent_groups_elements(GSupplicantP2PPersistentGroup *pg)
 {
-	struct peer_service_registration *reg_data = user_data;
-
-	DBG("");
+	if(pg->path)
+		g_free(pg->path);
+	if(pg->group_path)
+		g_free(pg->group_path);
+	if(pg->bssid)
+		g_free(pg->bssid);
+	if(pg->bssid_no_colon)
+		g_free(pg->bssid_no_colon);
+	if(pg->ssid)
+		g_free(pg->ssid);
+	if(pg->psk)
+		g_free(pg->psk);
+
+	g_free(pg);
+	pg = NULL;
+}
 
-	if (result == 0)
-		g_list_foreach(iface_list, apply_p2p_listen_on_iface, NULL);
+static void free_persistent_groups(gpointer data)
+{
+	struct GSupplicantP2PPersistentGroup *pg = data;
 
-	if (reg_data && reg_data->callback) {
-		reg_data->callback(result, reg_data->user_data);
-		g_free(reg_data);
-	}
+	if (pg != NULL)
+		remove_persistent_groups_elements(pg);
 }
 
-static GSupplicantP2PServiceParams *fill_in_peer_service_params(
-				const unsigned char *spec,
-				int spec_length, const unsigned char *query,
-				int query_length, int version)
+static void p2p_persistent_group_added(GSupplicantInterface *interface, GSupplicantP2PPersistentGroup *persistent_group)
 {
-	GSupplicantP2PServiceParams *params;
+	struct wifi_data *wifi;
+	wifi = g_supplicant_interface_get_data(interface);
 
-	params = g_try_malloc0(sizeof(GSupplicantP2PServiceParams));
-	if (!params)
-		return NULL;
+	DBG("ssid %s", persistent_group->ssid);
 
-	if (version > 0) {
-		params->version = version;
-		params->service = g_memdup(spec, spec_length);
-	} else if (query_length > 0 && spec_length > 0) {
-		params->query = g_memdup(query, query_length);
-		params->query_length = query_length;
+	if(wifi == NULL)
+		goto DONE;
 
-		params->response = g_memdup(spec, spec_length);
-		params->response_length = spec_length;
+	/* newly added persistent_group */
+	if(persistent_group->psk != NULL){
+		wifi->persistent_groups = g_slist_prepend(wifi->persistent_groups, persistent_group);
+		DBG("new group ssid : %s\n", persistent_group->ssid);
+		return;
+	/* added by service file */
+	} else if (persistent_group->bssid != NULL &&  persistent_group->ssid != NULL) {
+		GSList *item;
+		GSupplicantP2PPersistentGroup *exist_pg;
+
+		item = wifi->persistent_groups;
+		while(item != NULL) {
+			exist_pg = item->data;
+			if(g_str_equal(exist_pg->bssid, persistent_group->bssid) && g_str_equal(exist_pg->ssid, persistent_group->ssid)) {
+				DBG("updating existing group: %s\n", persistent_group->ssid);
+				if (exist_pg->path)
+					g_free(exist_pg->path);
+				exist_pg->path = g_strdup(persistent_group->path);
+
+				if (exist_pg->bssid_no_colon)
+					g_free(exist_pg->bssid_no_colon);
+				exist_pg->bssid_no_colon = g_strdup(persistent_group->bssid_no_colon);
+				break;
+			}
+
+			item = g_slist_next(item);
+		}
 	} else {
-		params->wfd_ies = g_memdup(spec, spec_length);
-		params->wfd_ies_length = spec_length;
+		DBG("Skipping group, need bssid and ssid!");
 	}
 
-	return params;
+DONE:
+	free_persistent_groups(persistent_group);
 }
 
-static void free_peer_service_params(GSupplicantP2PServiceParams *params)
+static void p2p_persistent_group_removed(GSupplicantInterface *interface, const char *persistent_group_path)
 {
-	if (!params)
-		return;
-
-	g_free(params->service);
-	g_free(params->query);
-	g_free(params->response);
-	g_free(params->wfd_ies);
+	struct wifi_data *wifi;
+	GSList *item;
+	GSupplicantP2PPersistentGroup *exist_pg, *removed_pg = NULL;
 
-	g_free(params);
-}
+	wifi = g_supplicant_interface_get_data(interface);
 
-static int peer_register_wfd_service(const unsigned char *specification,
-				int specification_length,
-				peer_service_registration_cb_t callback,
-				void *user_data)
-{
-	struct peer_service_registration *reg_data = NULL;
-	static GSupplicantP2PServiceParams *params;
-	int ret;
+	DBG("persistent_group_path %s", persistent_group_path);
 
-	DBG("");
+	if(wifi == NULL || wifi->persistent_groups == NULL || persistent_group_path == NULL)
+		return;
 
-	if (wfd_service_registered)
-		return -EBUSY;
+	item = wifi->persistent_groups;
+	while(item != NULL) {
+		exist_pg = item->data;
 
-	params = fill_in_peer_service_params(specification,
-					specification_length, NULL, 0, 0);
-	if (!params)
-		return -ENOMEM;
+		if(exist_pg->path && g_str_equal(exist_pg->path, persistent_group_path)) {
+			removed_pg = exist_pg;
+			break;
+		}
+		item = g_slist_next(item);
+	}
 
-	reg_data = g_try_malloc0(sizeof(*reg_data));
-	if (!reg_data) {
-		ret = -ENOMEM;
-		goto error;
+	if(removed_pg != NULL){
+		wifi->persistent_groups = g_slist_remove(wifi->persistent_groups, removed_pg);
+		remove_persistent_groups_elements(removed_pg);
 	}
+}
 
-	reg_data->callback = callback;
-	reg_data->user_data = user_data;
+static int tech_set_p2p_go(DBusMessage *msg, struct connman_technology *technology,
+		const char *identifier, const char *passphrase) {
+	GList *list;
+	struct wifi_tethering_info *info;
+	char p2p_ssid[P2P_MAX_SSID] = {0x00,};
+	int err = 0;
 
-	ret = g_supplicant_set_widi_ies(params,
-					register_wfd_service_cb, reg_data);
-	if (ret < 0 && ret != -EINPROGRESS)
-		goto error;
+	if (!p2p_technology)
+		return -EOPNOTSUPP;
 
-	wfd_service_registered = true;
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-	return ret;
-error:
-	free_peer_service_params(params);
-	g_free(reg_data);
+		if (!iface || !g_supplicant_interface_has_p2p(iface))
+			continue;
 
-	return ret;
-}
+		if (connman_technology_get_p2p_listen(technology) == TRUE) {
+			leave_p2p_listen_on_iface(wifi);
+			connman_technology_set_p2p_listen(technology, false);
+		} else {
+			if (wifi->device)
+				p2p_find_stop(wifi->device);
+		}
 
-static void register_peer_service_cb(int result,
-				GSupplicantInterface *iface, void *user_data)
-{
-	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
-	struct peer_service_registration *reg_data = user_data;
+		info = g_try_malloc0(sizeof(struct wifi_tethering_info));
+		if (info == NULL )
+			return -ENOMEM;
 
-	DBG("");
+		info->wifi = wifi;
+		info->technology = technology;
 
-	if (result == 0)
-		apply_p2p_listen_on_iface(wifi, NULL);
+		if (identifier || passphrase) {
+			snprintf(p2p_ssid, P2P_MAX_SSID, "%s%s", P2P_WILDCARD_SSID, identifier);
+			info->ssid = ssid_ap_init(p2p_ssid, passphrase);
 
-	if (reg_data->callback)
-		reg_data->callback(result, reg_data->user_data);
+			err = g_supplicant_interface_p2p_persistent_group_add(iface,
+					info->ssid, NULL, info);
 
-	g_free(reg_data);
+		} else {
+			err = g_supplicant_interface_p2p_group_add(iface, NULL,
+					NULL, info);
+		}
+
+		group_msg = dbus_message_ref(msg);
+		create_group_flag = true;
+	}
+
+	return -err;
 }
 
-static int peer_register_service(const unsigned char *specification,
-				int specification_length,
-				const unsigned char *query,
-				int query_length, int version,
-				peer_service_registration_cb_t callback,
-				void *user_data)
+static int p2p_remove_persistent_info(GSupplicantInterface *interface, const char *peer_ident)
 {
-	struct peer_service_registration *reg_data;
-	GSupplicantP2PServiceParams *params;
-	bool found = false;
-	int ret, ret_f;
-	GList *list;
+	struct wifi_data *wifi;
+	GSupplicantP2PPersistentGroup *persistent_group, *removing_pg;
+	char persistent_info_name[28] = "p2p_persistent_";
+	GSList *item;
 
-	DBG("");
+	DBG("peer_ident %s", peer_ident);
 
-	if (specification && !version && !query &&
-			is_service_wfd(specification, specification_length)) {
-		return peer_register_wfd_service(specification,
-				specification_length, callback, user_data);
-	}
+	wifi = g_supplicant_interface_get_data(interface);
 
-	reg_data = g_try_malloc0(sizeof(*reg_data));
-	if (!reg_data)
+	if(wifi == NULL)
 		return -ENOMEM;
 
-	reg_data->callback = callback;
-	reg_data->user_data = user_data;
+	p2p_find_stop(wifi->device);
 
-	ret_f = -EOPNOTSUPP;
+	removing_pg = g_try_malloc0(sizeof(GSupplicantP2PPersistentGroup));
+	if(removing_pg == NULL)
+		return -ENOMEM;
 
-	for (list = iface_list; list; list = list->next) {
-		struct wifi_data *wifi = list->data;
-		GSupplicantInterface *iface = wifi->interface;
+	strncat(persistent_info_name, peer_ident, strlen(peer_ident));
 
-		if (!g_supplicant_interface_has_p2p(iface))
-			continue;
+	p2p_persistent_info_load(interface, persistent_info_name, removing_pg);
 
-		params = fill_in_peer_service_params(specification,
-						specification_length, query,
-						query_length, version);
-		if (!params)
+	if(removing_pg->ssid == NULL) {
+		g_free(removing_pg);
+		return -EOPNOTSUPP;
+	}
+
+	item = wifi->persistent_groups;
+	while(item != NULL) {
+		persistent_group = item->data;
+
+		if(persistent_group->ssid == NULL || persistent_group->bssid == NULL)
 			continue;
 
-		if (!found) {
-			ret_f = g_supplicant_interface_p2p_add_service(iface,
-				register_peer_service_cb, params, reg_data);
-			if (ret_f == 0 || ret_f == -EINPROGRESS)
-				found = true;
-			ret = ret_f;
-		} else
-			ret = g_supplicant_interface_p2p_add_service(iface,
-				register_peer_service_cb, params, NULL);
-		if (ret != 0 && ret != -EINPROGRESS)
-			free_peer_service_params(params);
+		if(g_str_equal(persistent_group->ssid, removing_pg->ssid)
+				&& g_str_equal(persistent_group->bssid, removing_pg->bssid)) {
+			removing_pg->path = persistent_group->path;
+			break;
+		}
+		item = g_slist_next(item);
 	}
 
-	if (ret_f != 0 && ret_f != -EINPROGRESS)
-		g_free(reg_data);
+	if(removing_pg->path != NULL) {
+		struct connman_network *network;
 
-	return ret_f;
+		g_supplicant_interface_p2p_remove_persistent_group(interface, removing_pg->path);
+		g_hash_table_remove(wifi->persistent_peer_ssid, peer_ident);
+		g_free(removing_pg);
+		__connman_storage_remove_service(persistent_info_name);
+
+		return 0;
+	}
+
+	g_free(removing_pg);
+
+	return -EOPNOTSUPP;
 }
 
-static int peer_unregister_wfd_service(void)
+
+static int tech_remove_persistent_info(struct connman_technology *technology, const char *identifier)
 {
-	GSupplicantP2PServiceParams *params;
 	GList *list;
+	struct wifi_data *wifi;
+	GSupplicantInterface *interface;
+	const char *addr_no_colon;
+	int err = 0;
 
-	if (!wfd_service_registered)
-		return -EALREADY;
-
-	params = fill_in_peer_service_params(NULL, 0, NULL, 0, 0);
-	if (!params)
-		return -ENOMEM;
-
-	wfd_service_registered = false;
+	if (!is_technology_enabled(p2p_technology))
+		return -EOPNOTSUPP;
 
-	g_supplicant_set_widi_ies(params, NULL, NULL);
+	addr_no_colon = __connman_util_remove_colon_from_mac_addr(identifier);
+	if(addr_no_colon == NULL)
+		return -EINVAL;
 
 	for (list = iface_list; list; list = list->next) {
-		struct wifi_data *wifi = list->data;
+		wifi = list->data;
+		interface = wifi->interface;
 
-		if (!g_supplicant_interface_has_p2p(wifi->interface))
+		if (!interface || !g_supplicant_interface_has_p2p(interface))
 			continue;
 
-		wifi->servicing--;
-		if (!wifi->servicing || wifi->servicing < 0) {
-			g_supplicant_interface_p2p_listen(wifi->interface,
-									0, 0);
-			wifi->servicing = 0;
-		}
+		err = p2p_remove_persistent_info(interface, addr_no_colon);
 	}
 
-	return 0;
+	g_free(addr_no_colon);
+
+	return err;
 }
 
-static int peer_unregister_service(const unsigned char *specification,
-						int specification_length,
-						const unsigned char *query,
-						int query_length, int version)
+static int tech_remove_persistent_info_all(struct connman_technology *technology)
 {
-	GSupplicantP2PServiceParams *params;
-	bool wfd = false;
 	GList *list;
-	int ret;
+	struct wifi_data *wifi = NULL;
+	GSupplicantInterface *interface;
+	gchar **persistents;
+	char *peer_ident;
+	struct connman_network *network;
+	int i;
 
-	if (specification && !version && !query &&
-			is_service_wfd(specification, specification_length)) {
-		ret = peer_unregister_wfd_service();
-		if (ret != 0 && ret != -EINPROGRESS)
-			return ret;
-		wfd = true;
-	}
+	if (!is_technology_enabled(p2p_technology))
+		return -EOPNOTSUPP;
 
 	for (list = iface_list; list; list = list->next) {
-		struct wifi_data *wifi = list->data;
-		GSupplicantInterface *iface = wifi->interface;
-
-		if (wfd)
-			goto stop_listening;
+		wifi = list->data;
+		interface = wifi->interface;
 
-		if (!g_supplicant_interface_has_p2p(iface))
+		if (interface == NULL || !g_supplicant_interface_has_p2p(interface))
 			continue;
 
-		params = fill_in_peer_service_params(specification,
-						specification_length, query,
-						query_length, version);
-		if (!params)
+		g_supplicant_interface_p2p_remove_all_persistent_groups(interface);
+	}
+
+	persistents = __connman_storage_get_p2p_persistents();
+	for (i = 0; persistents && persistents[i]; i++) {
+		DBG("loop : %s\n", persistents[i]);
+
+		if (strncmp(persistents[i], "p2p_persistent_", 15) != 0)
 			continue;
 
-		ret = g_supplicant_interface_p2p_del_service(iface, params);
-		if (ret != 0 && ret != -EINPROGRESS)
-			free_peer_service_params(params);
-stop_listening:
-		wifi->servicing--;
-		if (!wifi->servicing || wifi->servicing < 0) {
-			g_supplicant_interface_p2p_listen(iface, 0, 0);
-			wifi->servicing = 0;
-		}
+		__connman_storage_remove_service(persistents[i]);
+
 	}
 
-	return 0;
+	if (wifi)
+		g_hash_table_remove_all(wifi->persistent_peer_ssid);
+
+	if (persistents)
+		g_strfreev(persistents);
+	return 1;
 }
 
-static struct connman_peer_driver peer_driver = {
-	.connect    = peer_connect,
-	.disconnect = peer_disconnect,
-	.register_service = peer_register_service,
-	.unregister_service = peer_unregister_service,
+static struct connman_technology_driver p2p_tech_driver = {
+	.name		= "p2p",
+	.type		= CONNMAN_SERVICE_TYPE_P2P,
+	.probe		= p2p_tech_probe,
+	.remove		= p2p_tech_remove,
+	.set_p2p_enable = tech_set_p2p_enable,
+	.set_p2p_identifier = tech_set_p2p_identifier,
+	.set_p2p_persistent = tech_set_p2p_persistent,
+	.set_p2p_listen_channel = tech_set_p2p_listen_channel,
+	.set_p2p_go_intent = tech_set_p2p_go_intent,
+	.set_p2p_listen = tech_set_p2p_listen,
+	.set_p2p_listen_params = tech_set_p2p_listen_params,
+	.set_p2p_go = tech_set_p2p_go,
+	.remove_persistent_info = tech_remove_persistent_info,
+	.remove_persistent_info_all = tech_remove_persistent_info_all,
 };
 
-static void handle_tethering(struct wifi_data *wifi)
+static bool is_p2p_connecting(void)
 {
-	if (!wifi->tethering)
-		return;
-
-	if (!wifi->bridge)
-		return;
-
-	if (wifi->bridged)
-		return;
+	GList *list;
 
-	DBG("index %d bridge %s", wifi->index, wifi->bridge);
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
 
-	if (connman_inet_add_to_bridge(wifi->index, wifi->bridge) < 0)
-		return;
+		if (wifi->p2p_connecting)
+			return true;
+	}
 
-	wifi->bridged = true;
+	return false;
 }
 
-static void wifi_newlink(unsigned flags, unsigned change, void *user_data)
+static void enable_auto_connect_block(bool block)
 {
-	struct connman_device *device = user_data;
-	struct wifi_data *wifi = connman_device_get_data(device);
-
-	if (!wifi)
-		return;
-
-	DBG("index %d flags %d change %d", wifi->index, flags, change);
-
-	if ((wifi->flags & IFF_UP) != (flags & IFF_UP)) {
-		if (flags & IFF_UP)
-			DBG("interface up");
-		else
-			DBG("interface down");
+	DBG("block %d", block);
+	if (block)
+		block_auto_connect = true;
+	else {
+		block_auto_connect = false;
+		__connman_service_auto_connect(CONNMAN_SERVICE_CONNECT_REASON_AUTO);
 	}
+}
 
-	if ((wifi->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP)) {
-		if (flags & IFF_LOWER_UP) {
-			DBG("carrier on");
-
-			handle_tethering(wifi);
-		} else
-			DBG("carrier off");
-	}
+static void add_pending_wifi_device(struct wifi_data *wifi)
+{
+	if (g_list_find(pending_wifi_device, wifi))
+		return;
 
-	wifi->flags = flags;
+	pending_wifi_device = g_list_append(pending_wifi_device, wifi);
 }
 
-static int wifi_probe(struct connman_device *device)
+static struct wifi_data *get_pending_wifi_data(const char *ifname)
 {
-	struct wifi_data *wifi;
-
-	DBG("device %p", device);
+	GList *list;
 
-	wifi = g_try_new0(struct wifi_data, 1);
-	if (!wifi)
-		return -ENOMEM;
+	for (list = pending_wifi_device; list; list = list->next) {
+		struct wifi_data *wifi;
+		const char *dev_name;
 
-	wifi->state = G_SUPPLICANT_STATE_INACTIVE;
-	wifi->ap_supported = WIFI_AP_UNKNOWN;
-	wifi->tethering_param = NULL;
+		wifi = list->data;
+		if (!wifi || !wifi->device)
+			continue;
 
-	connman_device_set_data(device, wifi);
-	wifi->device = connman_device_ref(device);
+		dev_name = connman_device_get_string(wifi->device, "Interface");
+		if (!g_strcmp0(ifname, dev_name)) {
+			pending_wifi_device = g_list_delete_link(
+						pending_wifi_device, list);
+			return wifi;
+		}
+	}
 
-	wifi->index = connman_device_get_index(device);
-	wifi->flags = 0;
+	return NULL;
+}
 
-	wifi->watch = connman_rtnl_add_newlink_watch(wifi->index,
-							wifi_newlink, device);
+static void remove_pending_wifi_device(struct wifi_data *wifi)
+{
+	GList *link;
 
-	wifi->wps_active = FALSE;
+	link = g_list_find(pending_wifi_device, wifi);
 
-	if (is_p2p_connecting())
-		add_pending_wifi_device(wifi);
-	else
-		iface_list = g_list_append(iface_list, wifi);
+	if (!link)
+		return;
 
-	return 0;
+	pending_wifi_device = g_list_delete_link(pending_wifi_device, link);
 }
 
-static void remove_networks(struct connman_device *device,
-				struct wifi_data *wifi)
+static void peer_cancel_timeout(struct wifi_data *wifi)
 {
-	GSList *list;
+	if (wifi->p2p_connection_timeout > 0)
+		g_source_remove(wifi->p2p_connection_timeout);
 
-	for (list = wifi->networks; list; list = list->next) {
-		struct connman_network *network = list->data;
+	wifi->p2p_connection_timeout = 0;
+	wifi->p2p_connecting = false;
 
-		connman_device_remove_network(device, network);
-		connman_network_unref(network);
+	if (wifi->pending_peer) {
+		connman_peer_unref(wifi->pending_peer);
+		wifi->pending_peer = NULL;
 	}
-
-	g_slist_free(wifi->networks);
-	wifi->networks = NULL;
 }
 
-static void remove_peers(struct wifi_data *wifi)
+static gboolean peer_connect_timeout(gpointer data)
 {
-	GSList *list;
+	struct wifi_data *wifi = data;
 
-	for (list = wifi->peers; list; list = list->next) {
-		struct connman_peer *peer = list->data;
+	DBG("");
 
-		connman_peer_unregister(peer);
-		connman_peer_unref(peer);
+	if (wifi->p2p_connecting) {
+		enum connman_peer_state state = CONNMAN_PEER_STATE_FAILURE;
+		GSupplicantPeer *gs_peer =
+			g_supplicant_interface_peer_lookup(wifi->interface,
+				connman_peer_get_identifier(wifi->pending_peer));
+
+		if (g_supplicant_peer_has_requested_connection(gs_peer))
+			state = CONNMAN_PEER_STATE_IDLE;
+
+		connman_peer_set_state(wifi->pending_peer, state);
 	}
 
-	g_slist_free(wifi->peers);
-	wifi->peers = NULL;
+	peer_cancel_timeout(wifi);
+
+	return FALSE;
 }
 
-static void reset_autoscan(struct connman_device *device)
+static void peer_connect_callback(int result, GSupplicantInterface *interface,
+							void *user_data)
 {
-	struct wifi_data *wifi = connman_device_get_data(device);
-	struct autoscan_params *autoscan;
+	struct wifi_data *wifi = user_data;
+	struct connman_peer *peer = wifi->pending_peer;
 
-	DBG("");
+	DBG("peer %p - %d", peer, result);
 
-	if (!wifi || !wifi->autoscan)
+	if (!peer)
 		return;
 
-	autoscan = wifi->autoscan;
-
-	autoscan->interval = 0;
-
-	if (autoscan->timeout == 0)
+	if (result < 0) {
+		peer_connect_timeout(wifi);
 		return;
+	}
 
-	g_source_remove(autoscan->timeout);
-	autoscan->timeout = 0;
+	connman_peer_set_state(peer, CONNMAN_PEER_STATE_ASSOCIATION);
 
-	connman_device_unref(device);
+	wifi->p2p_connection_timeout = g_timeout_add_seconds(
+						P2P_CONNECTION_TIMEOUT,
+						peer_connect_timeout, wifi);
 }
 
-static void stop_autoscan(struct connman_device *device)
+static int peer_connect(struct connman_peer *peer,
+			enum connman_peer_wps_method wps_method,
+			const char *wps_pin)
 {
-	const struct wifi_data *wifi = connman_device_get_data(device);
+	struct connman_device *device = connman_peer_get_device(peer);
+	GSupplicantPeerParams *peer_params;
+	GSupplicantPeer *gs_peer;
+	struct wifi_data *wifi;
+	bool pbc, pin;
+	int ret;
 
-	if (!wifi || !wifi->autoscan)
-		return;
+	DBG("peer %p", peer);
 
-	reset_autoscan(device);
+	if (!device)
+		return -ENODEV;
 
-	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_WIFI, false);
-}
+	wifi = connman_device_get_data(device);
+	if (!wifi || !wifi->interface)
+		return -ENODEV;
 
-static void check_p2p_technology(void)
-{
-	bool p2p_exists = false;
-	GList *list;
+	if (wifi->p2p_connecting)
+		return -EBUSY;
 
-	for (list = iface_list; list; list = list->next) {
-		struct wifi_data *w = list->data;
+	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
+					connman_peer_get_identifier(peer));
+	if (!gs_peer)
+		return -EINVAL;
 
-		if (w->interface &&
-				g_supplicant_interface_has_p2p(w->interface))
-			p2p_exists = true;
+	pbc = g_supplicant_peer_is_wps_pbc(gs_peer);
+	pin = g_supplicant_peer_is_wps_pin(gs_peer);
+
+	switch (wps_method) {
+	case CONNMAN_PEER_WPS_UNKNOWN:
+		if ((pbc && pin) || pin)
+			return -ENOKEY;
+		break;
+	case CONNMAN_PEER_WPS_PBC:
+		if (!pbc)
+			return -EINVAL;
+		wps_pin = NULL;
+		break;
+	case CONNMAN_PEER_WPS_PIN:
+		if (!pin || !wps_pin)
+			return -EINVAL;
+		break;
 	}
 
-	if (!p2p_exists) {
-		connman_technology_driver_unregister(&p2p_tech_driver);
-		connman_peer_driver_unregister(&peer_driver);
+	if (connman_technology_get_p2p_listen(p2p_technology)) {
+		leave_p2p_listen_on_iface(wifi);
+		connman_technology_set_p2p_listen(p2p_technology, false);
 	}
-}
 
-static void wifi_remove(struct connman_device *device)
-{
-	struct wifi_data *wifi = connman_device_get_data(device);
+	if(p2p_go_identifier != NULL) {
+			struct connman_network *network;
+			const char *wp_pin = NULL;
 
-	DBG("device %p wifi %p", device, wifi);
+			struct connman_group * group = __connman_group_lookup_from_ident(p2p_go_identifier);
+			const char *identifier = connman_peer_get_identifier(peer);
 
-	if (!wifi)
-		return;
+			network = connman_device_get_network(wifi->device, identifier);
 
-	stop_autoscan(device);
+			if(group != NULL) {
+				GSupplicantP2PWPSParams *wps_params = NULL;
 
-	if (wifi->p2p_device)
-		p2p_iface_list = g_list_remove(p2p_iface_list, wifi);
-	else
-		iface_list = g_list_remove(iface_list, wifi);
+				wps_params = g_try_malloc0(sizeof(GSupplicantP2PWPSParams));
+				if(wps_params == NULL)
+					return -ENOMEM;
 
-	check_p2p_technology();
+				if (network != NULL)
+					wp_pin = connman_network_get_string(network, "WiFi.PinWPS");
 
-	remove_pending_wifi_device(wifi);
+				wps_params->role = "enrollee";
+				if(wp_pin == NULL) {
+					wps_params->type = "pbc";
+					wps_params->p2p_dev_addr = identifier;
+				} else {
+					wps_params->type = "pin";
+					wps_params->pin = wp_pin;
+				}
 
-	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_P2P)) {
-		g_source_remove(wifi->p2p_find_timeout);
-		connman_device_unref(wifi->device);
-	}
+				ret = __connman_group_accept_connection(group, wps_params);
 
-	if (wifi->p2p_connection_timeout)
-		g_source_remove(wifi->p2p_connection_timeout);
+				if(ret == -EINPROGRESS) {
+					wifi->pending_peer = connman_peer_ref(peer);
+					wifi->p2p_connecting = true;
+				}
 
-	remove_networks(device, wifi);
-	remove_peers(wifi);
+				return ret;
+			} else
+				return -ENOMEM;
+	}
 
-	connman_device_set_powered(device, false);
-	connman_device_set_data(device, NULL);
-	connman_device_unref(wifi->device);
-	connman_rtnl_remove_watch(wifi->watch);
+	peer_params = g_try_malloc0(sizeof(GSupplicantPeerParams));
+	if (!peer_params)
+		return -ENOMEM;
 
-	g_supplicant_interface_set_data(wifi->interface, NULL);
+	peer_params->path = g_strdup(g_supplicant_peer_get_path(gs_peer));
+	if (wps_pin)
+		peer_params->wps_pin = g_strdup(wps_pin);
 
-	g_supplicant_interface_cancel(wifi->interface);
+	peer_params->master = connman_peer_service_is_master();
+	peer_params->authorize_only= FALSE;
+	peer_params->join = FALSE;
 
-	if (wifi->scan_params)
-		g_supplicant_free_scan_params(wifi->scan_params);
+	peer_params->go_intent = wifi->p2p_device_config.go_intent;
+	if(connman_technology_get_p2p_persistent(p2p_technology))
+		peer_params->persistent = TRUE;
+	else
+		peer_params->persistent = FALSE;
+
+	const char* connman_peer_path = __connman_peer_get_path(peer);
+
+	if (wifi->pin_requested_path && g_str_equal(wifi->pin_requested_path, connman_peer_path)
+		&& wifi->generated_pin) {
+		wps_method = CONNMAN_PEER_WPS_DISPLAY;
+		wifi->pin_requested_path = NULL;
+	} else if (wifi->invited_path && g_str_equal(wifi->invited_path, connman_peer_path)) {
+		wps_method = CONNMAN_PEER_WPS_DISPLAY;
+		peer_params->join = TRUE;
+		wifi->invited_path = NULL;
+	}
 
-	g_free(wifi->autoscan);
-	g_free(wifi->identifier);
-	g_free(wifi);
+	peer_params->wps_method= g_strdup(connman_peer_wps_method2string(wps_method));
+
+	ret = g_supplicant_interface_p2p_connect(wifi->interface, peer_params,
+						peer_connect_callback, wifi);
+	if (ret == -EINPROGRESS) {
+		wifi->pending_peer = connman_peer_ref(peer);
+		wifi->p2p_connecting = true;
+	} else if (ret < 0) {
+		g_free(peer_params->path);
+		g_free(peer_params->wps_pin);
+		g_free(peer_params->wps_method);
+		g_free(peer_params);
+	}
+
+	return ret;
 }
 
-static bool is_duplicate(GSList *list, gchar *ssid, int ssid_len)
+static void p2p_peers_refresh(struct wifi_data *wifi)
 {
-	GSList *iter;
+	GSupplicantInterface *interface = wifi->interface;
+	int err;
 
-	for (iter = list; iter; iter = g_slist_next(iter)) {
-		struct scan_ssid *scan_ssid = iter->data;
+	err = g_supplicant_interface_p2p_flush(interface, NULL, NULL);
 
-		if (ssid_len == scan_ssid->ssid_len &&
-				memcmp(ssid, scan_ssid->ssid, ssid_len) == 0)
-			return true;
+	if (!connman_technology_get_enable_p2p_listen(p2p_technology))
+		return;
+
+	//Do not p2p find from webOS 4.5 platform, since there is no WiFi Direct menu
+	// in settings, so no need to list the peers
+	// if(err == -EINPROGRESS)
+		//p2p_find(wifi->device);
+	if (__connman_get_connected_peer() == NULL && wifi->servicing){
+		leave_p2p_listen_on_iface(wifi);
 	}
 
-	return false;
+	err = apply_p2p_listen_on_iface(wifi, &params);
+	if (err == 0)
+		connman_technology_set_p2p_listen(p2p_technology, true);
 }
 
-static int add_scan_param(gchar *hex_ssid, char *raw_ssid, int ssid_len,
-			int freq, GSupplicantScanParams *scan_data,
-			int driver_max_scan_ssids, char *ssid_name)
+static int peer_disconnect(struct connman_peer *peer)
 {
-	unsigned int i;
-	struct scan_ssid *scan_ssid;
-
-	if ((driver_max_scan_ssids == 0 ||
-			driver_max_scan_ssids > scan_data->num_ssids) &&
-			(hex_ssid || raw_ssid)) {
-		gchar *ssid;
-		unsigned int j = 0, hex;
-
-		if (hex_ssid) {
-			size_t hex_ssid_len = strlen(hex_ssid);
+	struct connman_device *device = connman_peer_get_device(peer);
+	GSupplicantPeer *gs_peer;
+	struct wifi_data *wifi;
+	char* peer_path = NULL;
+	int ret;
 
-			ssid = g_try_malloc0(hex_ssid_len / 2);
-			if (!ssid)
-				return -ENOMEM;
+	DBG("peer %p", peer);
 
-			for (i = 0; i < hex_ssid_len; i += 2) {
-				sscanf(hex_ssid + i, "%02x", &hex);
-				ssid[j++] = hex;
-			}
-		} else {
-			ssid = raw_ssid;
-			j = ssid_len;
-		}
+	if (!device)
+		return -ENODEV;
 
-		/*
-		 * If we have already added hidden AP to the list,
-		 * then do not do it again. This might happen if you have
-		 * used or are using multiple wifi cards, so in that case
-		 * you might have multiple service files for same AP.
-		 */
-		if (is_duplicate(scan_data->ssids, ssid, j)) {
-			if (hex_ssid)
-				g_free(ssid);
-			return 0;
+	if (p2p_go_identifier) {
+		struct connman_group *connman_group;
+		bool autonomous;
+		connman_group = __connman_group_lookup_from_ident(p2p_go_identifier);
+		if (connman_group) {
+			autonomous = __connman_group_is_autonomous(connman_group);
+			if (autonomous)
+				return -ENOTSUP;
 		}
+	}
 
-		scan_ssid = g_try_new(struct scan_ssid, 1);
-		if (!scan_ssid) {
-			if (hex_ssid)
-				g_free(ssid);
-			return -ENOMEM;
-		}
+	wifi = connman_device_get_data(device);
+	if (!wifi)
+		return -ENODEV;
 
-		memcpy(scan_ssid->ssid, ssid, j);
-		scan_ssid->ssid_len = j;
-		scan_data->ssids = g_slist_prepend(scan_data->ssids,
-								scan_ssid);
+	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
+					connman_peer_get_identifier(peer));
+	if (!gs_peer)
+		return -EINVAL;
 
-		scan_data->num_ssids++;
+	peer_path = g_strdup(g_supplicant_peer_get_path(gs_peer));
 
-		DBG("SSID %s added to scanned list of %d entries", ssid_name,
-							scan_data->num_ssids);
+	ret = g_supplicant_interface_p2p_client_remove(wifi->interface, NULL, peer_path);
+	g_free(peer_path);
 
-		if (hex_ssid)
-			g_free(ssid);
-	} else
-		return -EINVAL;
+	if (ret == -EINPROGRESS) {
+		peer_cancel_timeout(wifi);
+		wifi->p2p_device = false;
+		__connman_peer_set_static_ip(peer, NULL);
+	}
 
-	scan_data->ssids = g_slist_reverse(scan_data->ssids);
+	if (!__connman_get_connected_peer())
+		p2p_peers_refresh(wifi);
 
-	if (!scan_data->freqs) {
-		scan_data->freqs = g_try_malloc0(sizeof(uint16_t));
-		if (!scan_data->freqs) {
-			g_slist_free_full(scan_data->ssids, g_free);
-			return -ENOMEM;
-		}
+	return ret;
+}
 
-		scan_data->num_freqs = 1;
-		scan_data->freqs[0] = freq;
-	} else {
-		bool duplicate = false;
+static gboolean timeout_p2p_listen_state(gpointer user_data)
+{
+	GSupplicantInterface *interface = user_data;
 
-		/* Don't add duplicate entries */
-		for (i = 0; i < scan_data->num_freqs; i++) {
-			if (scan_data->freqs[i] == freq) {
-				duplicate = true;
-				break;
-			}
-		}
+	p2p_listen_ref = -1;
 
-		if (!duplicate) {
-			scan_data->num_freqs++;
-			scan_data->freqs = g_try_realloc(scan_data->freqs,
-				sizeof(uint16_t) * scan_data->num_freqs);
-			if (!scan_data->freqs) {
-				g_slist_free_full(scan_data->ssids, g_free);
-				return -ENOMEM;
-			}
-			scan_data->freqs[scan_data->num_freqs - 1] = freq;
-		}
-	}
+	if (connman_technology_get_p2p_listen(p2p_technology) == false &&
+			!__connman_peer_get_connected_exists())
+		tech_set_p2p_listen(p2p_technology, true);
 
-	return 1;
+	return FALSE;
 }
 
-static int get_hidden_connections(GSupplicantScanParams *scan_data)
+static void reject_peer_callback(int result, GSupplicantInterface *interface,
+								void *user_data)
 {
-	struct connman_config_entry **entries;
-	GKeyFile *keyfile;
-	gchar **services;
-	char *ssid, *name;
-	int i, ret;
-	bool value;
-	int num_ssids = 0, add_param_failed = 0;
+	struct connman_peer *peer= user_data;
 
-	services = connman_storage_get_services();
-	for (i = 0; services && services[i]; i++) {
-		if (strncmp(services[i], "wifi_", 5) != 0)
-			continue;
+	DBG("result %d supplicant interface %p peer %p",
+			result, interface, peer);
 
-		keyfile = connman_storage_load_service(services[i]);
-		if (!keyfile)
-			continue;
+	if (result < 0)
+		return;
 
-		value = g_key_file_get_boolean(keyfile,
-					services[i], "Hidden", NULL);
-		if (!value) {
-			g_key_file_free(keyfile);
-			continue;
-		}
+	/*
+	 * Current wpa_supplicant does not supports to emit the signal which is
+	 * P2P negotiation failure when calling RejectPeer().
+	 * To do this, we should call dummy Connect() after RejectPeer().
+	 */
+	peer_connect(peer, CONNMAN_PEER_WPS_PBC, "");
 
-		value = g_key_file_get_boolean(keyfile,
-					services[i], "Favorite", NULL);
-		if (!value) {
-			g_key_file_free(keyfile);
-			continue;
-		}
+	if (p2p_listen_ref != -1)
+		g_source_remove(p2p_listen_ref);
 
-		ssid = g_key_file_get_string(keyfile,
-					services[i], "SSID", NULL);
+	p2p_listen_ref = g_timeout_add(3000, timeout_p2p_listen_state, interface);
+}
 
-		name = g_key_file_get_string(keyfile, services[i], "Name",
-								NULL);
+static int peer_reject(struct connman_peer *peer)
+{
+	struct connman_device *device = connman_peer_get_device(peer);
+	GSupplicantPeerParams peer_params = {};
+	GSupplicantPeer *gs_peer;
+	struct wifi_data *wifi;
+	int ret;
 
-		ret = add_scan_param(ssid, NULL, 0, 0, scan_data, 0, name);
-		if (ret < 0)
-			add_param_failed++;
-		else if (ret > 0)
-			num_ssids++;
+	DBG("peer %p", peer);
 
-		g_free(ssid);
-		g_free(name);
-		g_key_file_free(keyfile);
-	}
+	if (!device)
+		return -ENODEV;
 
-	/*
-	 * Check if there are any hidden AP that needs to be provisioned.
-	 */
-	entries = connman_config_get_entries("wifi");
-	for (i = 0; entries && entries[i]; i++) {
-		int len;
+	wifi = connman_device_get_data(device);
+	if (!wifi)
+		return -ENODEV;
 
-		if (!entries[i]->hidden)
-			continue;
+	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
+					connman_peer_get_identifier(peer));
+	if (!gs_peer)
+		return -EINVAL;
 
-		if (!entries[i]->ssid) {
-			ssid = entries[i]->name;
-			len = strlen(ssid);
-		} else {
-			ssid = entries[i]->ssid;
-			len = entries[i]->ssid_len;
-		}
+	peer_params.path = g_strdup(g_supplicant_peer_get_path(gs_peer));
 
-		if (!ssid)
-			continue;
+	ret = g_supplicant_interface_p2p_reject(wifi->interface,
+							&peer_params, reject_peer_callback, peer);
+	g_free(peer_params.path);
 
-		ret = add_scan_param(NULL, ssid, len, 0, scan_data, 0, ssid);
-		if (ret < 0)
-			add_param_failed++;
-		else if (ret > 0)
-			num_ssids++;
+	if (ret == -EINPROGRESS) {
+		wifi->p2p_device = false;
 	}
 
-	connman_config_free_entries(entries);
+	return ret;
+}
 
-	if (add_param_failed > 0)
-		DBG("Unable to scan %d out of %d SSIDs",
-					add_param_failed, num_ssids);
+struct peer_service_registration {
+	peer_service_registration_cb_t callback;
+	void *user_data;
+};
 
-	g_strfreev(services);
+static bool is_service_wfd(const unsigned char *specs, int length)
+{
+	if (length < 9 || specs[0] != 0 || specs[1] != 0 || specs[2] != 6)
+		return false;
 
-	return num_ssids;
+	return true;
 }
 
-static int get_hidden_connections_params(struct wifi_data *wifi,
-					GSupplicantScanParams *scan_params)
+static void apply_p2p_listen_callback(int result, GSupplicantInterface *interface, void *user_data)
 {
-	int driver_max_ssids, i;
-	GSupplicantScanParams *orig_params;
-
-	/*
-	 * Scan hidden networks so that we can autoconnect to them.
-	 * We will assume 1 as a default number of ssid to scan.
-	 */
-	driver_max_ssids = g_supplicant_interface_get_max_scan_ssids(
-							wifi->interface);
-	if (driver_max_ssids == 0)
-		driver_max_ssids = 1;
-
-	DBG("max ssids %d", driver_max_ssids);
-
-	if (!wifi->scan_params) {
-		wifi->scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
-		if (!wifi->scan_params)
-			return 0;
-
-		if (get_hidden_connections(wifi->scan_params) == 0) {
-			g_supplicant_free_scan_params(wifi->scan_params);
-			wifi->scan_params = NULL;
+	struct wifi_data *wifi = user_data;
 
-			return 0;
-		}
+	if (result < 0) {
+		connman_info("p2p extended listen set failed(%d)", result);
+		wifi->servicing--;
 	}
+}
 
-	orig_params = wifi->scan_params;
-
-	/* Let's transfer driver_max_ssids params */
-	for (i = 0; i < driver_max_ssids; i++) {
-		struct scan_ssid *ssid;
-
-		if (!wifi->scan_params->ssids)
-			break;
+static int apply_p2p_listen_on_iface(gpointer data, gpointer user_data)
+{
+	int err = 0;
+	struct wifi_data *wifi = data;
+	struct p2p_listen_data* listenParams = user_data;
 
-		ssid = orig_params->ssids->data;
-		orig_params->ssids = g_slist_remove(orig_params->ssids, ssid);
-		scan_params->ssids = g_slist_prepend(scan_params->ssids, ssid);
-	}
+	if (!listenParams)
+		return -EINVAL;
 
-	if (i > 0) {
-		scan_params->num_ssids = i;
-		scan_params->ssids = g_slist_reverse(scan_params->ssids);
+	if (!wifi->interface ||
+			!g_supplicant_interface_has_p2p(wifi->interface))
+		return -ENODEV;
 
-		scan_params->freqs = g_memdup(orig_params->freqs,
-				sizeof(uint16_t) * orig_params->num_freqs);
-		if (!scan_params->freqs)
-			goto err;
+	if (connman_setting_get_bool("SupportP2P0Interface") &&
+		g_strcmp0(connman_device_get_string(wifi->device, "Interface"),
+				connman_option_get_string("P2PDevice")) != 0)
+		return -EOPNOTSUPP;
 
-		scan_params->num_freqs = orig_params->num_freqs;
+	if (__connman_group_exist())
+		return -EALREADY;
 
-	} else
-		goto err;
+	if (!wifi->servicing) {
+		err = g_supplicant_interface_p2p_listen(wifi->interface,
+				listenParams->period, listenParams->interval, apply_p2p_listen_callback, wifi);
 
-	orig_params->num_ssids -= scan_params->num_ssids;
+		wifi->servicing++;
+	}
+	return err;
+}
 
-	return scan_params->num_ssids;
+static void leave_p2p_listen_on_iface(gpointer data)
+{
+	struct wifi_data *wifi = data;
+	if (!wifi->interface ||
+			!g_supplicant_interface_has_p2p(wifi->interface))
+		return;
 
-err:
-	g_slist_free_full(scan_params->ssids, g_free);
-	g_supplicant_free_scan_params(wifi->scan_params);
-	wifi->scan_params = NULL;
+	if (connman_setting_get_bool("SupportP2P0Interface") &&
+		g_strcmp0(connman_device_get_string(wifi->device, "Interface"),
+				connman_option_get_string("P2PDevice")) != 0)
+		return;
 
-	return 0;
+	wifi->servicing--;
+	if (!wifi->servicing || wifi->servicing < 0) {
+		g_supplicant_interface_p2p_listen(wifi->interface, 0, 0, NULL, wifi);
+		wifi->servicing = 0;
+	}
 }
 
-static int throw_wifi_scan(struct connman_device *device,
-			GSupplicantInterfaceCallback callback)
+static void register_wfd_service_cb(int result,
+				GSupplicantInterface *iface, void *user_data)
 {
-	struct wifi_data *wifi = connman_device_get_data(device);
-	int ret;
+	struct peer_service_registration *reg_data = user_data;
 
-	if (!wifi)
-		return -ENODEV;
+	DBG("");
 
-	DBG("device %p %p", device, wifi->interface);
+	if (reg_data && reg_data->callback) {
+		reg_data->callback(result, reg_data->user_data);
+		g_free(reg_data);
+	}
+}
 
-	if (wifi->tethering)
-		return -EBUSY;
+static GSupplicantP2PServiceParams *fill_in_peer_service_params(
+				const unsigned char *spec,
+				int spec_length, const unsigned char *query,
+				int query_length, int version)
+{
+	GSupplicantP2PServiceParams *params;
 
-	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI))
-		return -EALREADY;
+	params = g_try_malloc0(sizeof(GSupplicantP2PServiceParams));
+	if (!params)
+		return NULL;
 
-	connman_device_ref(device);
+	if (version > 0) {
+		params->version = version;
+		params->service = g_memdup(spec, spec_length);
+	} else if (query_length > 0 && spec_length > 0) {
+		params->query = g_memdup(query, query_length);
+		params->query_length = query_length;
 
-	ret = g_supplicant_interface_scan(wifi->interface, NULL,
-						callback, device);
-	if (ret == 0) {
-		connman_device_set_scanning(device,
-				CONNMAN_SERVICE_TYPE_WIFI, true);
-	} else
-		connman_device_unref(device);
+		params->response = g_memdup(spec, spec_length);
+		params->response_length = spec_length;
+	} else {
+		params->wfd_ies = g_memdup(spec, spec_length);
+		params->wfd_ies_length = spec_length;
+	}
 
-	return ret;
+	return params;
 }
 
-static void hidden_free(struct hidden_params *hidden)
+static void free_peer_service_params(GSupplicantP2PServiceParams *params)
 {
-	if (!hidden)
+	if (!params)
 		return;
 
-	if (hidden->scan_params)
-		g_supplicant_free_scan_params(hidden->scan_params);
-	g_free(hidden->identity);
-	g_free(hidden->passphrase);
-	g_free(hidden->security);
-	g_free(hidden);
+	g_free(params->service);
+	g_free(params->query);
+	g_free(params->response);
+	g_free(params->wfd_ies);
+
+	g_free(params);
 }
 
-static void scan_callback(int result, GSupplicantInterface *interface,
-						void *user_data)
+static int peer_register_wfd_service(const unsigned char *specification,
+				int specification_length,
+				peer_service_registration_cb_t callback,
+				void *user_data)
 {
-	struct connman_device *device = user_data;
-	struct wifi_data *wifi = connman_device_get_data(device);
-	bool scanning;
-
-	DBG("result %d wifi %p", result, wifi);
+	struct peer_service_registration *reg_data = NULL;
+	static GSupplicantP2PServiceParams *params;
+	int ret;
 
-	if (wifi) {
-		if (wifi->hidden && !wifi->postpone_hidden) {
-			connman_network_clear_hidden(wifi->hidden->user_data);
-			hidden_free(wifi->hidden);
-			wifi->hidden = NULL;
-		}
+	DBG("");
 
-		if (wifi->scan_params) {
-			g_supplicant_free_scan_params(wifi->scan_params);
-			wifi->scan_params = NULL;
-		}
-	}
+	if (wfd_service_registered)
+		return -EBUSY;
 
-	if (result < 0)
-		connman_device_reset_scanning(device);
+	params = fill_in_peer_service_params(specification,
+					specification_length, NULL, 0, 0);
+	if (!params)
+		return -ENOMEM;
 
-	/* User is connecting to a hidden AP, let's wait for finished event */
-	if (wifi && wifi->hidden && wifi->postpone_hidden) {
-		GSupplicantScanParams *scan_params;
-		int ret;
+	reg_data = g_try_malloc0(sizeof(*reg_data));
+	if (!reg_data) {
+		ret = -ENOMEM;
+		goto error;
+	}
 
-		wifi->postpone_hidden = false;
-		scan_params = wifi->hidden->scan_params;
-		wifi->hidden->scan_params = NULL;
+	reg_data->callback = callback;
+	reg_data->user_data = user_data;
 
-		reset_autoscan(device);
+	ret = g_supplicant_set_widi_ies(params,
+					register_wfd_service_cb, reg_data);
+	if (ret < 0 && ret != -EINPROGRESS)
+		goto error;
 
-		ret = g_supplicant_interface_scan(wifi->interface, scan_params,
-							scan_callback, device);
-		if (ret == 0)
-			return;
+	wfd_service_registered = true;
 
-		/* On error, let's recall scan_callback, which will cleanup */
-		return scan_callback(ret, interface, user_data);
-	}
+	return ret;
+error:
+	free_peer_service_params(params);
+	g_free(reg_data);
 
-	scanning = connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI);
+	return ret;
+}
 
-	if (scanning) {
-		connman_device_set_scanning(device,
-				CONNMAN_SERVICE_TYPE_WIFI, false);
-	}
+static void register_peer_service_cb(int result,
+				GSupplicantInterface *iface, void *user_data)
+{
+	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct peer_service_registration *reg_data = user_data;
+	int ret = 0;
 
-	if (result != -ENOLINK)
-		start_autoscan(device);
+	DBG("");
 
-	/*
-	 * If we are here then we were scanning; however, if we are
-	 * also mid-flight disabling the interface, then wifi_disable
-	 * has already cleared the device scanning state and
-	 * unreferenced the device, obviating the need to do it here.
-	 */
+	if (reg_data->callback)
+		reg_data->callback(result, reg_data->user_data);
 
-	if (scanning)
-		connman_device_unref(device);
+	g_free(reg_data);
 }
 
-static void scan_callback_hidden(int result,
-			GSupplicantInterface *interface, void *user_data)
+static int peer_register_service(const unsigned char *specification,
+				int specification_length,
+				const unsigned char *query,
+				int query_length, int version,
+				peer_service_registration_cb_t callback,
+				void *user_data)
 {
-	struct connman_device *device = user_data;
-	struct wifi_data *wifi = connman_device_get_data(device);
-	GSupplicantScanParams *scan_params;
-	int ret;
+	struct peer_service_registration *reg_data = NULL;
+	GSupplicantP2PServiceParams *params;
+	bool found = false;
+	int ret, ret_f;
+	GList *list;
 
-	DBG("result %d wifi %p", result, wifi);
+	DBG("");
 
-	if (!wifi)
-		goto out;
+	if (specification && !version && !query &&
+			is_service_wfd(specification, specification_length)) {
+		return peer_register_wfd_service(specification,
+				specification_length, callback, user_data);
+	}
 
-	/* User is trying to connect to a hidden AP */
-	if (wifi->hidden && wifi->postpone_hidden)
-		goto out;
+	reg_data = g_try_malloc0(sizeof(*reg_data));
+	if (!reg_data)
+		return -ENOMEM;
 
-	scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
-	if (!scan_params)
-		goto out;
+	reg_data->callback = callback;
+	reg_data->user_data = user_data;
 
-	if (get_hidden_connections_params(wifi, scan_params) > 0) {
-		ret = g_supplicant_interface_scan(wifi->interface,
-							scan_params,
-							scan_callback_hidden,
-							device);
-		if (ret == 0)
-			return;
+	ret_f = -EOPNOTSUPP;
+
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
+
+		if (!g_supplicant_interface_has_p2p(iface))
+			continue;
+
+		params = fill_in_peer_service_params(specification,
+						specification_length, query,
+						query_length, version);
+		if (!params) {
+			ret_f = -ENOMEM;
+			continue;
+		}
+
+		if (!found) {
+			ret_f = g_supplicant_interface_p2p_add_service(iface,
+				register_peer_service_cb, params, reg_data);
+			if (ret_f == 0 || ret_f == -EINPROGRESS)
+				found = true;
+			ret = ret_f;
+		} else
+			ret = g_supplicant_interface_p2p_add_service(iface,
+				register_peer_service_cb, params, NULL);
+		if (ret != 0 && ret != -EINPROGRESS)
+			free_peer_service_params(params);
 	}
 
-	g_supplicant_free_scan_params(scan_params);
+	if(ret_f != -EINPROGRESS && reg_data)
+		g_free(reg_data);
 
-out:
-	scan_callback(result, interface, user_data);
+	return ret_f;
 }
 
-static gboolean autoscan_timeout(gpointer data)
+static int peer_unregister_wfd_service(void)
 {
-	struct connman_device *device = data;
-	struct wifi_data *wifi = connman_device_get_data(device);
-	struct autoscan_params *autoscan;
-	int interval;
-
-	if (!wifi)
-		return FALSE;
+	GSupplicantP2PServiceParams *params;
+	GList *list;
 
-	autoscan = wifi->autoscan;
+	if (!wfd_service_registered)
+		return -EALREADY;
 
-	if (autoscan->interval <= 0) {
-		interval = autoscan->base;
-		goto set_interval;
-	} else
-		interval = autoscan->interval * autoscan->base;
+	params = fill_in_peer_service_params(NULL, 0, NULL, 0, 0);
+	if (!params)
+		return -ENOMEM;
 
-	if (interval > autoscan->limit)
-		interval = autoscan->limit;
+	wfd_service_registered = false;
 
-	throw_wifi_scan(wifi->device, scan_callback_hidden);
+	g_supplicant_set_widi_ies(params, NULL, NULL);
 
-	/*
-	 * In case BackgroundScanning is disabled, interval will reach the
-	 * limit exactly after the very first passive scanning. It allows
-	 * to ensure at most one passive scan is performed in such cases.
-	 */
-	if (!connman_setting_get_bool("BackgroundScanning") &&
-					interval == autoscan->limit) {
-		g_source_remove(autoscan->timeout);
-		autoscan->timeout = 0;
+	return 0;
+}
 
-		connman_device_unref(device);
+static int peer_unregister_service(const unsigned char *specification,
+						int specification_length,
+						const unsigned char *query,
+						int query_length, int version)
+{
+	GSupplicantP2PServiceParams *params;
+	bool wfd = false;
+	GList *list;
+	int ret;
 
-		return FALSE;
+	if (specification && !version && !query &&
+			is_service_wfd(specification, specification_length)) {
+		ret = peer_unregister_wfd_service();
+		if (ret != 0 && ret != -EINPROGRESS)
+			return ret;
+		wfd = true;
 	}
 
-set_interval:
-	DBG("interval %d", interval);
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *wifi = list->data;
+		GSupplicantInterface *iface = wifi->interface;
 
-	autoscan->interval = interval;
+		if (wfd)
+			continue;
 
-	autoscan->timeout = g_timeout_add_seconds(interval,
-						autoscan_timeout, device);
+		if (!g_supplicant_interface_has_p2p(iface))
+			continue;
 
-	return FALSE;
-}
+		params = fill_in_peer_service_params(specification,
+						specification_length, query,
+						query_length, version);
+		if (!params) {
+			continue;
+		}
 
-static void start_autoscan(struct connman_device *device)
-{
-	struct wifi_data *wifi = connman_device_get_data(device);
-	struct autoscan_params *autoscan;
+		ret = g_supplicant_interface_p2p_del_service(iface, params);
+		if (ret != 0 && ret != -EINPROGRESS)
+			free_peer_service_params(params);
+	}
 
-	DBG("");
+	return 0;
+}
 
-	if (!wifi)
-		return;
+static struct connman_peer_driver peer_driver = {
+	.connect    = peer_connect,
+	.disconnect = peer_disconnect,
+	.register_service = peer_register_service,
+	.unregister_service = peer_unregister_service,
+	.reject = peer_reject,
+};
 
-	if (wifi->p2p_device)
+static void handle_tethering(struct wifi_data *wifi)
+{
+	if (!wifi->tethering)
 		return;
 
-	if (wifi->connected)
+	if (!wifi->bridge)
 		return;
 
-	autoscan = wifi->autoscan;
-	if (!autoscan)
+	if (wifi->bridged)
 		return;
 
-	if (autoscan->timeout > 0 || autoscan->interval > 0)
-		return;
+	DBG("index %d bridge %s", wifi->index, wifi->bridge);
 
-	connman_device_ref(device);
+	if (connman_inet_add_to_bridge(wifi->index, wifi->bridge) < 0)
+		return;
 
-	autoscan_timeout(device);
+	wifi->bridged = true;
 }
 
-static struct autoscan_params *parse_autoscan_params(const char *params)
+static void wifi_newlink(unsigned flags, unsigned change, void *user_data)
 {
-	struct autoscan_params *autoscan;
-	char **list_params;
-	int limit;
-	int base;
+	struct connman_device *device = user_data;
+	struct wifi_data *wifi = connman_device_get_data(device);
 
-	DBG("");
+	if (!wifi)
+		return;
 
-	list_params = g_strsplit(params, ":", 0);
-	if (list_params == 0)
-		return NULL;
+	DBG("index %d flags %d change %d", wifi->index, flags, change);
 
-	if (!g_strcmp0(list_params[0], "exponential") &&
-				g_strv_length(list_params) == 3) {
-		base = atoi(list_params[1]);
-		limit = atoi(list_params[2]);
-	} else if (!g_strcmp0(list_params[0], "single") &&
-				g_strv_length(list_params) == 2)
-		base = limit = atoi(list_params[1]);
-	else {
-		g_strfreev(list_params);
-		return NULL;
+	if ((wifi->flags & IFF_UP) != (flags & IFF_UP)) {
+		if (flags & IFF_UP)
+			DBG("interface up");
+		else
+			DBG("interface down");
 	}
 
-	DBG("Setup %s autoscanning", list_params[0]);
-
-	g_strfreev(list_params);
+	if ((wifi->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP)) {
+		if (flags & IFF_LOWER_UP) {
+			DBG("carrier on");
 
-	autoscan = g_try_malloc0(sizeof(struct autoscan_params));
-	if (!autoscan) {
-		DBG("Could not allocate memory for autoscan");
-		return NULL;
+			handle_tethering(wifi);
+		} else
+			DBG("carrier off");
 	}
 
-	DBG("base %d - limit %d", base, limit);
-	autoscan->base = base;
-	autoscan->limit = limit;
-
-	return autoscan;
+	wifi->flags = flags;
 }
 
-static void setup_autoscan(struct wifi_data *wifi)
+static int wifi_probe(struct connman_device *device)
 {
-	/*
-	 * If BackgroundScanning is enabled, setup exponential
-	 * autoscanning if it has not been previously done.
-	 */
-	if (connman_setting_get_bool("BackgroundScanning")) {
-		wifi->autoscan = parse_autoscan_params(AUTOSCAN_EXPONENTIAL);
-		return;
-	}
-
-	/*
-	 * On the contrary, if BackgroundScanning is disabled, update autoscan
-	 * parameters based on the type of scanning that is being performed.
-	 */
-	if (wifi->autoscan) {
-		g_free(wifi->autoscan);
-		wifi->autoscan = NULL;
-	}
+	struct wifi_data *wifi;
 
-	switch (wifi->scanning_type) {
-	case WIFI_SCANNING_PASSIVE:
-		/* Do not setup autoscan. */
-		break;
-	case WIFI_SCANNING_ACTIVE:
-		/* Setup one single passive scan after active. */
-		wifi->autoscan = parse_autoscan_params(AUTOSCAN_SINGLE);
-		break;
-	case WIFI_SCANNING_UNKNOWN:
-		/* Setup autoscan in this case but we should never fall here. */
-		wifi->autoscan = parse_autoscan_params(AUTOSCAN_SINGLE);
-		break;
-	}
-}
+	DBG("device %p", device);
 
-static void finalize_interface_creation(struct wifi_data *wifi)
-{
-	DBG("interface is ready wifi %p tethering %d", wifi, wifi->tethering);
+	wifi = g_try_new0(struct wifi_data, 1);
+	if (!wifi)
+		return -ENOMEM;
 
-	if (!wifi->device) {
-		connman_error("WiFi device not set");
-		return;
-	}
+	wifi->state = G_SUPPLICANT_STATE_INACTIVE;
+	wifi->ap_supported = WIFI_AP_UNKNOWN;
+	wifi->tethering_param = NULL;
 
-	connman_device_set_powered(wifi->device, true);
+	connman_device_set_data(device, wifi);
+	wifi->device = connman_device_ref(device);
 
-	if (wifi->p2p_device)
-		return;
+	wifi->index = connman_device_get_index(device);
+	wifi->flags = 0;
 
-	if (!wifi->autoscan)
-		setup_autoscan(wifi);
+	wifi->watch = connman_rtnl_add_newlink_watch(wifi->index,
+							wifi_newlink, device);
 
-	start_autoscan(wifi->device);
+	wifi->p2p_listen_suppressed = false;
+	wifi->wps_active = FALSE;
+
+	if (is_p2p_connecting())
+		add_pending_wifi_device(wifi);
+	else
+		iface_list = g_list_append(iface_list, wifi);
+
+	return 0;
 }
 
-static void interface_create_callback(int result,
-					GSupplicantInterface *interface,
-							void *user_data)
+static void remove_networks(struct connman_device *device,
+				struct wifi_data *wifi)
 {
-	struct wifi_data *wifi = user_data;
+	GSList *list;
 
-	DBG("result %d ifname %s, wifi %p", result,
-				g_supplicant_interface_get_ifname(interface),
-				wifi);
+	for (list = wifi->networks; list; list = list->next) {
+		struct connman_network *network = list->data;
 
-	if (result < 0 || !wifi)
-		return;
+		connman_device_remove_network(device, network);
+		connman_network_unref(network);
+	}
 
-	wifi->interface = interface;
-	g_supplicant_interface_set_data(interface, wifi);
+	g_slist_free(wifi->networks);
+	wifi->networks = NULL;
+}
 
-	if (g_supplicant_interface_get_ready(interface)) {
-		wifi->interface_ready = true;
-		finalize_interface_creation(wifi);
+static void remove_peers(struct wifi_data *wifi)
+{
+	GSList *list;
+	DBG("");
+
+	for (list = wifi->peers; list; list = list->next) {
+		struct connman_peer *peer = list->data;
+
+		connman_peer_unregister(peer);
+		connman_peer_unref(peer);
 	}
+
+	g_slist_free(wifi->peers);
+	wifi->peers = NULL;
 }
 
-static int wifi_enable(struct connman_device *device)
+static void reset_autoscan(struct connman_device *device)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
-	int index;
-	char *interface;
-	const char *driver = connman_option_get_string("wifi");
-	int ret;
+	struct autoscan_params *autoscan;
 
-	DBG("device %p %p", device, wifi);
+	DBG("");
 
-	index = connman_device_get_index(device);
-	if (!wifi || index < 0)
-		return -ENODEV;
+	if (!wifi || !wifi->autoscan)
+		return;
 
-	if (is_p2p_connecting())
-		return -EINPROGRESS;
+	autoscan = wifi->autoscan;
 
-	interface = connman_inet_ifname(index);
-	const char *wpas_config_file = connman_setting_get_string("WpaSupplicantConfigFile");
-	ret = g_supplicant_interface_create(interface, driver, NULL, wpas_config_file,
-						interface_create_callback,
-							wifi);
-	g_free(interface);
+	autoscan->interval = 0;
 
-	if (ret < 0)
-		return ret;
+	if (autoscan->timeout == 0)
+		return;
 
-	return -EINPROGRESS;
+	g_source_remove(autoscan->timeout);
+	autoscan->timeout = 0;
+
+	connman_device_unref(device);
 }
 
-static int wifi_disable(struct connman_device *device)
+static void stop_autoscan(struct connman_device *device)
+{
+	const struct wifi_data *wifi = connman_device_get_data(device);
+
+	if (!wifi || !wifi->autoscan)
+		return;
+
+	reset_autoscan(device);
+
+	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_WIFI, false);
+}
+
+static void check_p2p_technology(void)
+{
+	bool p2p_exists = false;
+	GList *list;
+
+	for (list = iface_list; list; list = list->next) {
+		struct wifi_data *w = list->data;
+
+		if (w && w->interface &&
+				g_supplicant_interface_has_p2p(w->interface)) {
+			p2p_exists = true;
+
+			if (w->p2p_listen_suppressed == true ||
+					connman_technology_get_p2p_listen(p2p_technology)) {
+				leave_p2p_listen_on_iface(w);
+				p2p_peers_refresh(w);
+				if (w->p2p_listen_suppressed == true)
+					w->p2p_listen_suppressed = false;
+			}
+		}
+	}
+
+	if (!p2p_exists) {
+		connman_technology_driver_unregister(&p2p_tech_driver);
+		connman_peer_driver_unregister(&peer_driver);
+	}
+}
+
+static void wifi_remove(struct connman_device *device)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
-	int ret;
 
 	DBG("device %p wifi %p", device, wifi);
 
 	if (!wifi)
-		return -ENODEV;
+		return;
 
-	wifi->connected = false;
-	wifi->disconnecting = false;
+	stop_autoscan(device);
 
-	if (wifi->pending_network)
-		wifi->pending_network = NULL;
+	if (g_list_find(p2p_iface_list, wifi))
+		p2p_iface_list = g_list_remove(p2p_iface_list, wifi);
+	else
+		iface_list = g_list_remove(iface_list, wifi);
 
-	stop_autoscan(device);
+	check_p2p_technology();
 
-	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_P2P)) {
+	remove_pending_wifi_device(wifi);
+
+	if (wifi->p2p_find_timeout) {
 		g_source_remove(wifi->p2p_find_timeout);
-		wifi->p2p_find_timeout = 0;
-		connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
 		connman_device_unref(wifi->device);
 	}
 
-	/* In case of a user scan, device is still referenced */
-	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI)) {
-		connman_device_set_scanning(device,
-				CONNMAN_SERVICE_TYPE_WIFI, false);
-		connman_device_unref(wifi->device);
-	}
+	if (wifi->p2p_connection_timeout)
+		g_source_remove(wifi->p2p_connection_timeout);
 
 	remove_networks(device, wifi);
 	remove_peers(wifi);
 
-	ret = g_supplicant_interface_remove(wifi->interface, NULL, NULL);
-	if (ret < 0)
-		return ret;
+	connman_device_set_powered(device, false);
+	connman_device_set_data(device, NULL);
+	connman_device_unref(wifi->device);
+	connman_rtnl_remove_watch(wifi->watch);
+	__connman_sd_cleanup();
 
-	return -EINPROGRESS;
-}
+	g_supplicant_interface_set_data(wifi->interface, NULL);
 
-struct last_connected {
-	struct timeval modified;
-	gchar *ssid;
-	int freq;
-};
+	g_supplicant_interface_cancel(wifi->interface);
 
-static gint sort_entry(gconstpointer a, gconstpointer b, gpointer user_data)
-{
-	struct timeval *aval = (struct timeval *)a;
-	struct timeval *bval = (struct timeval *)b;
+	if (wifi->scan_params)
+		g_supplicant_free_scan_params(wifi->scan_params);
 
-	/* Note that the sort order is descending */
-	if (aval->tv_sec < bval->tv_sec)
-		return 1;
+	if(wifi->p2p_device_config.device_name)
+	{
+		g_free(wifi->p2p_device_config.device_name);
+		wifi->p2p_device_config.device_name = NULL;
+	}
 
-	if (aval->tv_sec > bval->tv_sec)
-		return -1;
+	if(wifi->p2p_device_config.ssid_postfix)
+	{
+		g_free(wifi->p2p_device_config.ssid_postfix);
+		wifi->p2p_device_config.ssid_postfix = NULL;
+	}
 
-	return 0;
+	if(wifi->persistent_groups){
+		g_slist_free_full(wifi->persistent_groups, free_persistent_groups);
+		wifi->persistent_groups = NULL;
+	}
+
+	g_free(wifi->autoscan);
+	g_free(wifi->identifier);
+	g_free(wifi);
 }
 
-static void free_entry(gpointer data)
+static bool is_duplicate(GSList *list, gchar *ssid, int ssid_len)
 {
-	struct last_connected *entry = data;
+	GSList *iter;
 
-	g_free(entry->ssid);
-	g_free(entry);
+	for (iter = list; iter; iter = g_slist_next(iter)) {
+		struct scan_ssid *scan_ssid = iter->data;
+
+		if (ssid_len == scan_ssid->ssid_len &&
+				memcmp(ssid, scan_ssid->ssid, ssid_len) == 0)
+			return true;
+	}
+
+	return false;
 }
 
-static int get_latest_connections(int max_ssids,
-				GSupplicantScanParams *scan_data)
+static int add_scan_param(gchar *hex_ssid, char *raw_ssid, int ssid_len,
+			int freq, GSupplicantScanParams *scan_data,
+			int driver_max_scan_ssids, char *ssid_name)
 {
-	GSequenceIter *iter;
-	GSequence *latest_list;
-	struct last_connected *entry;
-	GKeyFile *keyfile;
-	struct timeval modified;
-	gchar **services;
-	gchar *str;
-	char *ssid;
-	int i, freq;
-	int num_ssids = 0;
+	unsigned int i;
+	struct scan_ssid *scan_ssid;
 
-	latest_list = g_sequence_new(free_entry);
-	if (!latest_list)
-		return -ENOMEM;
+	if ((driver_max_scan_ssids == 0 ||
+			driver_max_scan_ssids > scan_data->num_ssids) &&
+			(hex_ssid || raw_ssid)) {
+		gchar *ssid;
+		unsigned int j = 0, hex;
 
-	services = connman_storage_get_services();
-	for (i = 0; services && services[i]; i++) {
-		if (strncmp(services[i], "wifi_", 5) != 0)
-			continue;
+		if (hex_ssid) {
+			size_t hex_ssid_len = strlen(hex_ssid);
 
-		keyfile = connman_storage_load_service(services[i]);
-		if (!keyfile)
-			continue;
+			ssid = g_try_malloc0(hex_ssid_len / 2);
+			if (!ssid)
+				return -ENOMEM;
 
-		str = g_key_file_get_string(keyfile,
-					services[i], "Favorite", NULL);
-		if (!str || g_strcmp0(str, "true")) {
-			g_free(str);
-			g_key_file_free(keyfile);
-			continue;
-		}
-		g_free(str);
-
-		str = g_key_file_get_string(keyfile,
-					services[i], "AutoConnect", NULL);
-		if (!str || g_strcmp0(str, "true")) {
-			g_free(str);
-			g_key_file_free(keyfile);
-			continue;
+			for (i = 0; i < hex_ssid_len; i += 2) {
+				sscanf(hex_ssid + i, "%02x", &hex);
+				ssid[j++] = hex;
+			}
+		} else {
+			ssid = raw_ssid;
+			j = ssid_len;
 		}
-		g_free(str);
 
-		str = g_key_file_get_string(keyfile,
-					services[i], "Modified", NULL);
-		if (!str) {
-			g_key_file_free(keyfile);
-			continue;
+		/*
+		 * If we have already added hidden AP to the list,
+		 * then do not do it again. This might happen if you have
+		 * used or are using multiple wifi cards, so in that case
+		 * you might have multiple service files for same AP.
+		 */
+		if (is_duplicate(scan_data->ssids, ssid, j)) {
+			if (hex_ssid)
+				g_free(ssid);
+			return 0;
 		}
-		util_iso8601_to_timeval(str, &modified);
-		g_free(str);
 
-		ssid = g_key_file_get_string(keyfile,
-					services[i], "SSID", NULL);
-
-		freq = g_key_file_get_integer(keyfile, services[i],
-					"Frequency", NULL);
-		if (freq) {
-			entry = g_try_new(struct last_connected, 1);
-			if (!entry) {
-				g_sequence_free(latest_list);
-				g_key_file_free(keyfile);
+		scan_ssid = g_try_new(struct scan_ssid, 1);
+		if (!scan_ssid) {
+			if (hex_ssid)
 				g_free(ssid);
-				return -ENOMEM;
-			}
-
-			entry->ssid = ssid;
-			entry->modified = modified;
-			entry->freq = freq;
+			return -ENOMEM;
+		}
 
-			g_sequence_insert_sorted(latest_list, entry,
-						sort_entry, NULL);
-			num_ssids++;
-		} else
-			g_free(ssid);
+		memcpy(scan_ssid->ssid, ssid, j);
+		scan_ssid->ssid_len = j;
+		scan_data->ssids = g_slist_prepend(scan_data->ssids,
+								scan_ssid);
 
-		g_key_file_free(keyfile);
-	}
+		scan_data->num_ssids++;
 
-	g_strfreev(services);
+		DBG("SSID %s added to scanned list of %d entries", ssid_name,
+							scan_data->num_ssids);
 
-	num_ssids = num_ssids > max_ssids ? max_ssids : num_ssids;
+		if (hex_ssid)
+			g_free(ssid);
+	} else
+		return -EINVAL;
 
-	iter = g_sequence_get_begin_iter(latest_list);
+	scan_data->ssids = g_slist_reverse(scan_data->ssids);
 
-	for (i = 0; i < num_ssids; i++) {
-		entry = g_sequence_get(iter);
+	if (!scan_data->freqs) {
+		scan_data->freqs = g_try_malloc0(sizeof(uint16_t));
+		if (!scan_data->freqs) {
+			g_slist_free_full(scan_data->ssids, g_free);
+			return -ENOMEM;
+		}
 
-		DBG("ssid %s freq %d modified %lu", entry->ssid, entry->freq,
-						entry->modified.tv_sec);
+		scan_data->num_freqs = 1;
+		scan_data->freqs[0] = freq;
+	} else {
+		bool duplicate = false;
 
-		add_scan_param(entry->ssid, NULL, 0, entry->freq, scan_data,
-						max_ssids, entry->ssid);
+		/* Don't add duplicate entries */
+		for (i = 0; i < scan_data->num_freqs; i++) {
+			if (scan_data->freqs[i] == freq) {
+				duplicate = true;
+				break;
+			}
+		}
 
-		iter = g_sequence_iter_next(iter);
+		if (!duplicate) {
+			scan_data->num_freqs++;
+			scan_data->freqs = g_try_realloc(scan_data->freqs,
+				sizeof(uint16_t) * scan_data->num_freqs);
+			if (!scan_data->freqs) {
+				g_slist_free_full(scan_data->ssids, g_free);
+				return -ENOMEM;
+			}
+			scan_data->freqs[scan_data->num_freqs - 1] = freq;
+		}
 	}
 
-	g_sequence_free(latest_list);
-	return num_ssids;
+	return 1;
 }
 
-static void wifi_update_scanner_type(struct wifi_data *wifi,
-					enum wifi_scanning_type new_type)
+static int get_hidden_connections(GSupplicantScanParams *scan_data)
 {
-	DBG("");
+	struct connman_config_entry **entries;
+	GKeyFile *keyfile;
+	gchar **services;
+	char *ssid, *name;
+	int i, ret;
+	bool value;
+	int num_ssids = 0, add_param_failed = 0;
 
-	if (!wifi || wifi->scanning_type == new_type)
-		return;
+	services = connman_storage_get_services();
+	for (i = 0; services && services[i]; i++) {
+		if (strncmp(services[i], "wifi_", 5) != 0)
+			continue;
 
-	wifi->scanning_type = new_type;
+		keyfile = connman_storage_load_service(services[i]);
+		if (!keyfile)
+			continue;
 
-	setup_autoscan(wifi);
-}
+		value = g_key_file_get_boolean(keyfile,
+					services[i], "Hidden", NULL);
+		if (!value) {
+			g_key_file_free(keyfile);
+			continue;
+		}
 
-static int wifi_scan_simple(struct connman_device *device)
-{
-	struct wifi_data *wifi = connman_device_get_data(device);
+		value = g_key_file_get_boolean(keyfile,
+					services[i], "Favorite", NULL);
+		if (!value) {
+			g_key_file_free(keyfile);
+			continue;
+		}
 
-	reset_autoscan(device);
+		ssid = g_key_file_get_string(keyfile,
+					services[i], "SSID", NULL);
 
-	/* Distinguish between devices performing passive and active scanning */
-	if (wifi)
-		wifi_update_scanner_type(wifi, WIFI_SCANNING_PASSIVE);
+		name = g_key_file_get_string(keyfile, services[i], "Name",
+								NULL);
 
-	return throw_wifi_scan(device, scan_callback_hidden);
-}
+		ret = add_scan_param(ssid, NULL, 0, 0, scan_data, 0, name);
+		if (ret < 0)
+			add_param_failed++;
+		else if (ret > 0)
+			num_ssids++;
 
-static gboolean p2p_find_stop(gpointer data)
-{
-	struct connman_device *device = data;
-	struct wifi_data *wifi = connman_device_get_data(device);
+		g_free(ssid);
+		g_free(name);
+		g_key_file_free(keyfile);
+	}
 
-	DBG("");
+	/*
+	 * Check if there are any hidden AP that needs to be provisioned.
+	 */
+	entries = connman_config_get_entries("wifi");
+	for (i = 0; entries && entries[i]; i++) {
+		int len;
 
-	if (wifi) {
-		wifi->p2p_find_timeout = 0;
+		if (!entries[i]->hidden)
+			continue;
 
-		g_supplicant_interface_p2p_stop_find(wifi->interface);
+		if (!entries[i]->ssid) {
+			ssid = entries[i]->name;
+			len = strlen(ssid);
+		} else {
+			ssid = entries[i]->ssid;
+			len = entries[i]->ssid_len;
+		}
+
+		if (!ssid)
+			continue;
+
+		ret = add_scan_param(NULL, ssid, len, 0, scan_data, 0, ssid);
+		if (ret < 0)
+			add_param_failed++;
+		else if (ret > 0)
+			num_ssids++;
 	}
 
-	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
+	connman_config_free_entries(entries);
 
-	connman_device_unref(device);
-	start_autoscan(device);
+	if (add_param_failed > 0)
+		DBG("Unable to scan %d out of %d SSIDs",
+					add_param_failed, num_ssids);
 
-	return FALSE;
+	g_strfreev(services);
+
+	return num_ssids;
 }
 
-static void p2p_find_callback(int result, GSupplicantInterface *interface,
-							void *user_data)
+static int get_hidden_connections_params(struct wifi_data *wifi,
+					GSupplicantScanParams *scan_params)
 {
-	struct connman_device *device = user_data;
-	struct wifi_data *wifi = connman_device_get_data(device);
+	int driver_max_ssids, i;
+	GSupplicantScanParams *orig_params;
 
-	DBG("result %d wifi %p", result, wifi);
+	/*
+	 * Scan hidden networks so that we can autoconnect to them.
+	 * We will assume 1 as a default number of ssid to scan.
+	 */
+	driver_max_ssids = g_supplicant_interface_get_max_scan_ssids(
+							wifi->interface);
+	if (driver_max_ssids == 0)
+		driver_max_ssids = 1;
 
-	if (!wifi)
-		goto error;
+	DBG("max ssids %d", driver_max_ssids);
 
-	if (wifi->p2p_find_timeout) {
-		g_source_remove(wifi->p2p_find_timeout);
-		wifi->p2p_find_timeout = 0;
+	if (!wifi->scan_params) {
+		wifi->scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
+		if (!wifi->scan_params)
+			return 0;
+
+		if (get_hidden_connections(wifi->scan_params) == 0) {
+			g_supplicant_free_scan_params(wifi->scan_params);
+			wifi->scan_params = NULL;
+
+			return 0;
+		}
 	}
 
-	if (result)
-		goto error;
+	orig_params = wifi->scan_params;
 
-	wifi->p2p_find_timeout = g_timeout_add_seconds(P2P_FIND_TIMEOUT,
-							p2p_find_stop, device);
-	if (!wifi->p2p_find_timeout)
-		goto error;
+	/* Let's transfer driver_max_ssids params */
+	for (i = 0; i < driver_max_ssids; i++) {
+		struct scan_ssid *ssid;
 
-	return;
-error:
-	p2p_find_stop(device);
-}
+		if (!wifi->scan_params->ssids)
+			break;
 
-static int p2p_find(struct connman_device *device)
-{
-	struct wifi_data *wifi;
-	int ret;
+		ssid = orig_params->ssids->data;
+		orig_params->ssids = g_slist_remove(orig_params->ssids, ssid);
+		scan_params->ssids = g_slist_prepend(scan_params->ssids, ssid);
+	}
 
-	DBG("");
+	if (i > 0) {
+		scan_params->num_ssids = i;
+		scan_params->ssids = g_slist_reverse(scan_params->ssids);
 
-	if (!p2p_technology)
-		return -ENOTSUP;
+		scan_params->freqs = g_memdup(orig_params->freqs,
+				sizeof(uint16_t) * orig_params->num_freqs);
+		if (!scan_params->freqs)
+			goto err;
 
-	wifi = connman_device_get_data(device);
+		scan_params->num_freqs = orig_params->num_freqs;
 
-	if (g_supplicant_interface_is_p2p_finding(wifi->interface))
-		return -EALREADY;
+	} else
+		goto err;
 
-	reset_autoscan(device);
-	connman_device_ref(device);
+	orig_params->num_ssids -= scan_params->num_ssids;
 
-	ret = g_supplicant_interface_p2p_find(wifi->interface,
-						p2p_find_callback, device);
-	if (ret) {
-		connman_device_unref(device);
-		start_autoscan(device);
-	} else {
-		connman_device_set_scanning(device,
-				CONNMAN_SERVICE_TYPE_P2P, true);
+	return scan_params->num_ssids;
+
+err:
+	g_slist_free_full(scan_params->ssids, g_free);
+	g_supplicant_free_scan_params(wifi->scan_params);
+	wifi->scan_params = NULL;
+
+	return 0;
+}
+
+static void p2p_stop_find(struct wifi_data *wifi)
+{
+	if(p2p_find_ref != -1) {
+		g_source_remove(p2p_find_ref);
+		p2p_find_ref = -1;
+		g_supplicant_interface_p2p_stop_find(wifi->interface);
+
+		if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+					g_strcmp0(connman_device_get_string(wifi->device, "Interface"),
+							connman_option_get_string("P2PDevice")) == 0) {
+			connman_device_set_scanning(wifi->device, CONNMAN_SERVICE_TYPE_P2P, false);
+		}
+		return;
 	}
 
-	return ret;
+	g_supplicant_interface_p2p_stop_find(wifi->interface);
 }
 
-/*
- * Note that the hidden scan is only used when connecting to this specific
- * hidden AP first time. It is not used when system autoconnects to hidden AP.
- */
-static int wifi_scan(struct connman_device *device,
-			struct connman_device_scan_params *params)
+
+static int throw_wifi_scan(struct connman_device *device,
+			GSupplicantInterfaceCallback callback)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
-	GSupplicantScanParams *scan_params = NULL;
-	struct scan_ssid *scan_ssid;
-	struct hidden_params *hidden;
 	int ret;
-	int driver_max_ssids = 0;
-	bool do_hidden;
-	bool scanning;
 
 	if (!wifi)
 		return -ENODEV;
 
-	if (wifi->p2p_device)
-		return -EBUSY;
+	DBG("device %p %p", device, wifi->interface);
 
 	if (wifi->tethering)
 		return -EBUSY;
 
-	if (params->type == CONNMAN_SERVICE_TYPE_P2P)
-		return p2p_find(device);
-
-	DBG("device %p wifi %p hidden ssid %s", device, wifi->interface,
-		params->ssid);
-
-	scanning = connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI);
-
-	if (!params->ssid || params->ssid_len == 0 || params->ssid_len > 32) {
-		if (scanning)
-			return -EALREADY;
+	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI))
+		return -EALREADY;
 
-		driver_max_ssids = g_supplicant_interface_get_max_scan_ssids(
-							wifi->interface);
-		DBG("max ssids %d", driver_max_ssids);
-		if (driver_max_ssids == 0)
-			return wifi_scan_simple(device);
+	connman_device_ref(device);
 
-		do_hidden = false;
-	} else {
-		if (scanning && wifi->hidden && wifi->postpone_hidden)
-			return -EALREADY;
+	ret = g_supplicant_interface_scan(wifi->interface, NULL,
+						callback, device);
+	if (ret == 0) {
+		connman_device_set_scanning(device,
+				CONNMAN_SERVICE_TYPE_WIFI, true);
+	} else
+		connman_device_unref(device);
 
-		do_hidden = true;
-	}
+	return ret;
+}
 
-	scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
-	if (!scan_params)
-		return -ENOMEM;
+static void hidden_free(struct hidden_params *hidden)
+{
+	if (!hidden)
+		return;
 
-	if (do_hidden) {
-		scan_ssid = g_try_new(struct scan_ssid, 1);
-		if (!scan_ssid) {
-			g_free(scan_params);
-			return -ENOMEM;
-		}
+	if (hidden->scan_params)
+		g_supplicant_free_scan_params(hidden->scan_params);
+	g_free(hidden->identity);
+	g_free(hidden->passphrase);
+	g_free(hidden->security);
+	g_free(hidden);
+}
 
-		memcpy(scan_ssid->ssid, params->ssid, params->ssid_len);
-		scan_ssid->ssid_len = params->ssid_len;
-		scan_params->ssids = g_slist_prepend(scan_params->ssids,
-								scan_ssid);
-		scan_params->num_ssids = 1;
+static void scan_callback(int result, GSupplicantInterface *interface,
+						void *user_data)
+{
+	struct connman_device *device = user_data;
+	struct wifi_data *wifi = connman_device_get_data(device);
+	bool scanning;
 
-		hidden = g_try_new0(struct hidden_params, 1);
-		if (!hidden) {
-			g_supplicant_free_scan_params(scan_params);
-			return -ENOMEM;
-		}
+	DBG("result %d wifi %p", result, wifi);
 
-		if (wifi->hidden) {
+	if (wifi) {
+		if (wifi->hidden && !wifi->postpone_hidden) {
+			connman_network_clear_hidden(wifi->hidden->user_data);
 			hidden_free(wifi->hidden);
 			wifi->hidden = NULL;
 		}
 
-		memcpy(hidden->ssid, params->ssid, params->ssid_len);
-		hidden->ssid_len = params->ssid_len;
-		hidden->identity = g_strdup(params->identity);
-		hidden->passphrase = g_strdup(params->passphrase);
-		hidden->security = g_strdup(params->security);
-		hidden->user_data = params->user_data;
-		wifi->hidden = hidden;
-
-		if (scanning) {
-			/* Let's keep this active scan for later,
-			 * when current scan will be over. */
-			wifi->postpone_hidden = TRUE;
-			hidden->scan_params = scan_params;
-
-			return 0;
-		}
-	} else if (wifi->connected) {
-		g_supplicant_free_scan_params(scan_params);
-		return wifi_scan_simple(device);
-	} else if (!params->force_full_scan) {
-		ret = get_latest_connections(driver_max_ssids, scan_params);
-		if (ret <= 0) {
-			g_supplicant_free_scan_params(scan_params);
-			return wifi_scan_simple(device);
+		if (wifi->scan_params) {
+			g_supplicant_free_scan_params(wifi->scan_params);
+			wifi->scan_params = NULL;
 		}
 	}
 
-	/* Distinguish between devices performing passive and active scanning */
-	wifi_update_scanner_type(wifi, WIFI_SCANNING_ACTIVE);
-
-	connman_device_ref(device);
-
-	reset_autoscan(device);
+	if (result < 0)
+		connman_device_reset_scanning(device);
 
-	ret = g_supplicant_interface_scan(wifi->interface, scan_params,
-						scan_callback, device);
-	if (ret == 0) {
-		connman_device_set_scanning(device,
-				CONNMAN_SERVICE_TYPE_WIFI, true);
-	} else {
-		g_supplicant_free_scan_params(scan_params);
-		connman_device_unref(device);
+	/* User is connecting to a hidden AP, let's wait for finished event */
+	if (wifi && wifi->hidden && wifi->postpone_hidden) {
+		GSupplicantScanParams *scan_params;
+		int ret;
 
-		if (do_hidden) {
-			hidden_free(wifi->hidden);
-			wifi->hidden = NULL;
-		}
-	}
+		wifi->postpone_hidden = false;
+		scan_params = wifi->hidden->scan_params;
+		wifi->hidden->scan_params = NULL;
 
-	return ret;
-}
+		reset_autoscan(device);
 
-static void wifi_stop_scan(enum connman_service_type type,
-			struct connman_device *device)
-{
-	struct wifi_data *wifi = connman_device_get_data(device);
+		ret = g_supplicant_interface_scan(wifi->interface, scan_params,
+							scan_callback, device);
+		if (ret == 0)
+			return;
 
-	DBG("device %p wifi %p", device, wifi);
+		/* On error, let's recall scan_callback, which will cleanup */
+		return scan_callback(ret, interface, user_data);
+	}
 
-	if (!wifi)
-		return;
+	scanning = connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI);
 
-	if (type == CONNMAN_SERVICE_TYPE_P2P) {
-		if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_P2P)) {
-			g_source_remove(wifi->p2p_find_timeout);
-			p2p_find_stop(device);
-		}
+	if (scanning) {
+		connman_device_set_scanning(device,
+				CONNMAN_SERVICE_TYPE_WIFI, false);
 	}
-}
 
-static void wifi_regdom_callback(int result,
-					const char *alpha2,
-						void *user_data)
-{
-	struct connman_device *device = user_data;
+	if (result != -ENOLINK)
+		start_autoscan(device);
 
-	connman_device_regdom_notify(device, result, alpha2);
+	/*
+	 * If we are here then we were scanning; however, if we are
+	 * also mid-flight disabling the interface, then wifi_disable
+	 * has already cleared the device scanning state and
+	 * unreferenced the device, obviating the need to do it here.
+	 */
 
-	connman_device_unref(device);
+	if (scanning)
+		connman_device_unref(device);
 }
 
-static int wifi_set_regdom(struct connman_device *device, const char *alpha2)
+static void scan_callback_hidden(int result,
+			GSupplicantInterface *interface, void *user_data)
 {
+	struct connman_device *device = user_data;
 	struct wifi_data *wifi = connman_device_get_data(device);
+	GSupplicantScanParams *scan_params;
 	int ret;
 
+	DBG("result %d wifi %p", result, wifi);
+
 	if (!wifi)
-		return -EINVAL;
+		goto out;
 
-	connman_device_ref(device);
+	/* User is trying to connect to a hidden AP */
+	if (wifi->hidden && wifi->postpone_hidden)
+		goto out;
 
-	ret = g_supplicant_interface_set_country(wifi->interface,
-						wifi_regdom_callback,
-							alpha2, device);
-	if (ret != 0)
-		connman_device_unref(device);
+	scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
+	if (!scan_params)
+		goto out;
 
-	return ret;
+	if (get_hidden_connections_params(wifi, scan_params) > 0) {
+		ret = g_supplicant_interface_scan(wifi->interface,
+							scan_params,
+							scan_callback_hidden,
+							device);
+		if (ret == 0)
+			return;
+	}
+
+	g_supplicant_free_scan_params(scan_params);
+
+out:
+	scan_callback(result, interface, user_data);
 }
 
-static gboolean start_wps_timeout(gpointer user_data)
+static gboolean autoscan_timeout(gpointer data)
 {
-	struct wifi_data *wifi = user_data;
+	struct connman_device *device = data;
+	struct wifi_data *wifi = connman_device_get_data(device);
+	struct autoscan_params *autoscan;
+	int interval;
 
-	DBG("");
+	if (!wifi)
+		return FALSE;
 
-	wifi->wps_timeout = 0;
-	wifi->wps_active = FALSE;
+	autoscan = wifi->autoscan;
 
-	/* if we already assigned a network we have to remove it too */
-	wifi->network = NULL;
+	if (autoscan->interval <= 0) {
+		interval = autoscan->base;
+		goto set_interval;
+	} else
+		interval = autoscan->interval * autoscan->base;
 
-	connman_technology_wps_failed_notify(wifi_technology);
+	if (interval > autoscan->limit)
+		interval = autoscan->limit;
 
-	return FALSE;
-}
+	throw_wifi_scan(wifi->device, scan_callback_hidden);
 
-static bool is_wifi_valid (struct wifi_data *wifi)
-{
-	GList *list;
+	/*
+	 * In case BackgroundScanning is disabled, interval will reach the
+	 * limit exactly after the very first passive scanning. It allows
+	 * to ensure at most one passive scan is performed in such cases.
+	 */
+	if (!connman_setting_get_bool("BackgroundScanning") &&
+					interval == autoscan->limit) {
+		g_source_remove(autoscan->timeout);
+		autoscan->timeout = 0;
 
-	DBG("");
+		connman_device_unref(device);
 
-	if (wifi == NULL)
 		return FALSE;
-
-	for (list = iface_list; list; list = list->next) {
-		if (list->data == wifi)
-			return TRUE;
 	}
 
-	DBG("wifi %p not found", wifi);
+set_interval:
+	DBG("interval %d", interval);
+
+	autoscan->interval = interval;
+
+	autoscan->timeout = g_timeout_add_seconds(interval,
+						autoscan_timeout, device);
 
 	return FALSE;
 }
 
-static void cancel_wps_callback(int result, GSupplicantInterface *interface,
-                            void *user_data)
+static void start_autoscan(struct connman_device *device)
 {
-	struct wifi_data *wifi = user_data;
+	struct wifi_data *wifi = connman_device_get_data(device);
+	struct autoscan_params *autoscan;
 
-	DBG("result %d", result);
+	DBG("");
 
-	if (!is_wifi_valid(wifi))
+	if (!wifi)
 		return;
 
-	/* if we already assigned a network we have to remove it too */
-	if (wifi->network) {
-		connman_network_set_bool(wifi->network, "WiFi.UseWPS", FALSE);
-		connman_network_set_connected(wifi->network, FALSE);
-		wifi->network = NULL;
-	}
-
-	if (wifi->wps_timeout > 0) {
-		g_source_remove(wifi->wps_timeout);
-		wifi->wps_timeout = 0;
-	}
-
-	wifi->wps_active = FALSE;
-	/* already freed within gsupplicant layer */
-	wifi->wps_ssid = NULL;
+	if (wifi->p2p_device)
+		return;
 
-	enable_auto_connect_block(FALSE);
-}
+	if (wifi->connected)
+		return;
 
-static int cancel_wps(struct wifi_data *wifi)
-{
-	int ret;
+	autoscan = wifi->autoscan;
+	if (!autoscan)
+		return;
 
-	DBG("wifi %p", wifi);
+	if (autoscan->timeout > 0 || autoscan->interval > 0)
+		return;
 
-	ret = g_supplicant_interface_wps_cancel(wifi->interface, cancel_wps_callback, wifi);
-	if (ret == -EALREADY || ret == -EINPROGRESS)
-		ret = 0;
+	connman_device_ref(device);
 
-	return ret;
+	autoscan_timeout(device);
 }
 
-static gboolean wps_timeout_cb(gpointer user_data)
+static struct autoscan_params *parse_autoscan_params(const char *params)
 {
-	struct wifi_data *wifi = user_data;
+	struct autoscan_params *autoscan;
+	char **list_params;
+	int limit;
+	int base;
 
 	DBG("");
 
-	if (!is_wifi_valid(wifi))
-		return FALSE;
+	list_params = g_strsplit(params, ":", 0);
+	if (list_params == 0)
+		return NULL;
 
-	cancel_wps(wifi);
+	if (!g_strcmp0(list_params[0], "exponential") &&
+				g_strv_length(list_params) == 3) {
+		base = atoi(list_params[1]);
+		limit = atoi(list_params[2]);
+	} else if (!g_strcmp0(list_params[0], "single") &&
+				g_strv_length(list_params) == 2)
+		base = limit = atoi(list_params[1]);
+	else {
+		g_strfreev(list_params);
+		return NULL;
+	}
 
-	connman_technology_wps_failed_notify(wifi_technology);
+	DBG("Setup %s autoscanning", list_params[0]);
 
-	return FALSE;
-}
+	g_strfreev(list_params);
 
-static void wps_start_callback(int result, GSupplicantInterface *interface,
-                            void *user_data)
-{
-	struct wifi_data *wifi = user_data;
+	autoscan = g_try_malloc0(sizeof(struct autoscan_params));
+	if (!autoscan) {
+		DBG("Could not allocate memory for autoscan");
+		return NULL;
+	}
 
-	DBG("result %d", result);
+	DBG("base %d - limit %d", base, limit);
+	autoscan->base = base;
+	autoscan->limit = limit;
 
-	if (result == 0)
-		return;
+	return autoscan;
+}
 
-	if (!is_wifi_valid(wifi))
+static void setup_autoscan(struct wifi_data *wifi)
+{
+	/*
+	 * If BackgroundScanning is enabled, setup exponential
+	 * autoscanning if it has not been previously done.
+	 */
+	if (connman_setting_get_bool("BackgroundScanning")) {
+		wifi->autoscan = parse_autoscan_params(AUTOSCAN_EXPONENTIAL);
 		return;
-
-	/* if we're at this place something went wrong an we have to clean up */
-	if (wifi->wps_timeout > 0) {
-		g_source_remove(wifi->wps_timeout);
-		wifi->wps_timeout = 0;
 	}
 
-	wifi->wps_active = FALSE;
+	/*
+	 * On the contrary, if BackgroundScanning is disabled, update autoscan
+	 * parameters based on the type of scanning that is being performed.
+	 */
+	if (wifi->autoscan) {
+		g_free(wifi->autoscan);
+		wifi->autoscan = NULL;
+	}
 
-	connman_technology_wps_failed_notify(wifi_technology);
+	switch (wifi->scanning_type) {
+	case WIFI_SCANNING_PASSIVE:
+		/* Do not setup autoscan. */
+		break;
+	case WIFI_SCANNING_ACTIVE:
+		/* Setup one single passive scan after active. */
+		wifi->autoscan = parse_autoscan_params(AUTOSCAN_SINGLE);
+		break;
+	case WIFI_SCANNING_UNKNOWN:
+		/* Setup autoscan in this case but we should never fall here. */
+		wifi->autoscan = parse_autoscan_params(AUTOSCAN_SINGLE);
+		break;
+	}
 }
 
-static int start_wps(struct wifi_data *wifi)
+static void finalize_interface_creation(struct wifi_data *wifi)
 {
-	int ret;
+	DBG("interface is ready wifi %p tethering %d", wifi, wifi->tethering);
 
-	connman_info("start wps connection");
+	if (!wifi->device) {
+		connman_error("WiFi device not set");
+		return;
+	}
 
-	wifi->wps_timeout = g_timeout_add_seconds(WPS_CONNECT_TIMEOUT,
-							wps_timeout_cb, wifi);
+	connman_device_set_powered(wifi->device, true);
 
-	ret = g_supplicant_interface_connect(wifi->interface, wifi->wps_ssid,
-						wps_start_callback, wifi);
-	if (ret == -EALREADY || ret == -EINPROGRESS)
-		ret = 0;
+	if (wifi->p2p_device)
+		return;
 
-	return ret;
-}
+	if (is_technology_enabled(wifi_technology)) {
+		DBG("WiFi is enable, so enable p2p also");
+		if (p2p_technology)
+			connman_technology_set_p2p(p2p_technology, true);
+	}
+//	if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+//		g_strcmp0(g_supplicant_interface_get_ifname(wifi->interface),
+//			connman_option_get_string("P2PDevice")) == 0) {
+                int ret;
 
-static gboolean deferred_wps_start(struct wifi_data *wifi)
-{
-	DBG("WPS active %d", wifi->wps_active);
+                DBG("interface type is p2p interface");
+                ret = g_supplicant_interface_get_p2p_device_config(wifi->interface, &wifi->p2p_device_config);
+                if (ret == 0) {
+                        DBG("interface type is p2p device config");
 
-	if(wifi->wps_active == FALSE)
-		return FALSE;
+                        wifi->persistent_peer_ssid = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+                        add_persistent_group_info(wifi);
+                }
 
-	if(wifi->wps_start_deferred) {
-		wifi->network = NULL;
-		start_wps(wifi);
-		wifi->wps_start_deferred = FALSE;
-		return TRUE;
-	}
+                __connman_group_init();
 
-	return FALSE;
+		__connman_sd_init(wifi->interface, connman_device_get_ident(wifi->device));
+//	}
+
+	if (!wifi->autoscan)
+		setup_autoscan(wifi);
+
+	start_autoscan(wifi->device);
 }
 
-static int wifi_start_wps(struct connman_device *device, const char *pin)
+static void interface_create_callback(int result,
+					GSupplicantInterface *interface,
+							void *user_data)
 {
-	struct wifi_data *wifi = connman_device_get_data(device);
-	GSupplicantSSID *ssid;
-	int ret=0;
-
-	if (wifi->wps_active == TRUE)
-		return -EINPROGRESS;
+	struct wifi_data *wifi = user_data;
 
-	DBG("");
-
-	ssid = g_try_malloc0(sizeof(GSupplicantSSID));
-	if (ssid == NULL)
-		return -ENOMEM;
-
-	ssid->use_wps = TRUE;
-	if(strlen(pin) == 0)
-		ssid->pin_wps = NULL;
-	else
-		ssid->pin_wps = g_strdup(pin);
-
-	wifi->wps_active = TRUE;
-	wifi->wps_ssid = ssid;
+	DBG("result %d ifname %s, wifi %p", result,
+				g_supplicant_interface_get_ifname(interface),
+				wifi);
 
-	enable_auto_connect_block(TRUE);
+	if (result < 0 || !wifi)
+		return;
 
-	/* if we're still disconnecting wait until we're completely disconnected */
-	if (wifi->disconnecting) {
-		DBG("Defering WPS until disconnect is done");
-		wifi->wps_start_deferred = TRUE;
-		return 0;
-	}
+	wifi->interface = interface;
+	g_supplicant_interface_set_data(interface, wifi);
 
-	/* This is ahead of what will happen if we have an associating network
-	 * at this point. Once we issue the StartWPS command to wpa-supplicant
-	 * the network will be disconnected and we will receive the interface
-	 * state change signal. As we're in the middle of the WPS process we
-	 * don't handle that there ... */
-	if (wifi->network) {
-		connman_network_set_connected(wifi->network, FALSE);
-		connman_network_set_associating(wifi->network, FALSE);
-		wifi->network = NULL;
+	if (g_supplicant_interface_get_ready(interface)) {
+		wifi->interface_ready = true;
+		finalize_interface_creation(wifi);
 	}
-
-	return start_wps(wifi);
 }
 
-static int wifi_cancel_wps(struct connman_device *device)
+static int wifi_enable(struct connman_device *device)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
+	int index;
+	char *interface;
+	const char *driver = connman_option_get_string("wifi");
+	int ret;
 
-	DBG("");
-
-	if (wifi->wps_active == FALSE)
-		return 0;
-
-	return cancel_wps(wifi);
-}
-
-static void signal_info_cb(int result, GSupplicantInterface *interface, void *user_data)
-{
-	struct wifi_cb_data *data = user_data;
-	connman_device_request_signal_info_cb cb = data->callback;
-	unsigned int value;
-
-	if (result < 0)
-		goto done;
-
-	value = g_supplicant_interface_get_rssi(interface);
-	connman_device_set_integer(data->wifi->device, "WiFi.RSSI", value);
+	DBG("device %p %p", device, wifi);
 
-	value = g_supplicant_interface_get_link_speed(interface);
-	connman_device_set_integer(data->wifi->device, "WiFi.LinkSpeed", value);
+	index = connman_device_get_index(device);
+	if (!wifi || index < 0)
+		return -ENODEV;
 
-	value = g_supplicant_interface_get_frequency(interface);
-	connman_device_set_integer(data->wifi->device, "WiFi.Frequency", value);
+	if (is_p2p_connecting())
+		return -EINPROGRESS;
 
-	value = g_supplicant_interface_get_noise(interface);
-	connman_device_set_integer(data->wifi->device, "WiFi.Noise", value);
+	interface = connman_inet_ifname(index);
+	const char *wpas_config_file = connman_setting_get_string("WpaSupplicantConfigFile");
+	ret = g_supplicant_interface_create(interface, driver, NULL, wpas_config_file,
+						interface_create_callback,
+							wifi);
+	g_free(interface);
 
-done:
-	cb(data->wifi->device, data->user_data);
+	if (ret < 0)
+		return ret;
 
-	g_free(data);
+	return -EINPROGRESS;
 }
 
-static int wifi_get_signal_info(struct connman_device *device, connman_device_request_signal_info_cb cb, void *user_data)
+static int wifi_disable(struct connman_device *device)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
-	struct wifi_cb_data *data;
+	int ret;
+
+	DBG("device %p wifi %p", device, wifi);
 
 	if (!wifi)
-		return -EINVAL;
+		return -ENODEV;
 
-	data = g_new0(struct wifi_cb_data, 1);
-	if (!data)
-		return -ENOMEM;
+	wifi->connected = false;
+	wifi->disconnecting = false;
 
-	data->callback = cb;
-	data->user_data = user_data;
-	data->wifi = wifi;
+	if (wifi->pending_network)
+		wifi->pending_network = NULL;
 
-	return g_supplicant_interface_update_signal_info(wifi->interface, signal_info_cb, data);
-}
+	stop_autoscan(device);
 
-static struct connman_device_driver wifi_ng_driver = {
-	.name		= "wifi",
-	.type		= CONNMAN_DEVICE_TYPE_WIFI,
-	.priority	= CONNMAN_DEVICE_PRIORITY_LOW,
-	.probe		= wifi_probe,
-	.remove		= wifi_remove,
-	.enable		= wifi_enable,
-	.disable	= wifi_disable,
-	.scan		= wifi_scan,
-	.stop_scan	= wifi_stop_scan,
-	.set_regdom	= wifi_set_regdom,
-	.start_wps	= wifi_start_wps,
-	.cancel_wps	= wifi_cancel_wps,
-	.get_signal_info = wifi_get_signal_info,
-};
+	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_P2P)) {
+		g_source_remove(wifi->p2p_find_timeout);
+		wifi->p2p_find_timeout = 0;
+		connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
+		connman_device_unref(wifi->device);
+	}
 
-static void system_ready(void)
-{
-	DBG("");
+	/* In case of a user scan, device is still referenced */
+	if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI)) {
+		connman_device_set_scanning(device,
+				CONNMAN_SERVICE_TYPE_WIFI, false);
+		connman_device_unref(wifi->device);
+	}
 
-	if (connman_device_driver_register(&wifi_ng_driver) < 0)
-		connman_error("Failed to register WiFi driver");
-}
+	remove_networks(device, wifi);
+	remove_peers(wifi);
 
-static void system_killed(void)
-{
-	DBG("");
+	ret = g_supplicant_interface_remove(wifi->interface, NULL, NULL);
+	if (ret < 0)
+		return ret;
 
-	connman_device_driver_unregister(&wifi_ng_driver);
+	return -EINPROGRESS;
 }
 
-static int network_probe(struct connman_network *network)
+struct last_connected {
+	struct timeval modified;
+	gchar *ssid;
+	int freq;
+};
+
+static gint sort_entry(gconstpointer a, gconstpointer b, gpointer user_data)
 {
-	DBG("network %p", network);
+	struct timeval *aval = (struct timeval *)a;
+	struct timeval *bval = (struct timeval *)b;
+
+	/* Note that the sort order is descending */
+	if (aval->tv_sec < bval->tv_sec)
+		return 1;
+
+	if (aval->tv_sec > bval->tv_sec)
+		return -1;
 
 	return 0;
 }
 
-static int network_connect(struct connman_network *network);
-
-static gboolean perform_deferred_connect_after_disconnect(struct wifi_data *wifi)
+static void free_entry(gpointer data)
 {
-	if (wifi->pending_network != NULL) {
-		network_connect(wifi->pending_network);
-		wifi->pending_network = NULL;
-		return TRUE;
-	}
-
-	if (deferred_wps_start(wifi)) {
-		return TRUE;
-	}
+	struct last_connected *entry = data;
 
-	return FALSE;
+	g_free(entry->ssid);
+	g_free(entry);
 }
 
-static void network_remove(struct connman_network *network)
+static int get_latest_connections(int max_ssids,
+				GSupplicantScanParams *scan_data)
 {
-	struct connman_device *device = connman_network_get_device(network);
-	struct wifi_data *wifi;
+	GSequenceIter *iter;
+	GSequence *latest_list;
+	struct last_connected *entry;
+	GKeyFile *keyfile;
+	struct timeval modified;
+	gchar **services;
+	gchar *str;
+	char *ssid;
+	int i, freq;
+	int num_ssids = 0;
 
-	DBG("network %p", network);
+	latest_list = g_sequence_new(free_entry);
+	if (!latest_list)
+		return -ENOMEM;
 
-	wifi = connman_device_get_data(device);
-	if (!wifi)
-		return;
+	services = connman_storage_get_services();
+	for (i = 0; services && services[i]; i++) {
+		if (strncmp(services[i], "wifi_", 5) != 0)
+			continue;
 
-	if (wifi->network != network)
-		return;
-	else {
-		wifi->disconnecting = FALSE;
-		perform_deferred_connect_after_disconnect(wifi);
-	}
+		keyfile = connman_storage_load_service(services[i]);
+		if (!keyfile)
+			continue;
 
-	wifi->network = NULL;
-}
+		str = g_key_file_get_string(keyfile,
+					services[i], "Favorite", NULL);
+		if (!str || g_strcmp0(str, "true")) {
+			g_free(str);
+			g_key_file_free(keyfile);
+			continue;
+		}
+		g_free(str);
 
-static void connect_callback(int result, GSupplicantInterface *interface,
-							void *user_data)
-{
-	struct connman_network *network = user_data;
+		str = g_key_file_get_string(keyfile,
+					services[i], "AutoConnect", NULL);
+		if (!str || g_strcmp0(str, "true")) {
+			g_free(str);
+			g_key_file_free(keyfile);
+			continue;
+		}
+		g_free(str);
 
-	DBG("network %p result %d", network, result);
+		str = g_key_file_get_string(keyfile,
+					services[i], "Modified", NULL);
+		if (!str) {
+			g_key_file_free(keyfile);
+			continue;
+		}
+		util_iso8601_to_timeval(str, &modified);
+		g_free(str);
 
-	if (result == -ENOKEY) {
-		connman_network_set_error(network,
-					CONNMAN_NETWORK_ERROR_INVALID_KEY);
-	} else if (result < 0) {
-		connman_network_set_error(network,
-					CONNMAN_NETWORK_ERROR_CONFIGURE_FAIL);
+		ssid = g_key_file_get_string(keyfile,
+					services[i], "SSID", NULL);
+
+		freq = g_key_file_get_integer(keyfile, services[i],
+					"Frequency", NULL);
+		if (freq) {
+			entry = g_try_new(struct last_connected, 1);
+			if (!entry) {
+				g_sequence_free(latest_list);
+				g_key_file_free(keyfile);
+				g_free(ssid);
+				return -ENOMEM;
+			}
+
+			entry->ssid = ssid;
+			entry->modified = modified;
+			entry->freq = freq;
+
+			g_sequence_insert_sorted(latest_list, entry,
+						sort_entry, NULL);
+			num_ssids++;
+		} else
+			g_free(ssid);
+
+		g_key_file_free(keyfile);
 	}
 
-	connman_network_unref(network);
+	g_strfreev(services);
+
+	num_ssids = num_ssids > max_ssids ? max_ssids : num_ssids;
+
+	iter = g_sequence_get_begin_iter(latest_list);
+
+	for (i = 0; i < num_ssids; i++) {
+		entry = g_sequence_get(iter);
+
+		DBG("ssid %s freq %d modified %lu", entry->ssid, entry->freq,
+						entry->modified.tv_sec);
+
+		add_scan_param(entry->ssid, NULL, 0, entry->freq, scan_data,
+						max_ssids, entry->ssid);
+
+		iter = g_sequence_iter_next(iter);
+	}
+
+	g_sequence_free(latest_list);
+	return num_ssids;
 }
 
-static GSupplicantSecurity network_security(const char *security)
+static void wifi_update_scanner_type(struct wifi_data *wifi,
+					enum wifi_scanning_type new_type)
 {
-	if (g_str_equal(security, "none"))
-		return G_SUPPLICANT_SECURITY_NONE;
-	else if (g_str_equal(security, "wep"))
-		return G_SUPPLICANT_SECURITY_WEP;
-	else if (g_str_equal(security, "psk"))
-		return G_SUPPLICANT_SECURITY_PSK;
-	else if (g_str_equal(security, "wpa"))
-		return G_SUPPLICANT_SECURITY_PSK;
-	else if (g_str_equal(security, "rsn"))
-		return G_SUPPLICANT_SECURITY_PSK;
-	else if (g_str_equal(security, "ieee8021x"))
-		return G_SUPPLICANT_SECURITY_IEEE8021X;
+	DBG("");
 
-	return G_SUPPLICANT_SECURITY_UNKNOWN;
+	if (!wifi || wifi->scanning_type == new_type)
+		return;
+
+	wifi->scanning_type = new_type;
+
+	setup_autoscan(wifi);
 }
 
-static void ssid_init(GSupplicantSSID *ssid, struct connman_network *network)
+static int wifi_scan_simple(struct connman_device *device)
 {
-	const char *security;
+	struct wifi_data *wifi = connman_device_get_data(device);
 
-	memset(ssid, 0, sizeof(*ssid));
-	ssid->mode = G_SUPPLICANT_MODE_INFRA;
-	ssid->ssid = connman_network_get_blob(network, "WiFi.SSID",
-						&ssid->ssid_len);
-	ssid->scan_ssid = 1;
-	security = connman_network_get_string(network, "WiFi.Security");
-	ssid->security = network_security(security);
-	ssid->passphrase = connman_network_get_string(network,
-						"WiFi.Passphrase");
+	reset_autoscan(device);
 
-	ssid->eap = connman_network_get_string(network, "WiFi.EAP");
+	/* Distinguish between devices performing passive and active scanning */
+	if (wifi)
+		wifi_update_scanner_type(wifi, WIFI_SCANNING_PASSIVE);
 
-	/*
-	 * If our private key password is unset,
-	 * we use the supplied passphrase. That is needed
-	 * for PEAP where 2 passphrases (identity and client
-	 * cert may have to be provided.
-	 */
-	if (!connman_network_get_string(network, "WiFi.PrivateKeyPassphrase"))
-		connman_network_set_string(network,
-						"WiFi.PrivateKeyPassphrase",
-						ssid->passphrase);
-	/* We must have an identity for both PEAP and TLS */
-	ssid->identity = connman_network_get_string(network, "WiFi.Identity");
+	return throw_wifi_scan(device, scan_callback_hidden);
+}
 
-	/* Use agent provided identity as a fallback */
-	if (!ssid->identity || strlen(ssid->identity) == 0)
-		ssid->identity = connman_network_get_string(network,
-							"WiFi.AgentIdentity");
+static gboolean p2p_find_stop(gpointer data)
+{
+	struct connman_device *device = data;
+	struct wifi_data *wifi = connman_device_get_data(device);
 
-	ssid->anonymous_identity = connman_network_get_string(network,
-						"WiFi.AnonymousIdentity");
-	ssid->ca_cert_path = connman_network_get_string(network,
-							"WiFi.CACertFile");
-	ssid->subject_match = connman_network_get_string(network,
-							"WiFi.SubjectMatch");
-	ssid->altsubject_match = connman_network_get_string(network,
-							"WiFi.AltSubjectMatch");
-	ssid->domain_suffix_match = connman_network_get_string(network,
-							"WiFi.DomainSuffixMatch");
-	ssid->domain_match = connman_network_get_string(network,
-							"WiFi.DomainMatch");
-	ssid->client_cert_path = connman_network_get_string(network,
-							"WiFi.ClientCertFile");
-	ssid->private_key_path = connman_network_get_string(network,
-							"WiFi.PrivateKeyFile");
-	ssid->private_key_passphrase = connman_network_get_string(network,
-						"WiFi.PrivateKeyPassphrase");
-	ssid->phase2_auth = connman_network_get_string(network, "WiFi.Phase2");
+	DBG("");
 
-	ssid->use_wps = connman_network_get_bool(network, "WiFi.UseWPS");
-	ssid->pin_wps = connman_network_get_string(network, "WiFi.PinWPS");
+	if (wifi) {
+		wifi->p2p_find_timeout = 0;
 
-	if (connman_setting_get_bool("BackgroundScanning"))
-		ssid->bgscan = BGSCAN_DEFAULT;
+		g_supplicant_interface_p2p_stop_find(wifi->interface);
+		if (p2p_technology &&
+				(wifi->p2p_listen_suppressed == true ||
+				connman_technology_get_p2p_listen(p2p_technology))) {
+			set_p2p_listen_without_state_change(p2p_technology, true);
+			if (wifi->p2p_listen_suppressed)
+				wifi->p2p_listen_suppressed = false;
+		}
+	}
+
+	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
+
+	connman_device_unref(device);
+	start_autoscan(device);
+
+	return FALSE;
 }
 
-static int network_connect(struct connman_network *network)
+static void p2p_find_callback(int result, GSupplicantInterface *interface,
+							void *user_data)
+{
+	struct connman_device *device = user_data;
+	struct wifi_data *wifi = connman_device_get_data(device);
+
+	DBG("result %d wifi %p", result, wifi);
+
+	if (!wifi)
+		goto error;
+
+	if (wifi->p2p_find_timeout) {
+		g_source_remove(wifi->p2p_find_timeout);
+		wifi->p2p_find_timeout = 0;
+	}
+
+	if (result)
+		goto error;
+
+	wifi->p2p_find_timeout = g_timeout_add_seconds(P2P_FIND_TIMEOUT,
+							p2p_find_stop, device);
+	if (!wifi->p2p_find_timeout)
+		goto error;
+
+	p2p_find_ref = -1;
+
+	return;
+error:
+	p2p_find_ref = -1;
+	p2p_find_stop(device);
+}
+
+static gboolean p2p_find_complete(gpointer argv)
+{
+	struct connman_device *device = argv;
+	struct wifi_data *wifi = connman_device_get_data(device);
+	int ret = 0;
+
+	if(!wifi) {
+		p2p_find_ref = -1;
+		return FALSE;
+	}
+
+	if (p2p_technology &&
+			(wifi->p2p_listen_suppressed == true ||
+			connman_technology_get_p2p_listen(p2p_technology))) {
+		set_p2p_listen_without_state_change(p2p_technology, true);
+		if (wifi->p2p_listen_suppressed)
+			wifi->p2p_listen_suppressed = false;
+	}
+
+	p2p_find_ref = -1;
+
+	return FALSE;
+}
+
+static int p2p_find(struct connman_device *device)
 {
-	struct connman_device *device = connman_network_get_device(network);
 	struct wifi_data *wifi;
-	GSupplicantInterface *interface;
-	GSupplicantSSID *ssid;
+	int ret;
 
-	DBG("network %p", network);
+	DBG("");
 
-	if (!device)
-		return -ENODEV;
+	if (!p2p_technology)
+		return -ENOTSUP;
 
 	wifi = connman_device_get_data(device);
+
+	if (!wifi || !wifi->interface)
+		return -ENODEV;
+
+	if (g_supplicant_interface_is_p2p_finding(wifi->interface))
+		return -EALREADY;
+
+	if (p2p_technology &&
+		connman_technology_get_p2p_listen(p2p_technology)) {
+		set_p2p_listen_without_state_change(p2p_technology, false);
+		wifi->p2p_listen_suppressed = true;
+	}
+
+	reset_autoscan(device);
+	connman_device_ref(device);
+
+	ret = g_supplicant_interface_p2p_find(wifi->interface, NULL,
+						p2p_find_callback, device);
+
+	if (ret) {
+		connman_device_unref(device);
+		start_autoscan(device);
+	} else {
+		connman_device_set_scanning(device,
+				CONNMAN_SERVICE_TYPE_P2P, true);
+		p2p_find_ref = g_timeout_add_seconds(wifi->p2p_find_timeout, p2p_find_complete, device);
+	}
+
+	return ret;
+}
+
+/*
+ * Note that the hidden scan is only used when connecting to this specific
+ * hidden AP first time. It is not used when system autoconnects to hidden AP.
+ */
+static int wifi_scan(struct connman_device *device,
+			struct connman_device_scan_params *params)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+	GSupplicantScanParams *scan_params = NULL;
+	struct scan_ssid *scan_ssid;
+	struct hidden_params *hidden;
+	int ret;
+	int driver_max_ssids = 0;
+	bool do_hidden;
+	bool scanning;
+
 	if (!wifi)
 		return -ENODEV;
 
-	if (wifi->wps_active)
-		return -EINPROGRESS;
+	if (wifi->p2p_device)
+		return -EBUSY;
 
-	ssid = g_try_malloc0(sizeof(GSupplicantSSID));
-	if (!ssid)
-		return -ENOMEM;
+	if (wifi->tethering)
+		return -EBUSY;
+
+	if (params->type == CONNMAN_SERVICE_TYPE_P2P) {
+			if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+					g_strcmp0(connman_device_get_string(device, "Interface"),
+								connman_option_get_string("P2PDevice")) != 0)
+					return -ENOTSUP;
+
+			if(p2p_find_ref != -1)
+				return -EINPROGRESS;
+			return p2p_find(device);
+	}
+ 
+	DBG("device %p wifi %p hidden ssid %s", device, wifi->interface,
+		params->ssid);
+
+	if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+				g_strcmp0(connman_device_get_string(device, "Interface"),
+						connman_option_get_string("WiFiDevice")) != 0)
+		return -ENOTSUP;
+
+	scanning = connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_WIFI);
+	if (!scanning && (!params->ssid || params->ssid_len == 0 || params->ssid_len > 32))
+		p2p_stop_find(wifi);
+
+	if (p2p_technology &&
+		connman_technology_get_p2p_listen(p2p_technology)) {
+		set_p2p_listen_without_state_change(p2p_technology, false);
+		wifi->p2p_listen_suppressed = true;
+	}
+
+
+	if (!params->ssid || params->ssid_len == 0 || params->ssid_len > 32) {
+		if (scanning)
+			return -EALREADY;
+
+		driver_max_ssids = g_supplicant_interface_get_max_scan_ssids(
+							wifi->interface);
+		DBG("max ssids %d", driver_max_ssids);
+		if (driver_max_ssids == 0)
+			return wifi_scan_simple(device);
+
+		do_hidden = false;
+	} else {
+		if (scanning && wifi->hidden && wifi->postpone_hidden)
+			return -EALREADY;
+
+		do_hidden = true;
+	}
+
+	scan_params = g_try_malloc0(sizeof(GSupplicantScanParams));
+	if (!scan_params)
+		return -ENOMEM;
+
+	if (do_hidden) {
+		scan_ssid = g_try_new(struct scan_ssid, 1);
+		if (!scan_ssid) {
+			g_free(scan_params);
+			return -ENOMEM;
+		}
+
+		memcpy(scan_ssid->ssid, params->ssid, params->ssid_len);
+		scan_ssid->ssid_len = params->ssid_len;
+		scan_params->ssids = g_slist_prepend(scan_params->ssids,
+								scan_ssid);
+		scan_params->num_ssids = 1;
+
+		hidden = g_try_new0(struct hidden_params, 1);
+		if (!hidden) {
+			g_supplicant_free_scan_params(scan_params);
+			return -ENOMEM;
+		}
+
+		if (wifi->hidden) {
+			hidden_free(wifi->hidden);
+			wifi->hidden = NULL;
+		}
+
+		memcpy(hidden->ssid, params->ssid, params->ssid_len);
+		hidden->ssid_len = params->ssid_len;
+		hidden->identity = g_strdup(params->identity);
+		hidden->passphrase = g_strdup(params->passphrase);
+		hidden->security = g_strdup(params->security);
+		hidden->user_data = params->user_data;
+		wifi->hidden = hidden;
+
+		if (scanning) {
+			/* Let's keep this active scan for later,
+			 * when current scan will be over. */
+			wifi->postpone_hidden = TRUE;
+			hidden->scan_params = scan_params;
+
+			return 0;
+		}
+	} else if (wifi->connected) {
+		g_supplicant_free_scan_params(scan_params);
+		return wifi_scan_simple(device);
+	} else if (!params->force_full_scan) {
+		ret = get_latest_connections(driver_max_ssids, scan_params);
+		if (ret <= 0) {
+			g_supplicant_free_scan_params(scan_params);
+			return wifi_scan_simple(device);
+		}
+	}
+
+	/* Distinguish between devices performing passive and active scanning */
+	wifi_update_scanner_type(wifi, WIFI_SCANNING_ACTIVE);
+
+	connman_device_ref(device);
+
+	reset_autoscan(device);
+
+	ret = g_supplicant_interface_scan(wifi->interface, scan_params,
+						scan_callback, device);
+	if (ret == 0) {
+		connman_device_set_scanning(device,
+				CONNMAN_SERVICE_TYPE_WIFI, true);
+	} else {
+		g_supplicant_free_scan_params(scan_params);
+		connman_device_unref(device);
+
+		if (do_hidden) {
+			hidden_free(wifi->hidden);
+			wifi->hidden = NULL;
+		}
+	}
+
+	return ret;
+}
+
+static void wifi_stop_scan(enum connman_service_type type,
+			struct connman_device *device)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+
+	DBG("device %p wifi %p", device, wifi);
+
+	if (!wifi)
+		return;
+
+	if (type == CONNMAN_SERVICE_TYPE_P2P) {
+		if (connman_device_get_scanning(device, CONNMAN_SERVICE_TYPE_P2P)) {
+			g_source_remove(wifi->p2p_find_timeout);
+			p2p_find_stop(device);
+		}
+	}
+}
+
+static void wifi_regdom_callback(int result,
+					const char *alpha2,
+						void *user_data)
+{
+	struct connman_device *device = user_data;
+
+	connman_device_regdom_notify(device, result, alpha2);
+
+	connman_device_unref(device);
+}
+
+static int wifi_set_regdom(struct connman_device *device, const char *alpha2)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+	int ret;
+
+	if (!wifi)
+		return -EINVAL;
+
+	connman_device_ref(device);
+
+	ret = g_supplicant_interface_set_country(wifi->interface,
+						wifi_regdom_callback,
+							alpha2, device);
+	if (ret != 0)
+		connman_device_unref(device);
+
+	return ret;
+}
+
+static gboolean start_wps_timeout(gpointer user_data)
+{
+	struct wifi_data *wifi = user_data;
+
+	DBG("");
+
+	wifi->wps_timeout = 0;
+	wifi->wps_active = FALSE;
+
+	/* if we already assigned a network we have to remove it too */
+	wifi->network = NULL;
+
+	connman_technology_wps_failed_notify(wifi_technology);
+
+	return FALSE;
+}
+
+static bool is_wifi_valid (struct wifi_data *wifi)
+{
+	GList *list;
+
+	DBG("");
+
+	if (wifi == NULL)
+		return FALSE;
+
+	for (list = iface_list; list; list = list->next) {
+		if (list->data == wifi)
+			return TRUE;
+	}
+
+	DBG("wifi %p not found", wifi);
+
+	return FALSE;
+}
+
+static void cancel_wps_callback(int result, GSupplicantInterface *interface,
+                            void *user_data)
+{
+	struct wifi_data *wifi = user_data;
+
+	DBG("result %d", result);
+
+	if (!is_wifi_valid(wifi))
+		return;
+
+	/* if we already assigned a network we have to remove it too */
+	if (wifi->network) {
+		connman_network_set_bool(wifi->network, "WiFi.UseWPS", FALSE);
+		connman_network_set_connected(wifi->network, FALSE);
+		wifi->network = NULL;
+	}
+
+	if (wifi->wps_timeout > 0) {
+		g_source_remove(wifi->wps_timeout);
+		wifi->wps_timeout = 0;
+	}
+
+	wifi->wps_active = FALSE;
+	/* already freed within gsupplicant layer */
+	wifi->wps_ssid = NULL;
+
+	enable_auto_connect_block(FALSE);
+}
+
+static int cancel_wps(struct wifi_data *wifi)
+{
+	int ret;
+
+	DBG("wifi %p", wifi);
+
+	ret = g_supplicant_interface_wps_cancel(wifi->interface, cancel_wps_callback, wifi);
+	if (ret == -EALREADY || ret == -EINPROGRESS)
+		ret = 0;
+
+	return ret;
+}
+
+static gboolean wps_timeout_cb(gpointer user_data)
+{
+	struct wifi_data *wifi = user_data;
+
+	DBG("");
+
+	if (!is_wifi_valid(wifi))
+		return FALSE;
+
+	cancel_wps(wifi);
+
+	connman_technology_wps_failed_notify(wifi_technology);
+
+	return FALSE;
+}
+
+static void wps_start_callback(int result, GSupplicantInterface *interface,
+                            void *user_data)
+{
+	struct wifi_data *wifi = user_data;
+
+	DBG("result %d", result);
+
+	if (result == 0)
+		return;
+
+	if (!is_wifi_valid(wifi))
+		return;
+
+	/* if we're at this place something went wrong an we have to clean up */
+	if (wifi->wps_timeout > 0) {
+		g_source_remove(wifi->wps_timeout);
+		wifi->wps_timeout = 0;
+	}
+
+	wifi->wps_active = FALSE;
+
+	connman_technology_wps_failed_notify(wifi_technology);
+}
+
+static int start_wps(struct wifi_data *wifi)
+{
+	int ret;
+
+	connman_info("start wps connection");
+
+	wifi->wps_timeout = g_timeout_add_seconds(WPS_CONNECT_TIMEOUT,
+							wps_timeout_cb, wifi);
+
+	ret = g_supplicant_interface_connect(wifi->interface, wifi->wps_ssid,
+						wps_start_callback, wifi);
+	if (ret == -EALREADY || ret == -EINPROGRESS)
+		ret = 0;
+
+	return ret;
+}
+
+static gboolean deferred_wps_start(struct wifi_data *wifi)
+{
+	DBG("WPS active %d", wifi->wps_active);
+
+	if(wifi->wps_active == FALSE)
+		return FALSE;
+
+	if(wifi->wps_start_deferred) {
+		wifi->network = NULL;
+		start_wps(wifi);
+		wifi->wps_start_deferred = FALSE;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static int wifi_start_wps(struct connman_device *device, const char *pin)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+	GSupplicantSSID *ssid;
+	int ret=0;
+
+	if (wifi->wps_active == TRUE)
+		return -EINPROGRESS;
+
+	DBG("");
+
+	ssid = g_try_malloc0(sizeof(GSupplicantSSID));
+	if (ssid == NULL)
+		return -ENOMEM;
+
+	ssid->use_wps = TRUE;
+	if(strlen(pin) == 0)
+		ssid->pin_wps = NULL;
+	else
+		ssid->pin_wps = g_strdup(pin);
+
+	wifi->wps_active = TRUE;
+	wifi->wps_ssid = ssid;
+
+	enable_auto_connect_block(TRUE);
+
+	/* if we're still disconnecting wait until we're completely disconnected */
+	if (wifi->disconnecting) {
+		DBG("Defering WPS until disconnect is done");
+		wifi->wps_start_deferred = TRUE;
+		return 0;
+	}
+
+	/* This is ahead of what will happen if we have an associating network
+	 * at this point. Once we issue the StartWPS command to wpa-supplicant
+	 * the network will be disconnected and we will receive the interface
+	 * state change signal. As we're in the middle of the WPS process we
+	 * don't handle that there ... */
+	if (wifi->network) {
+		connman_network_set_connected(wifi->network, FALSE);
+		connman_network_set_associating(wifi->network, FALSE);
+		wifi->network = NULL;
+	}
+
+	return start_wps(wifi);
+}
+
+static int wifi_cancel_wps(struct connman_device *device)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+
+	DBG("");
+
+	if (wifi->wps_active == FALSE)
+		return 0;
+
+	return cancel_wps(wifi);
+}
+
+static void cancel_p2p_callback(int result, GSupplicantInterface *interface,
+							void *user_data)
+{
+	struct connman_device *device = user_data;
+
+	DBG("result %d", result);
+
+	if (!device)
+		return;
+
+	//Do not p2p find on webOS 4.5 platform
+	//p2p_find(device);
+}
+
+static int wifi_cancel_p2p(struct connman_device *device)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+	int ret = 0;
+
+	if (!wifi || !wifi->device)
+		return -EINVAL;
+
+	DBG("");
+
+	if (p2p_go_identifier != NULL) {
+		/* disconnect the group only if there are no existing connected peers */
+			struct connman_group *group = __connman_group_lookup_from_ident(p2p_go_identifier);
+
+			if (group != NULL) {
+
+				if (__connman_group_get_list_length(group) == 0)
+					__connman_group_peer_failed(group);
+
+				return 0;
+			}
+	}
+
+	ret = g_supplicant_interface_p2p_cancel(wifi->interface, cancel_p2p_callback, wifi->device);
+	if (ret == -EALREADY || ret == -EINPROGRESS) {
+		ret = 0;
+
+		connman_peer_state_change_by_cancelled();
+	}
+
+	return ret;
+}
+
+static void signal_info_cb(int result, GSupplicantInterface *interface, void *user_data)
+{
+	struct wifi_cb_data *data = user_data;
+	connman_device_request_signal_info_cb cb = data->callback;
+	unsigned int value;
+
+	if (result < 0)
+		goto done;
+
+	value = g_supplicant_interface_get_rssi(interface);
+	connman_device_set_integer(data->wifi->device, "WiFi.RSSI", value);
+
+	value = g_supplicant_interface_get_link_speed(interface);
+	connman_device_set_integer(data->wifi->device, "WiFi.LinkSpeed", value);
+
+	value = g_supplicant_interface_get_frequency(interface);
+	connman_device_set_integer(data->wifi->device, "WiFi.Frequency", value);
+
+	value = g_supplicant_interface_get_noise(interface);
+	connman_device_set_integer(data->wifi->device, "WiFi.Noise", value);
+
+done:
+	cb(data->wifi->device, data->user_data);
+
+	g_free(data);
+}
+
+static int wifi_get_signal_info(struct connman_device *device, connman_device_request_signal_info_cb cb, void *user_data)
+{
+	struct wifi_data *wifi = connman_device_get_data(device);
+	struct wifi_cb_data *data;
+
+	if (!wifi)
+		return -EINVAL;
+
+	data = g_new0(struct wifi_cb_data, 1);
+	if (!data)
+		return -ENOMEM;
+
+	data->callback = cb;
+	data->user_data = user_data;
+	data->wifi = wifi;
+
+	return g_supplicant_interface_update_signal_info(wifi->interface, signal_info_cb, data);
+}
+
+static struct connman_device_driver wifi_ng_driver = {
+	.name		= "wifi",
+	.type		= CONNMAN_DEVICE_TYPE_WIFI,
+	.priority	= CONNMAN_DEVICE_PRIORITY_LOW,
+	.probe		= wifi_probe,
+	.remove		= wifi_remove,
+	.enable		= wifi_enable,
+	.disable	= wifi_disable,
+	.scan		= wifi_scan,
+	.stop_scan	= wifi_stop_scan,
+	.set_regdom	= wifi_set_regdom,
+	.start_wps	= wifi_start_wps,
+	.cancel_wps	= wifi_cancel_wps,
+	.cancel_p2p	= wifi_cancel_p2p,
+	.get_signal_info = wifi_get_signal_info,
+};
+
+static void system_ready(void)
+{
+	DBG("");
+
+	if (connman_device_driver_register(&wifi_ng_driver) < 0)
+		connman_error("Failed to register WiFi driver");
+}
+
+static void system_killed(void)
+{
+	DBG("");
+
+	connman_device_driver_unregister(&wifi_ng_driver);
+}
+
+static int network_probe(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+static int network_connect(struct connman_network *network);
+
+static gboolean perform_deferred_connect_after_disconnect(struct wifi_data *wifi)
+{
+	if (wifi->pending_network != NULL) {
+		network_connect(wifi->pending_network);
+		wifi->pending_network = NULL;
+		return TRUE;
+	}
+
+	if (deferred_wps_start(wifi)) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static void network_remove(struct connman_network *network)
+{
+	struct connman_device *device = connman_network_get_device(network);
+	struct wifi_data *wifi;
+
+	DBG("network %p", network);
+
+	wifi = connman_device_get_data(device);
+	if (!wifi)
+		return;
+
+	if (wifi->network != network)
+		return;
+	else {
+		wifi->disconnecting = FALSE;
+		perform_deferred_connect_after_disconnect(wifi);
+	}
+
+	wifi->network = NULL;
+}
+
+static void connect_callback(int result, GSupplicantInterface *interface,
+							void *user_data)
+{
+	struct connman_network *network = user_data;
+
+	DBG("network %p result %d", network, result);
+
+	if (result == -ENOKEY) {
+		connman_network_set_error(network,
+					CONNMAN_NETWORK_ERROR_INVALID_KEY);
+	} else if (result < 0) {
+		connman_network_set_error(network,
+					CONNMAN_NETWORK_ERROR_CONFIGURE_FAIL);
+	}
+
+	connman_network_unref(network);
+}
+
+static GSupplicantSecurity network_security(const char *security)
+{
+	if (g_str_equal(security, "none"))
+		return G_SUPPLICANT_SECURITY_NONE;
+	else if (g_str_equal(security, "wep"))
+		return G_SUPPLICANT_SECURITY_WEP;
+	else if (g_str_equal(security, "psk"))
+		return G_SUPPLICANT_SECURITY_PSK;
+	else if (g_str_equal(security, "wpa"))
+		return G_SUPPLICANT_SECURITY_PSK;
+	else if (g_str_equal(security, "rsn"))
+		return G_SUPPLICANT_SECURITY_PSK;
+	else if (g_str_equal(security, "ieee8021x"))
+		return G_SUPPLICANT_SECURITY_IEEE8021X;
+
+	return G_SUPPLICANT_SECURITY_UNKNOWN;
+}
+
+static void ssid_init(GSupplicantSSID *ssid, struct connman_network *network)
+{
+	const char *security;
+
+	memset(ssid, 0, sizeof(*ssid));
+	ssid->mode = G_SUPPLICANT_MODE_INFRA;
+	ssid->ssid = connman_network_get_blob(network, "WiFi.SSID",
+						&ssid->ssid_len);
+	ssid->scan_ssid = 1;
+	security = connman_network_get_string(network, "WiFi.Security");
+	ssid->security = network_security(security);
+	ssid->passphrase = connman_network_get_string(network,
+						"WiFi.Passphrase");
+
+	ssid->eap = connman_network_get_string(network, "WiFi.EAP");
+
+	/*
+	 * If our private key password is unset,
+	 * we use the supplied passphrase. That is needed
+	 * for PEAP where 2 passphrases (identity and client
+	 * cert may have to be provided.
+	 */
+	if (!connman_network_get_string(network, "WiFi.PrivateKeyPassphrase"))
+		connman_network_set_string(network,
+						"WiFi.PrivateKeyPassphrase",
+						ssid->passphrase);
+	/* We must have an identity for both PEAP and TLS */
+	ssid->identity = connman_network_get_string(network, "WiFi.Identity");
+
+	/* Use agent provided identity as a fallback */
+	if (!ssid->identity || strlen(ssid->identity) == 0)
+		ssid->identity = connman_network_get_string(network,
+							"WiFi.AgentIdentity");
+
+	ssid->anonymous_identity = connman_network_get_string(network,
+						"WiFi.AnonymousIdentity");
+	ssid->ca_cert_path = connman_network_get_string(network,
+							"WiFi.CACertFile");
+	ssid->subject_match = connman_network_get_string(network,
+							"WiFi.SubjectMatch");
+	ssid->altsubject_match = connman_network_get_string(network,
+							"WiFi.AltSubjectMatch");
+	ssid->domain_suffix_match = connman_network_get_string(network,
+							"WiFi.DomainSuffixMatch");
+	ssid->domain_match = connman_network_get_string(network,
+							"WiFi.DomainMatch");
+	ssid->client_cert_path = connman_network_get_string(network,
+							"WiFi.ClientCertFile");
+	ssid->private_key_path = connman_network_get_string(network,
+							"WiFi.PrivateKeyFile");
+	ssid->private_key_passphrase = connman_network_get_string(network,
+						"WiFi.PrivateKeyPassphrase");
+	ssid->phase2_auth = connman_network_get_string(network, "WiFi.Phase2");
+
+	ssid->use_wps = connman_network_get_bool(network, "WiFi.UseWPS");
+	ssid->pin_wps = connman_network_get_string(network, "WiFi.PinWPS");
+
+	if (connman_setting_get_bool("BackgroundScanning"))
+		ssid->bgscan = BGSCAN_DEFAULT;
+}
+
+static int network_connect(struct connman_network *network)
+{
+	struct connman_device *device = connman_network_get_device(network);
+	struct wifi_data *wifi;
+	GSupplicantInterface *interface;
+	GSupplicantSSID *ssid;
+
+	DBG("network %p", network);
+
+	if (!device)
+		return -ENODEV;
+
+	wifi = connman_device_get_data(device);
+	if (!wifi)
+		return -ENODEV;
+
+	if (wifi->wps_active)
+		return -EINPROGRESS;
+
+	ssid = g_try_malloc0(sizeof(GSupplicantSSID));
+	if (!ssid)
+		return -ENOMEM;
+
+	interface = wifi->interface;
+
+	p2p_stop_find(wifi);
+	ssid_init(ssid, network);
+
+	if (wifi->disconnecting) {
+		wifi->pending_network = network;
+		g_free(ssid);
+	} else {
+		wifi->network = connman_network_ref(network);
+		wifi->retries = 0;
+
+		if (p2p_technology && is_technology_enabled(p2p_technology) &&
+			connman_technology_get_p2p_listen(p2p_technology) == true) {
+			set_p2p_listen_without_state_change(p2p_technology, false);
+
+			wifi->p2p_listen_suppressed = true;
+			if (p2p_find_ref == -1)
+				g_supplicant_interface_p2p_stop_find(wifi->interface);
+		}
+		return g_supplicant_interface_connect(interface, ssid,
+						connect_callback, network);
+	}
+
+	return -EINPROGRESS;
+}
+
+static void disconnect_callback(int result, GSupplicantInterface *interface,
+								void *user_data)
+{
+	struct wifi_data *wifi = user_data;
+
+	DBG("result %d supplicant interface %p wifi %p",
+			result, interface, wifi);
+
+	if (result == -ECONNABORTED) {
+		DBG("wifi interface no longer available");
+		return;
+	}
+
+	if (wifi->network && wifi->network != wifi->pending_network)
+		connman_network_set_connected(wifi->network, false);
+	wifi->network = NULL;
+
+	wifi->disconnecting = false;
+	wifi->connected = false;
+
+	if (perform_deferred_connect_after_disconnect(wifi) == FALSE)
+	{
+		start_autoscan(wifi->device);
+	}
+}
+
+static int network_disconnect(struct connman_network *network)
+{
+	struct connman_device *device = connman_network_get_device(network);
+	struct wifi_data *wifi;
+	int err;
+
+	DBG("network %p", network);
+
+	wifi = connman_device_get_data(device);
+	if (!wifi || !wifi->interface)
+		return -ENODEV;
+
+	connman_network_set_associating(network, false);
+
+	if (wifi->disconnecting)
+		return -EALREADY;
+
+	wifi->disconnecting = true;
+
+	err = g_supplicant_interface_disconnect(wifi->interface,
+						disconnect_callback, wifi);
+	if (err < 0)
+		wifi->disconnecting = false;
+
+	return err;
+}
+
+static struct connman_network_driver network_driver = {
+	.name		= "wifi",
+	.type		= CONNMAN_NETWORK_TYPE_WIFI,
+	.priority	= CONNMAN_NETWORK_PRIORITY_LOW,
+	.probe		= network_probe,
+	.remove		= network_remove,
+	.connect	= network_connect,
+	.disconnect	= network_disconnect,
+};
+
+static void interface_added(GSupplicantInterface *interface)
+{
+	const char *ifname = g_supplicant_interface_get_ifname(interface);
+	const char *driver = g_supplicant_interface_get_driver(interface);
+	struct wifi_data *wifi;
+
+	wifi = g_supplicant_interface_get_data(interface);
+	if (!wifi) {
+		wifi = get_pending_wifi_data(ifname);
+		if (!wifi)
+			return;
+
+		wifi->interface = interface;
+		g_supplicant_interface_set_data(interface, wifi);
+		p2p_iface_list = g_list_append(p2p_iface_list, wifi);
+		wifi->p2p_device = true;
+	}
+
+	DBG("ifname %s driver %s wifi %p tethering %d",
+			ifname, driver, wifi, wifi->tethering);
+
+	if (!wifi->device) {
+		connman_error("WiFi device not set");
+		return;
+	}
+
+	connman_device_set_powered(wifi->device, true);
+}
+
+static bool is_idle(struct wifi_data *wifi)
+{
+	DBG("state %d", wifi->state);
+
+	switch (wifi->state) {
+	case G_SUPPLICANT_STATE_UNKNOWN:
+	case G_SUPPLICANT_STATE_DISABLED:
+	case G_SUPPLICANT_STATE_DISCONNECTED:
+	case G_SUPPLICANT_STATE_INACTIVE:
+	case G_SUPPLICANT_STATE_SCANNING:
+		return true;
+
+	case G_SUPPLICANT_STATE_AUTHENTICATING:
+	case G_SUPPLICANT_STATE_ASSOCIATING:
+	case G_SUPPLICANT_STATE_ASSOCIATED:
+	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
+	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
+	case G_SUPPLICANT_STATE_COMPLETED:
+		return false;
+	}
+
+	return false;
+}
+
+static bool is_idle_wps(GSupplicantInterface *interface,
+						struct wifi_data *wifi)
+{
+	/* First, let's check if WPS processing did not went wrong */
+	if (g_supplicant_interface_get_wps_state(interface) ==
+		G_SUPPLICANT_WPS_STATE_FAIL)
+		return false;
+
+	/* Unlike normal connection, being associated while processing wps
+	 * actually means that we are idling. */
+	switch (wifi->state) {
+	case G_SUPPLICANT_STATE_UNKNOWN:
+	case G_SUPPLICANT_STATE_DISABLED:
+	case G_SUPPLICANT_STATE_DISCONNECTED:
+	case G_SUPPLICANT_STATE_INACTIVE:
+	case G_SUPPLICANT_STATE_SCANNING:
+	case G_SUPPLICANT_STATE_ASSOCIATED:
+		return true;
+	case G_SUPPLICANT_STATE_AUTHENTICATING:
+	case G_SUPPLICANT_STATE_ASSOCIATING:
+	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
+	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
+	case G_SUPPLICANT_STATE_COMPLETED:
+		return false;
+	}
+
+	return false;
+}
+
+static bool handle_wps_completion(GSupplicantInterface *interface,
+					struct connman_network *network,
+					struct connman_device *device,
+					struct wifi_data *wifi)
+{
+	bool wps;
+
+	wps = connman_network_get_bool(network, "WiFi.UseWPS");
+	if (wps) {
+		const unsigned char *ssid, *wps_ssid;
+		unsigned int ssid_len, wps_ssid_len;
+		const char *wps_key;
+
+		if (wifi->wps_active == FALSE) {
+			/* Checking if we got associated with requested
+			 * network */
+			ssid = connman_network_get_blob(network, "WiFi.SSID",
+							&ssid_len);
+
+			wps_ssid = g_supplicant_interface_get_wps_ssid(
+				interface, &wps_ssid_len);
+
+			if (!wps_ssid || wps_ssid_len != ssid_len ||
+					memcmp(ssid, wps_ssid, ssid_len) != 0) {
+				connman_network_set_associating(network, false);
+				g_supplicant_interface_disconnect(wifi->interface,
+							disconnect_callback, wifi);
+				return false;
+			}
+		}
+
+		wps_key = g_supplicant_interface_get_wps_key(interface);
+		connman_network_set_string(network, "WiFi.Passphrase",
+					wps_key);
+
+		connman_network_set_string(network, "WiFi.PinWPS", NULL);
+	}
+
+	return true;
+}
+
+static bool handle_assoc_status_code(GSupplicantInterface *interface,
+                                     struct wifi_data *wifi)
+{
+	if (wifi->state == G_SUPPLICANT_STATE_ASSOCIATING &&
+			wifi->assoc_code == ASSOC_STATUS_NO_CLIENT &&
+			wifi->load_shaping_retries < LOAD_SHAPING_MAX_RETRIES) {
+		wifi->load_shaping_retries ++;
+		return TRUE;
+	}
+	wifi->load_shaping_retries = 0;
+	return FALSE;
+}
+
+static bool handle_4way_handshake_failure(GSupplicantInterface *interface,
+					struct connman_network *network,
+					struct wifi_data *wifi)
+{
+	struct connman_service *service;
+
+	if (wifi->state != G_SUPPLICANT_STATE_4WAY_HANDSHAKE)
+		return false;
+
+	if (wifi->connected)
+		return false;
+
+	service = connman_service_lookup_from_network(network);
+	if (!service)
+		return false;
+
+	wifi->retries++;
+
+	if (connman_service_get_favorite(service)) {
+		if (wifi->retries < FAVORITE_MAXIMUM_RETRIES)
+			return true;
+	}
+
+	wifi->retries = 0;
+	connman_network_set_error(network, CONNMAN_NETWORK_ERROR_INVALID_KEY);
+
+	return false;
+}
+
+static void wps_state(GSupplicantInterface *interface)
+{
+	struct wifi_data *wifi;
+	GSupplicantWpsState state = g_supplicant_interface_get_wps_state(interface);
+	const char *wps_ssid, *ssid;
+	unsigned int wps_ssid_len, ssid_len;
+	GSList *list;
+	struct connman_network *found_network = NULL;
+
+	wifi = g_supplicant_interface_get_data(interface);
+
+	if(wifi==NULL)
+		return;
+
+	if (wifi->wps_active == FALSE)
+		return;
+
+	wps_ssid = g_supplicant_interface_get_wps_ssid(interface, &wps_ssid_len);
+
+	DBG("wifi %p wps state %d ssid %s", wifi, state, wps_ssid);
+
+	g_source_remove(wifi->wps_timeout);
+	wifi->wps_timeout = 0;
+
+	switch (state) {
+	case G_SUPPLICANT_WPS_STATE_UNKNOWN:
+		return;
+	case G_SUPPLICANT_WPS_STATE_FAIL:
+	wifi->wps_active = FALSE;
+	connman_technology_wps_failed_notify(wifi_technology);
+	return;
+	}
+
+	for (list = wifi->networks; list != NULL; list = list->next) {
+		struct connman_network *network = list->data;
+
+		ssid = connman_network_get_blob(network, "WiFi.SSID", &ssid_len);
+
+		if (ssid != NULL && wps_ssid_len == ssid_len &&
+		    memcmp(ssid, wps_ssid, ssid_len) == 0) {
+			DBG("found network %s", ssid);
+			connman_network_set_bool(network, "WiFi.UseWPS", TRUE);
+			found_network = network;
+			break;
+		}
+	}
+
+	if (found_network == NULL) {
+		DBG("didn't found a network for ssid %s", wps_ssid);
+		g_supplicant_interface_disconnect(wifi->interface,
+		disconnect_callback, wifi);
+		return;
+	}
+
+	/* we've found the correct network so we connect as normal
+	 * in our connection process */
+	wifi->network = found_network;
+}
+
+static void interface_state(GSupplicantInterface *interface)
+{
+	struct connman_network *network;
+	struct connman_device *device;
+	struct wifi_data *wifi;
+	GSupplicantState state = g_supplicant_interface_get_state(interface);
+	bool wps;
+	GSList *list;
+	bool old_connected;
+	const char *wps_ssid, *ssid;
+	unsigned int wps_ssid_len, ssid_len;
+
+	wifi = g_supplicant_interface_get_data(interface);
+
+	DBG("wifi %p interface state %d", wifi, state);
+
+	if (!wifi)
+		return;
+
+	device = wifi->device;
+	if (!device)
+		return;
+
+	if (state == G_SUPPLICANT_STATE_COMPLETED) {
+		if (wifi->tethering_param) {
+			g_free(wifi->tethering_param->ssid);
+			g_free(wifi->tethering_param);
+			wifi->tethering_param = NULL;
+		}
+
+		if (wifi->tethering)
+			stop_autoscan(device);
+	}
+
+	if (g_supplicant_interface_get_ready(interface) &&
+					!wifi->interface_ready) {
+		wifi->interface_ready = true;
+		finalize_interface_creation(wifi);
+	}
+
+	network = wifi->network;
+	if (!network)
+		return;
+
+	wps_ssid = g_supplicant_interface_get_wps_ssid(interface, &wps_ssid_len);
+	if (!network && wifi->wps_active && wps_ssid_len) {
+		for (list = wifi->networks; list != NULL; list = list->next) {
+			struct connman_network *connected_network = list->data;
+
+			ssid = connman_network_get_blob(connected_network, "WiFi.SSID", &ssid_len);
+			if (ssid != NULL && wps_ssid_len == ssid_len &&
+				memcmp(ssid, wps_ssid, ssid_len) == 0) {
+				DBG("found network %s", ssid);
+				connman_network_set_bool(connected_network, "WiFi.UseWPS", TRUE);
+				wifi->network = connected_network;
+				network = wifi->network;
+				break;
+			}
+		}
+	}
+
+	switch (state) {
+	case G_SUPPLICANT_STATE_SCANNING:
+		if (wifi->connected)
+			connman_network_set_connected(network, false);
+
+		break;
+
+	case G_SUPPLICANT_STATE_AUTHENTICATING:
+	case G_SUPPLICANT_STATE_ASSOCIATING:
+		stop_autoscan(device);
+
+		connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_WIFI,FALSE);
+		if (!wifi->connected)
+			connman_network_set_associating(network, true);
+
+		break;
+
+	case G_SUPPLICANT_STATE_COMPLETED:
+		/* though it should be already stopped: */
+		stop_autoscan(device);
+
+		connman_device_set_scanning(device,CONNMAN_SERVICE_TYPE_WIFI,FALSE);
+		if (!handle_wps_completion(interface, network, device, wifi))
+			break;
+
+		connman_network_set_connected(network, true);
+
+		wifi->disconnect_code = 0;
+		wifi->assoc_code = 0;
+		wifi->load_shaping_retries = 0;
+		wifi->wps_active = FALSE;
+		break;
+
+	case G_SUPPLICANT_STATE_DISCONNECTED:
+		/*
+		 * If we're in one of the idle modes, we have
+		 * not started association yet and thus setting
+		 * those ones to FALSE could cancel an association
+		 * in progress.
+		 */
+		wps = connman_network_get_bool(network, "WiFi.UseWPS");
+		if (wps)
+			if (is_idle_wps(interface, wifi))
+				break;
+
+		if (is_idle(wifi))
+			break;
+
+		if (handle_assoc_status_code(interface, wifi))
+			break;
+
+		/* If previous state was 4way-handshake, then
+		 * it's either: psk was incorrect and thus we retry
+		 * or if we reach the maximum retries we declare the
+		 * psk as wrong */
+		if (handle_4way_handshake_failure(interface,
+						network, wifi))
+			break;
+
+		/* See table 8-36 Reason codes in IEEE Std 802.11 */
+		switch (wifi->disconnect_code) {
+		case 1: /* Unspecified reason */
+			/* Let's assume it's because we got blocked */
+
+		case 6: /* Class 2 frame received from nonauthenticated STA */
+			connman_network_set_error(network,
+						CONNMAN_NETWORK_ERROR_BLOCKED);
+			break;
+
+		default:
+			break;
+		}
+
+		if (network != wifi->pending_network) {
+			connman_network_set_connected(network, false);
+			connman_network_set_associating(network, false);
+		}
+		wifi->disconnecting = false;
+
+		if (!deferred_wps_start(wifi))
+		{
+			/* Set connected to false to allow autoscan to start. */
+			wifi->connected = FALSE;
+		    start_autoscan(device);
+		}
+
+		break;
+
+	case G_SUPPLICANT_STATE_INACTIVE:
+		connman_network_set_associating(network, false);
+		start_autoscan(device);
+
+		break;
+
+	case G_SUPPLICANT_STATE_UNKNOWN:
+	case G_SUPPLICANT_STATE_DISABLED:
+	case G_SUPPLICANT_STATE_ASSOCIATED:
+	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
+	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
+		break;
+	}
+
+	old_connected = wifi->connected;
+	wifi->state = state;
+
+	/* Saving wpa_s state policy:
+	 * If connected and if the state changes are roaming related:
+	 * --> We stay connected
+	 * If completed
+	 * --> We are connected
+	 * All other case:
+	 * --> We are not connected
+	 * */
+	switch (state) {
+	case G_SUPPLICANT_STATE_AUTHENTICATING:
+	case G_SUPPLICANT_STATE_ASSOCIATING:
+	case G_SUPPLICANT_STATE_ASSOCIATED:
+	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
+	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
+		if (wifi->connected)
+			connman_warn("Probably roaming right now!"
+						" Staying connected...");
+		break;
+	case G_SUPPLICANT_STATE_SCANNING:
+		wifi->connected = false;
+
+		if (old_connected)
+			start_autoscan(device);
+		break;
+	case G_SUPPLICANT_STATE_COMPLETED:
+		wifi->connected = true;
+		break;
+	default:
+		wifi->connected = false;
+		break;
+	}
+
+	DBG("DONE");
+}
+
+static void interface_removed(GSupplicantInterface *interface)
+{
+	const char *ifname = g_supplicant_interface_get_ifname(interface);
+	struct wifi_data *wifi;
+	int err;
+
+	DBG("ifname %s", ifname);
+	GSList *list;
+
+	for (list = iface_list; list; list = list->next) {
+		wifi = list->data;
+		GSupplicantInterface *p2p_interface = wifi->interface;
+
+		if (!p2p_interface || !g_supplicant_interface_has_p2p(p2p_interface))
+			continue;
+
+		if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+				g_strcmp0(g_supplicant_interface_get_ifname(p2p_interface),
+					connman_option_get_string("P2PDevice")) != 0)
+			continue;
+
+		if (connman_technology_get_p2p_listen(p2p_technology) == false &&
+				!__connman_peer_get_connected_exists()) {
+			if (!connman_technology_get_enable_p2p_listen(p2p_technology))
+				return;
+			err = apply_p2p_listen_on_iface(wifi, &params);
+			if (err == 0)
+				connman_technology_set_p2p_listen(p2p_technology, true);
+		}
+	}
+
+	wifi = g_supplicant_interface_get_data(interface);
+
+	if (wifi)
+		wifi->interface = NULL;
+
+	if (wifi && wifi->tethering)
+		return;
+
+	if (!wifi || !wifi->device) {
+		DBG("wifi interface already removed");
+		return;
+	}
+
+	connman_device_set_powered(wifi->device, false);
+
+	check_p2p_technology();
+}
+
+static void set_device_type(const char *type, char dev_type[17])
+{
+	const char *oui = "0050F204";
+	const char *category = "0001";
+	const char *sub_category = "0000";
+
+	if (!g_strcmp0(type, "handset")) {
+		category = "000A";
+		sub_category = "0005";
+	} else if (!g_strcmp0(type, "vm") || !g_strcmp0(type, "container"))
+		sub_category = "0001";
+	else if (!g_strcmp0(type, "server"))
+		sub_category = "0002";
+	else if (!g_strcmp0(type, "laptop"))
+		sub_category = "0005";
+	else if (!g_strcmp0(type, "desktop"))
+		sub_category = "0006";
+	else if (!g_strcmp0(type, "tablet"))
+		sub_category = "0009";
+	else if (!g_strcmp0(type, "watch"))
+		category = "00FF";
+
+	snprintf(dev_type, 17, "%s%s%s", category, oui, sub_category);
+}
+
+static void p2ps_prov_start(GSupplicantInterface *interface,  GSupplicantPeer *peer, GSupplicantP2PSProvisionSignalParams* params)
+{
+	struct wifi_data *wifi;
+	const char *identifier;
+	struct connman_network *connman_network;
+
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_peer_get_identifier(peer);
+
+	DBG("identifier %s", identifier);
+
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (connman_network == NULL)
+		return;
+
+	//wfds_on_p2ps_prov_start(connman_network, params);
+}
+
+static void p2ps_prov_done(GSupplicantInterface *interface,  GSupplicantPeer *peer, GSupplicantP2PSProvisionSignalParams* params)
+{
+	struct wifi_data *wifi;
+	const char *identifier;
+	struct connman_network *connman_network;
+
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_peer_get_identifier(peer);
+
+	DBG("identifier %s", identifier);
+
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (connman_network == NULL)
+		return;
+
+	//wfds_on_p2ps_prov_done(connman_network, params);
+}
+
+static GSupplicantSSID *ssid_persistent_init(GSupplicantP2PPersistentGroup *persistent_group, int go)
+{
+	GSupplicantSSID *p_ssid;
+
+	p_ssid = g_try_malloc0(sizeof(GSupplicantSSID));
+	if (p_ssid == NULL)
+		return NULL;
+
+	if(go == 1)
+		p_ssid->mode = G_SUPPLICANT_MODE_MASTER;
+	else
+		p_ssid->mode = G_SUPPLICANT_MODE_UNKNOWN;
+	p_ssid->ssid = g_strdup(persistent_group->ssid);
+	p_ssid->ssid_len = strlen(persistent_group->ssid);
+	p_ssid->scan_ssid = 0;
+	p_ssid->bssid = g_strdup(persistent_group->bssid);
+	p_ssid->passphrase= g_strdup(persistent_group->psk);
+
+	p_ssid->security = G_SUPPLICANT_SECURITY_PSK;
+	p_ssid->protocol = G_SUPPLICANT_PROTO_RSN;
+	p_ssid->pairwise_cipher = G_SUPPLICANT_PAIRWISE_CCMP;
+	p_ssid->group_cipher = G_SUPPLICANT_GROUP_CCMP;
+
+	return p_ssid;
+}
+
+static int p2p_persistent_info_load(GSupplicantInterface *interface, const char *persistent_dir, GSupplicantP2PPersistentGroup *persistent_group)
+{
+	GKeyFile *keyfile;
+	const char *ssid=NULL, *bssid=NULL, *psk=NULL, *role=NULL, *mac_address=NULL;
+	int ret = -1;
+	unsigned long long connectedtime=0;
+
+	keyfile = __connman_storage_open_service(persistent_dir);
+	if(keyfile == NULL)
+		return -EIO;
+
+	ssid = g_key_file_get_string(keyfile, P2P_PERSISTENT_INFO, "SSID", NULL);
+	bssid = g_key_file_get_string(keyfile, P2P_PERSISTENT_INFO, "BSSID", NULL);
+	psk = g_key_file_get_string(keyfile, P2P_PERSISTENT_INFO, "PSK", NULL);
+	role = g_key_file_get_string(keyfile, P2P_PERSISTENT_INFO, "Role", NULL);
+	mac_address = g_key_file_get_string(keyfile, P2P_PERSISTENT_INFO, "MAC", NULL);
+	connectedtime = g_key_file_get_uint64(keyfile, P2P_PERSISTENT_INFO, "ConnectedTime", NULL);
+
+	g_key_file_free(keyfile);
+
+	if (mac_address) {
+		struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+		if (wifi) {
+			char * p2p_ident = __connman_util_insert_colon_to_mac_addr(connman_device_get_ident(wifi->device));
+			if (strncmp(mac_address, p2p_ident, 17) != 0) {
+				// P2P MAC address changed, so removing this p2p service
+				__connman_storage_remove_service(persistent_dir);
+				g_free(p2p_ident);
+				goto cleanup;
+			}
+			g_free(p2p_ident);
+		}
+	}
+
+	if(ssid != NULL && bssid != NULL && psk != NULL) {
+		DBG("ssid : %s bssid : %s psk : %s connectedtime : %llu\n", ssid, bssid, psk, connectedtime);
+
+		persistent_group->interface = interface;
+		persistent_group->ssid = g_strdup(ssid);
+		persistent_group->bssid = g_strdup(bssid);
+		persistent_group->psk = g_strdup(psk);
+		persistent_group->connected_time = connectedtime;
+
+		if(g_str_equal(role, "GO")) {
+			persistent_group->go = TRUE;
+			ret = 1;
+		} else if(g_str_equal(role, "Client")) {
+			persistent_group->go = FALSE;
+			ret = 0;
+		} else
+			ret = -1;
+	}
+
+cleanup:
+	g_free(mac_address);
+	g_free(role);
+	g_free(psk);
+	g_free(bssid);
+	g_free(ssid);
+	return ret;
+}
+
+static void ssid_persistent_free(GSupplicantSSID *p_ssid)
+{
+	if (p_ssid == NULL)
+		return;
+
+	if (p_ssid->ssid)
+		g_free(p_ssid->ssid);
+	if (p_ssid->bssid)
+		g_free(p_ssid->bssid);
+	if (p_ssid->passphrase)
+		g_free(p_ssid->passphrase);
+
+	g_free(p_ssid);
+	p_ssid = NULL;
+}
+
+
+static int add_persistent_group_info(struct wifi_data *wifi)
+{
+	GSupplicantInterface *interface;
+	gchar **persistents;
+	GSupplicantP2PPersistentGroup *persistent_group;
+	int go;
+	char *peer;
+	int i;
+
+	if(wifi == NULL)
+		return -ENOMEM;
+
+	interface = wifi->interface;
+
+	if(interface == NULL)
+		return -ENOMEM;
+
+	persistents = __connman_storage_get_p2p_persistents();
+        if (!persistents)
+            return -ENOMEM;
+
+	for (i = 0; persistents && persistents[i]; i++) {
+		persistent_group = g_try_malloc0(sizeof(GSupplicantP2PPersistentGroup));
+		if(persistent_group == NULL) {
+			g_strfreev(persistents);
+			return -ENOMEM;
+		}
+
+		if (strncmp(persistents[i], "p2p_persistent_", 15) != 0) {
+			g_free(persistent_group);
+			continue;
+		}
+
+		go = p2p_persistent_info_load(interface, persistents[i], persistent_group);
+		if(go < 0) {
+			g_free(persistent_group);
+			continue;
+		}
+		else {
+			GSupplicantSSID *p_ssid = ssid_persistent_init(persistent_group, go);
+
+			if(p_ssid == NULL) {
+				g_free(persistent_group);
+				continue;
+			}
+
+			wifi->persistent_groups = g_slist_prepend(wifi->persistent_groups, persistent_group);
+
+			g_supplicant_interface_p2p_add_persistent_group(interface, p_ssid, &go);
+
+			peer = strrchr(persistents[i], '_') + 1;
+			g_hash_table_replace(wifi->persistent_peer_ssid, peer, persistent_group->ssid);
+			ssid_persistent_free(p_ssid);
+		}
+	}
+        g_strfreev(persistents);
+	return 1;
+}
+
+static void p2p_support(GSupplicantInterface *interface)
+{
+	struct wifi_data *wifi = NULL;
+
+	DBG("");
+
+	if (!interface)
+		return;
+
+	if (!g_supplicant_interface_has_p2p(interface))
+		return;
+
+	wifi = g_supplicant_interface_get_data(interface);
+
+	if (!wifi)
+		return;
+
+	if (connman_technology_driver_register(&p2p_tech_driver) < 0) {
+		DBG("Could not register P2P technology driver");
+		return;
+	}
+
+	connman_peer_driver_register(&peer_driver);
+}
+
+static void p2p_device_config_loaded(GSupplicantInterface *interface)
+{
+	struct wifi_data *wifi = NULL;
+	char dev_type[17] = {};
+	char hostname[HOST_NAME_MAX+1] = {0};
+	const char *p2p_identifier;
+	char *old_device_name = NULL, *old_ssid_postfix = NULL;
+	int result;
+
+	wifi = g_supplicant_interface_get_data(interface);
+
+	if (!wifi)
+		return;
+
+	p2p_identifier = load_p2p_identifier();
+	if (wifi->p2p_device_config.device_name)
+		old_device_name = wifi->p2p_device_config.device_name;
+
+	if (wifi->p2p_device_config.ssid_postfix)
+		old_ssid_postfix = wifi->p2p_device_config.ssid_postfix;
+
+	if (!p2p_identifier) {
+		if (gethostname(hostname, HOST_NAME_MAX) < 0)
+			return;
+
+		wifi->p2p_device_config.device_name = g_strdup(hostname);
+	}
+	else
+		wifi->p2p_device_config.device_name = g_strdup(p2p_identifier);
+
+	if (wifi->p2p_device_config.device_name) {
+		/* we have to add a hyphen here as wpa-supplicant just adds the postifx to the
+		 * automatically created SSID */
+		wifi->p2p_device_config.ssid_postfix = g_strdup_printf("-%s", wifi->p2p_device_config.device_name);
+	}
+
+	/**
+	 * TV icon type listed as Laptop. Reason is the machine type related interface org.freedesktop.hostname1
+	 * is not used ,commenting the below source ,using the type from wpa_supplicant as it is
+	 */
+	/*	set_device_type(connman_machine_get_type(), dev_type);
+	 dev_type_str2bin(dev_type, wifi->p2p_device_config.pri_dev_type);*/
+
+	result = g_supplicant_interface_set_p2p_device_configs(interface, &wifi->p2p_device_config, NULL);
+	if (result < 0) {
+		g_free(wifi->p2p_device_config.device_name);
+		g_free(wifi->p2p_device_config.ssid_postfix);
+		wifi->p2p_device_config.device_name = old_device_name;
+		wifi->p2p_device_config.ssid_postfix = old_ssid_postfix;
+	}
+
+	connman_technology_set_p2p_identifier(p2p_technology, wifi->p2p_device_config.device_name);
+	if (old_device_name != wifi->p2p_device_config.device_name)
+		g_free(old_device_name);
+	if (old_ssid_postfix != wifi->p2p_device_config.ssid_postfix)
+		g_free(old_ssid_postfix);
+
+    g_free(p2p_identifier);
+}
+
+static void scan_started(GSupplicantInterface *interface)
+{
+	DBG("");
+}
+
+static void scan_finished(GSupplicantInterface *interface)
+{
+	DBG("");
+}
+
+static void ap_create_fail(GSupplicantInterface *interface)
+{
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+	int ret;
+
+	if ((wifi->tethering) && (wifi->tethering_param)) {
+		DBG("%s create AP fail \n",
+				g_supplicant_interface_get_ifname(wifi->interface));
+
+		connman_inet_remove_from_bridge(wifi->index, wifi->bridge);
+		wifi->ap_supported = WIFI_AP_NOT_SUPPORTED;
+		wifi->tethering = false;
+
+		ret = tech_set_tethering(wifi->tethering_param->technology,
+				wifi->tethering_param->ssid->ssid,
+				wifi->tethering_param->ssid->passphrase,
+				wifi->bridge, true);
+
+		if ((ret == -EOPNOTSUPP) && (wifi_technology)) {
+			connman_technology_tethering_notify(wifi_technology,false);
+		}
+
+		g_free(wifi->tethering_param->ssid);
+		g_free(wifi->tethering_param);
+		wifi->tethering_param = NULL;
+	}
+}
+
+static unsigned char calculate_strength(GSupplicantNetwork *supplicant_network)
+{
+	unsigned char strength;
+
+	strength = 120 + g_supplicant_network_get_signal(supplicant_network);
+	if (strength > 100)
+		strength = 100;
+
+	return strength;
+}
+
+static unsigned char calculate_peer_strength(GSupplicantPeer *peer)
+{
+	unsigned char strength;
+
+	strength = 120 + g_supplicant_peer_get_level(peer);
+	if (strength > 100)
+		strength = 100;
+
+	return strength;
+}
+
+static void network_added(GSupplicantNetwork *supplicant_network)
+{
+	struct connman_network *network;
+	GSupplicantInterface *interface;
+	struct wifi_data *wifi;
+	const char *name, *identifier, *security, *group, *mode;
+	const unsigned char *ssid;
+	unsigned int ssid_len;
+	bool wps;
+	bool wps_pbc;
+	bool wps_ready;
+	bool wps_advertizing;
+	GHashTable *bss_table;
+
+	mode = g_supplicant_network_get_mode(supplicant_network);
+	identifier = g_supplicant_network_get_identifier(supplicant_network);
+
+	DBG("%s", identifier);
+
+	if (!g_strcmp0(mode, "adhoc"))
+		return;
+
+	interface = g_supplicant_network_get_interface(supplicant_network);
+	wifi = g_supplicant_interface_get_data(interface);
+	name = g_supplicant_network_get_name(supplicant_network);
+	security = g_supplicant_network_get_security(supplicant_network);
+	group = g_supplicant_network_get_identifier(supplicant_network);
+	wps = g_supplicant_network_get_wps(supplicant_network);
+	wps_pbc = g_supplicant_network_is_wps_pbc(supplicant_network);
+	wps_ready = g_supplicant_network_is_wps_active(supplicant_network);
+	wps_advertizing = g_supplicant_network_is_wps_advertizing(
+							supplicant_network);
+	bss_table = g_supplicant_network_get_bss_table(supplicant_network);
+
+	if (!wifi)
+		return;
+
+	ssid = g_supplicant_network_get_ssid(supplicant_network, &ssid_len);
+
+	network = connman_device_get_network(wifi->device, identifier);
+
+	if (!network) {
+		network = connman_network_create(identifier,
+						CONNMAN_NETWORK_TYPE_WIFI);
+		if (!network)
+			return;
+
+		connman_network_set_index(network, wifi->index);
+
+		if (connman_device_add_network(wifi->device, network) < 0) {
+			connman_network_unref(network);
+			return;
+		}
+
+		wifi->networks = g_slist_prepend(wifi->networks, network);
+	}
+
+	if (name && name[0] != '\0')
+		connman_network_set_name(network, name);
+
+	connman_network_set_blob(network, "WiFi.SSID",
+						ssid, ssid_len);
+	connman_network_set_string(network, "WiFi.Security", security);
+	connman_network_set_strength(network,
+				calculate_strength(supplicant_network));
+	connman_network_set_bool(network, "WiFi.WPS", wps);
+	connman_network_set_bool(network, "WiFi.WPSAdvertising",
+				wps_advertizing);
+
+	if (wps) {
+		/* Is AP advertizing for WPS association?
+		 * If so, we decide to use WPS by default */
+		if (wps_ready && wps_pbc &&
+						wps_advertizing)
+			connman_network_set_bool(network, "WiFi.UseWPS", true);
+	}
+
+	connman_network_set_frequency(network,
+			g_supplicant_network_get_frequency(supplicant_network));
+
+	connman_network_set_available(network, true);
+	connman_network_set_string(network, "WiFi.Mode", mode);
+
+	if (ssid)
+		connman_network_set_group(network, group);
+
+	if (wifi->hidden && ssid) {
+		if (!g_strcmp0(wifi->hidden->security, security) &&
+				wifi->hidden->ssid_len == ssid_len &&
+				!memcmp(wifi->hidden->ssid, ssid, ssid_len)) {
+			connman_network_connect_hidden(network,
+					wifi->hidden->identity,
+					wifi->hidden->passphrase,
+					wifi->hidden->user_data);
+			wifi->hidden->user_data = NULL;
+			hidden_free(wifi->hidden);
+			wifi->hidden = NULL;
+		}
+	}
+
+	connman_network_set_address(network, g_supplicant_network_get_bssid(supplicant_network), 6);
+
+	if (bss_table)
+		g_hash_table_foreach(bss_table, bss_foreach, network);
+}
+
+static void network_removed(GSupplicantNetwork *network)
+{
+	GSupplicantInterface *interface;
+	struct wifi_data *wifi;
+	const char *name, *identifier;
+	struct connman_network *connman_network;
+
+	interface = g_supplicant_network_get_interface(network);
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_network_get_identifier(network);
+	name = g_supplicant_network_get_name(network);
+
+	DBG("name %s", name);
+
+	if (!wifi)
+		return;
+
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
+
+	wifi->networks = g_slist_remove(wifi->networks, connman_network);
+
+	connman_device_remove_network(wifi->device, connman_network);
+	connman_network_unref(connman_network);
+}
+
+static void network_changed(GSupplicantNetwork *network, const char *property)
+{
+	GSupplicantInterface *interface;
+	struct wifi_data *wifi;
+	const char *name, *identifier;
+	struct connman_network *connman_network;
+	bool update_needed;
+	GHashTable *bss_table;
+
+	if (p2p_find_ref != -1)
+		return;
+
+	interface = g_supplicant_network_get_interface(network);
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_network_get_identifier(network);
+	name = g_supplicant_network_get_name(network);
+	bss_table = g_supplicant_network_get_bss_table(network);
+
+	DBG("name %s", name);
+
+	if (!wifi)
+		return;
+
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
+
+	connman_network_set_address(connman_network, g_supplicant_network_get_bssid(network), 6);
+
+	if (bss_table)
+		g_hash_table_foreach(bss_table, bss_foreach, connman_network);
+
+	if (g_str_equal(property, "WPSCapabilities")) {
+		bool wps;
+		bool wps_pbc;
+		bool wps_ready;
+		bool wps_advertizing;
 
-	interface = wifi->interface;
+		wps = g_supplicant_network_get_wps(network);
+		wps_pbc = g_supplicant_network_is_wps_pbc(network);
+		wps_ready = g_supplicant_network_is_wps_active(network);
+		wps_advertizing =
+			g_supplicant_network_is_wps_advertizing(network);
 
-	ssid_init(ssid, network);
+		connman_network_set_bool(connman_network, "WiFi.WPS", wps);
+		connman_network_set_bool(connman_network,
+				"WiFi.WPSAdvertising", wps_advertizing);
 
-	if (wifi->disconnecting) {
-		wifi->pending_network = network;
-		g_free(ssid);
-	} else {
-		wifi->network = connman_network_ref(network);
-		wifi->retries = 0;
+		if (wps) {
+			/*
+			 * Is AP advertizing for WPS association?
+			 * If so, we decide to use WPS by default
+			 */
+			if (wps_ready && wps_pbc && wps_advertizing)
+				connman_network_set_bool(connman_network,
+							"WiFi.UseWPS", true);
+		}
 
-		return g_supplicant_interface_connect(interface, ssid,
-						connect_callback, network);
-	}
+		update_needed = true;
+	} else if (g_str_equal(property, "Signal")) {
+		connman_network_set_strength(connman_network,
+					calculate_strength(network));
+		update_needed = true;
+	} else
+		update_needed = false;
 
-	return -EINPROGRESS;
+	if (update_needed)
+		connman_network_update(connman_network);
 }
 
-static void disconnect_callback(int result, GSupplicantInterface *interface,
-								void *user_data)
+static void network_associated(GSupplicantNetwork *network)
 {
-	struct wifi_data *wifi = user_data;
+	GSupplicantInterface *interface;
+	struct wifi_data *wifi;
+	struct connman_network *connman_network;
+	const char *identifier;
 
-	DBG("result %d supplicant interface %p wifi %p",
-			result, interface, wifi);
+	DBG("");
 
-	if (result == -ECONNABORTED) {
-		DBG("wifi interface no longer available");
+	interface = g_supplicant_network_get_interface(network);
+	if (!interface)
 		return;
-	}
-
-	if (wifi->network && wifi->network != wifi->pending_network)
-		connman_network_set_connected(wifi->network, false);
-	wifi->network = NULL;
 
-	wifi->disconnecting = false;
-	wifi->connected = false;
+	wifi = g_supplicant_interface_get_data(interface);
+	if (!wifi)
+		return;
 
-	if (perform_deferred_connect_after_disconnect(wifi) == FALSE)
-	{
-		start_autoscan(wifi->device);
-	}
-}
+	/* P2P networks must not be treated as WiFi networks */
+	if (wifi->p2p_connecting || wifi->p2p_device)
+		return;
 
-static int network_disconnect(struct connman_network *network)
-{
-	struct connman_device *device = connman_network_get_device(network);
-	struct wifi_data *wifi;
-	int err;
+	identifier = g_supplicant_network_get_identifier(network);
 
-	DBG("network %p", network);
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
 
-	wifi = connman_device_get_data(device);
-	if (!wifi || !wifi->interface)
-		return -ENODEV;
+	if (wifi->network) {
+		if (wifi->network == connman_network)
+			return;
 
-	connman_network_set_associating(network, false);
+		/*
+		 * This should never happen, we got associated with
+		 * a network different than the one we were expecting.
+		 */
+		DBG("Associated to %p while expecting %p",
+					connman_network, wifi->network);
 
-	if (wifi->disconnecting)
-		return -EALREADY;
+		connman_network_set_associating(wifi->network, false);
+	}
 
-	wifi->disconnecting = true;
+	DBG("Reconnecting to previous network %p from wpa_s", connman_network);
 
-	err = g_supplicant_interface_disconnect(wifi->interface,
-						disconnect_callback, wifi);
-	if (err < 0)
-		wifi->disconnecting = false;
+	wifi->network = connman_network_ref(connman_network);
+	wifi->retries = 0;
 
-	return err;
+	/*
+	 * Interface state changes callback (interface_state) is always
+	 * called before network_associated callback thus we need to call
+	 * interface_state again in order to process the new state now that
+	 * we have the network properly set.
+	 */
+	interface_state(interface);
 }
 
-static struct connman_network_driver network_driver = {
-	.name		= "wifi",
-	.type		= CONNMAN_NETWORK_TYPE_WIFI,
-	.priority	= CONNMAN_NETWORK_PRIORITY_LOW,
-	.probe		= network_probe,
-	.remove		= network_remove,
-	.connect	= network_connect,
-	.disconnect	= network_disconnect,
-};
-
-static void interface_added(GSupplicantInterface *interface)
+static void sta_authorized(GSupplicantInterface *interface,
+					const char *addr)
 {
-	const char *ifname = g_supplicant_interface_get_ifname(interface);
-	const char *driver = g_supplicant_interface_get_driver(interface);
-	struct wifi_data *wifi;
-
-	wifi = g_supplicant_interface_get_data(interface);
-	if (!wifi) {
-		wifi = get_pending_wifi_data(ifname);
-		if (!wifi)
-			return;
-
-		wifi->interface = interface;
-		g_supplicant_interface_set_data(interface, wifi);
-		p2p_iface_list = g_list_append(p2p_iface_list, wifi);
-		wifi->p2p_device = true;
-	}
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 
-	DBG("ifname %s driver %s wifi %p tethering %d",
-			ifname, driver, wifi, wifi->tethering);
+	DBG("wifi %p station %s authorized", wifi, addr);
 
-	if (!wifi->device) {
-		connman_error("WiFi device not set");
+	if (!wifi || !wifi->tethering)
 		return;
-	}
 
-	connman_device_set_powered(wifi->device, true);
+	__connman_tethering_client_register(addr);
 }
 
-static bool is_idle(struct wifi_data *wifi)
+static void sta_deauthorized(GSupplicantInterface *interface,
+					const char *addr)
 {
-	DBG("state %d", wifi->state);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 
-	switch (wifi->state) {
-	case G_SUPPLICANT_STATE_UNKNOWN:
-	case G_SUPPLICANT_STATE_DISABLED:
-	case G_SUPPLICANT_STATE_DISCONNECTED:
-	case G_SUPPLICANT_STATE_INACTIVE:
-	case G_SUPPLICANT_STATE_SCANNING:
-		return true;
+	DBG("wifi %p station %s deauthorized", wifi, addr);
 
-	case G_SUPPLICANT_STATE_AUTHENTICATING:
-	case G_SUPPLICANT_STATE_ASSOCIATING:
-	case G_SUPPLICANT_STATE_ASSOCIATED:
-	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
-	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
-	case G_SUPPLICANT_STATE_COMPLETED:
-		return false;
-	}
+	if (!wifi || !wifi->tethering)
+		return;
 
-	return false;
+	__connman_tethering_client_unregister(addr);
 }
 
-static bool is_idle_wps(GSupplicantInterface *interface,
-						struct wifi_data *wifi)
+static void station_added(const char *mac)
 {
-	/* First, let's check if WPS processing did not went wrong */
-	if (g_supplicant_interface_get_wps_state(interface) ==
-		G_SUPPLICANT_WPS_STATE_FAIL)
-		return false;
-
-	/* Unlike normal connection, being associated while processing wps
-	 * actually means that we are idling. */
-	switch (wifi->state) {
-	case G_SUPPLICANT_STATE_UNKNOWN:
-	case G_SUPPLICANT_STATE_DISABLED:
-	case G_SUPPLICANT_STATE_DISCONNECTED:
-	case G_SUPPLICANT_STATE_INACTIVE:
-	case G_SUPPLICANT_STATE_SCANNING:
-	case G_SUPPLICANT_STATE_ASSOCIATED:
-		return true;
-	case G_SUPPLICANT_STATE_AUTHENTICATING:
-	case G_SUPPLICANT_STATE_ASSOCIATING:
-	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
-	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
-	case G_SUPPLICANT_STATE_COMPLETED:
-		return false;
-	}
+	int stacount = 0;
+	connman_technology_tethering_add_station(CONNMAN_SERVICE_TYPE_WIFI, mac);
 
-	return false;
+	stacount = __connman_tethering_sta_count();
+	__connman_technology_sta_count_changed(CONNMAN_SERVICE_TYPE_WIFI, stacount);
 }
 
-static bool handle_wps_completion(GSupplicantInterface *interface,
-					struct connman_network *network,
-					struct connman_device *device,
-					struct wifi_data *wifi)
+static void station_removed(const char *mac)
 {
-	bool wps;
+	int stacount = 0;
 
-	wps = connman_network_get_bool(network, "WiFi.UseWPS");
-	if (wps) {
-		const unsigned char *ssid, *wps_ssid;
-		unsigned int ssid_len, wps_ssid_len;
-		const char *wps_key;
+	connman_technology_tethering_remove_station(mac);
 
-		if (wifi->wps_active == FALSE) {
-			/* Checking if we got associated with requested
-			 * network */
-			ssid = connman_network_get_blob(network, "WiFi.SSID",
-							&ssid_len);
+	stacount = __connman_tethering_sta_count();
+	__connman_technology_sta_count_changed(CONNMAN_SERVICE_TYPE_WIFI, stacount);
+}
 
-			wps_ssid = g_supplicant_interface_get_wps_ssid(
-				interface, &wps_ssid_len);
+static void p2p_sd_asp_response(GSupplicantInterface *interface, GSupplicantPeer *peer,
+								unsigned char transaction_id,
+								unsigned int advertisement_id,
+								unsigned char service_status,
+								dbus_uint16_t config_method,
+								const char* service_name,
+								const char* service_info)
+{
+	/*
+	wfds_on_service_discovery_response(peer,
+										transaction_id,
+										advertisement_id,
+										service_status,
+										config_method,
+										service_name,
+										service_info);
+	*/
+}
 
-			if (!wps_ssid || wps_ssid_len != ssid_len ||
-					memcmp(ssid, wps_ssid, ssid_len) != 0) {
-				connman_network_set_associating(network, false);
-				g_supplicant_interface_disconnect(wifi->interface,
-							disconnect_callback, wifi);
-				return false;
-			}
-		}
+static void p2p_sd_response(GSupplicantInterface *interface, GSupplicantPeer *peer,
+				int indicator, unsigned char *tlv, int tlv_len)
+{
+	struct wifi_data *wifi;
+	const char *identifier;
 
-		wps_key = g_supplicant_interface_get_wps_key(interface);
-		connman_network_set_string(network, "WiFi.Passphrase",
-					wps_key);
+	if (p2p_technology == NULL)
+		return;
 
-		connman_network_set_string(network, "WiFi.PinWPS", NULL);
-	}
+	wifi = g_supplicant_interface_get_data(interface);
 
-	return true;
+	identifier =  strrchr(g_supplicant_peer_get_path(peer), '/') + 1;
+
+	__connman_sd_response_from_p2p_peer(identifier, indicator, tlv, tlv_len);
 }
 
-static bool handle_assoc_status_code(GSupplicantInterface *interface,
-                                     struct wifi_data *wifi)
+static void apply_peer_services(GSupplicantPeer *peer,
+				struct connman_peer *connman_peer)
 {
-	if (wifi->state == G_SUPPLICANT_STATE_ASSOCIATING &&
-			wifi->assoc_code == ASSOC_STATUS_NO_CLIENT &&
-			wifi->load_shaping_retries < LOAD_SHAPING_MAX_RETRIES) {
-		wifi->load_shaping_retries ++;
-		return TRUE;
+	const unsigned char *data;
+	int length;
+
+	DBG("");
+
+	connman_peer_reset_services(connman_peer);
+
+	data = g_supplicant_peer_get_widi_ies(peer, &length);
+	if (data) {
+		connman_peer_add_service(connman_peer,
+			CONNMAN_PEER_SERVICE_WIFI_DISPLAY, data, length);
 	}
-	wifi->load_shaping_retries = 0;
-	return FALSE;
 }
 
-static bool handle_4way_handshake_failure(GSupplicantInterface *interface,
-					struct connman_network *network,
-					struct wifi_data *wifi)
+static void peer_found(GSupplicantPeer *peer)
 {
-	struct connman_service *service;
+	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct connman_peer *connman_peer;
 
-	if (wifi->state != G_SUPPLICANT_STATE_4WAY_HANDSHAKE)
-		return false;
+	struct connman_network *connman_network;
 
-	if (wifi->connected)
-		return false;
+	const char *identifier, *name, *path, *pri_dev_type;;
+	dbus_uint16_t config_methods;
+	int ret;
 
-	service = connman_service_lookup_from_network(network);
-	if (!service)
-		return false;
+	identifier = g_supplicant_peer_get_identifier(peer);
+	name = g_supplicant_peer_get_name(peer);
 
-	wifi->retries++;
+	path = g_supplicant_peer_get_path(peer);
+	config_methods = g_supplicant_peer_get_config_methods(peer);
+	pri_dev_type = g_supplicant_peer_get_pri_dev_type(peer);
 
-	if (connman_service_get_favorite(service)) {
-		if (wifi->retries < FAVORITE_MAXIMUM_RETRIES)
-			return true;
-	}
+	DBG("ident: %s", identifier);
 
-	wifi->retries = 0;
-	connman_network_set_error(network, CONNMAN_NETWORK_ERROR_INVALID_KEY);
+	connman_network = connman_device_get_network(wifi->device, identifier);
 
-	return false;
-}
+	if (connman_network == NULL) {
+		DBG("creating new network");
+		connman_network = connman_network_create(identifier, CONNMAN_NETWORK_TYPE_WIFI);
+		if (connman_network == NULL)
+			return;
 
-static void wps_state(GSupplicantInterface *interface)
-{
-	struct wifi_data *wifi;
-	GSupplicantWpsState state = g_supplicant_interface_get_wps_state(interface);
-	const char *wps_ssid, *ssid;
-	unsigned int wps_ssid_len, ssid_len;
-	GSList *list;
-	struct connman_network *found_network = NULL;
+		connman_network_set_index(connman_network, wifi->index);
 
-	wifi = g_supplicant_interface_get_data(interface);
+		connman_network_set_name(connman_network, name);
+		connman_network_set_string(connman_network, "Path", path);
+		connman_network_set_p2p_network(connman_network, TRUE);
+		if (connman_device_add_network(wifi->device, connman_network) < 0) {
+			connman_network_unref(connman_network);
+			return;
+		}
 
-	if(wifi==NULL)
-		return;
+		wifi->networks = g_slist_prepend(wifi->networks, connman_network);
+	} else {
+		DBG("network already exists, just update it");
 
-	if (wifi->wps_active == FALSE)
+		connman_network_set_name(connman_network, name);
+		__connman_service_update_from_network(connman_network);
+	}
+
+	connman_peer = connman_peer_get(wifi->device, identifier);
+	if (connman_peer)
 		return;
 
-	wps_ssid = g_supplicant_interface_get_wps_ssid(interface, &wps_ssid_len);
+	connman_peer = connman_peer_create(identifier);
+	connman_peer_set_name(connman_peer, name);
+	connman_peer_set_device(connman_peer, wifi->device);
+	connman_peer_set_strength(connman_peer, calculate_peer_strength(peer));
+	connman_peer_set_config_methods(connman_peer, config_methods);
+	connman_peer_set_pri_dev_type(connman_peer, pri_dev_type);
 
-	DBG("wifi %p wps state %d ssid %s", wifi, state, wps_ssid);
+	apply_peer_services(peer, connman_peer);
 
-	g_source_remove(wifi->wps_timeout);
-	wifi->wps_timeout = 0;
+	ret = connman_peer_register(connman_peer);
+	if (ret < 0 && ret != -EALREADY)
+		connman_peer_unref(connman_peer);
+	else
+		wifi->peers = g_slist_prepend(wifi->peers, connman_peer);
 
-	switch (state) {
-	case G_SUPPLICANT_WPS_STATE_UNKNOWN:
+	//wfds_on_peer_added(peer);
+
+}
+
+static void peer_lost(GSupplicantPeer *peer)
+{
+	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct connman_peer *connman_peer;
+	const char *identifier;
+	struct connman_network *connman_network;
+
+	if (!wifi)
 		return;
-	case G_SUPPLICANT_WPS_STATE_FAIL:
-	wifi->wps_active = FALSE;
-	connman_technology_wps_failed_notify(wifi_technology);
-	return;
-	}
 
-	for (list = wifi->networks; list != NULL; list = list->next) {
-		struct connman_network *network = list->data;
+	identifier = g_supplicant_peer_get_identifier(peer);
 
-		ssid = connman_network_get_blob(network, "WiFi.SSID", &ssid_len);
+	if (!identifier)
+		return;
 
-		if (ssid != NULL && wps_ssid_len == ssid_len &&
-		    memcmp(ssid, wps_ssid, ssid_len) == 0) {
-			DBG("found network %s", ssid);
-			connman_network_set_bool(network, "WiFi.UseWPS", TRUE);
-			found_network = network;
-			break;
+	DBG("ident: %s", identifier);
+
+	connman_peer = connman_peer_get(wifi->device, identifier);
+	connman_network = connman_device_get_network(wifi->device, identifier);
+
+	if (connman_peer) {
+		if (wifi->p2p_connecting &&
+				wifi->pending_peer == connman_peer) {
+			peer_connect_timeout(wifi);
 		}
+		connman_peer_unregister(connman_peer);
+		connman_peer_unref(connman_peer);
 	}
 
-	if (found_network == NULL) {
-		DBG("didn't found a network for ssid %s", wps_ssid);
-		g_supplicant_interface_disconnect(wifi->interface,
-		disconnect_callback, wifi);
-		return;
+	if (connman_network) {
+		wifi->networks = g_slist_remove(wifi->networks, connman_network);
+
+		connman_device_remove_network(wifi->device, connman_network);
+		connman_network_unref(connman_network);
 	}
 
-	/* we've found the correct network so we connect as normal
-	 * in our connection process */
-	wifi->network = found_network;
+	wifi->peers = g_slist_remove(wifi->peers, connman_peer);
 }
 
-static void interface_state(GSupplicantInterface *interface)
+GSList * __connman_service_connected_peer_list(struct wifi_data *wifi)
 {
-	struct connman_network *network;
-	struct connman_device *device;
-	struct wifi_data *wifi;
-	GSupplicantState state = g_supplicant_interface_get_state(interface);
-	bool wps;
 	GSList *list;
-	bool old_connected;
-	const char *wps_ssid, *ssid;
-	unsigned int wps_ssid_len, ssid_len;
-
-	wifi = g_supplicant_interface_get_data(interface);
+	GSList *connected_peers = NULL;
+	int cnt = 0;
 
-	DBG("wifi %p interface state %d", wifi, state);
+	for (list = wifi->peers; list; list = list->next)
+	{
+		struct connman_peer *peer = list->data;
+		if (peer == NULL)
+			continue;
 
-	if (!wifi)
-		return;
+		if (connman_peer_get_state(peer) == CONNMAN_PEER_STATE_READY)
+			connected_peers = g_slist_prepend(connected_peers, peer);
+	}
+	return connected_peers;
+}
 
-	device = wifi->device;
-	if (!device)
-		return;
+static char * p2p_persistent_info_find_oldest(const char *identifier, GList * connected_p2pList, struct wifi_data *wifi)
+{
+	gchar **persistents = NULL;
+	int i = 0;
+	char *peer_ident = NULL;
+	char *oldest_identifier = NULL;
+	guint64 oldest_time = 0;
+	GList *list;
+	char *connected_identifier = NULL;
+	connman_bool_t same = 0;
 
-	if (state == G_SUPPLICANT_STATE_COMPLETED) {
-		if (wifi->tethering_param) {
-			g_free(wifi->tethering_param->ssid);
-			g_free(wifi->tethering_param);
-			wifi->tethering_param = NULL;
-		}
+	persistents = __connman_storage_get_p2p_persistents();
+	for (i = 0; persistents && persistents[i]; i++)
+	{
+		if (strncmp(persistents[i], "p2p_persistent_", 15) != 0)
+			continue;
 
-		if (wifi->tethering)
-			stop_autoscan(device);
-	}
+		peer_ident = strrchr(persistents[i], '_') + 1;
 
-	if (g_supplicant_interface_get_ready(interface) &&
-					!wifi->interface_ready) {
-		wifi->interface_ready = true;
-		finalize_interface_creation(wifi);
-	}
+		if (!strcmp(peer_ident, identifier))
+			continue;
 
-	network = wifi->network;
-	if (!network)
-		return;
+		for (list = connected_p2pList; list != NULL; list = list->next)
+		{
+			struct connman_peer *peer = list->data;
+			if (peer == NULL)
+				continue;
 
-	wps_ssid = g_supplicant_interface_get_wps_ssid(interface, &wps_ssid_len);
-	if (!network && wifi->wps_active && wps_ssid_len) {
-		for (list = wifi->networks; list != NULL; list = list->next) {
-			struct connman_network *connected_network = list->data;
+			if (connman_peer_get_state(peer) == CONNMAN_PEER_STATE_READY)
+				connected_identifier = connman_peer_get_identifier(peer);
 
-			ssid = connman_network_get_blob(connected_network, "WiFi.SSID", &ssid_len);
-			if (ssid != NULL && wps_ssid_len == ssid_len &&
-				memcmp(ssid, wps_ssid, ssid_len) == 0) {
-				DBG("found network %s", ssid);
-				connman_network_set_bool(connected_network, "WiFi.UseWPS", TRUE);
-				wifi->network = connected_network;
-				network = wifi->network;
+			if (connected_identifier && !strcmp(peer_ident, connected_identifier))
+			{
+				same = 1;
 				break;
 			}
 		}
-	}
 
-	switch (state) {
-	case G_SUPPLICANT_STATE_SCANNING:
-		if (wifi->connected)
-			connman_network_set_connected(network, false);
+		if (same)
+		{
+			same = 0;
+			continue;
+		}
 
-		break;
+		GKeyFile *keyfile = NULL;
+		keyfile =  __connman_storage_open_service(persistents[i]);
+		guint64 last_connected = 0;
+		last_connected = g_key_file_get_uint64(keyfile, P2P_PERSISTENT_INFO, "ConnectedTime", NULL);
 
-	case G_SUPPLICANT_STATE_AUTHENTICATING:
-	case G_SUPPLICANT_STATE_ASSOCIATING:
-		stop_autoscan(device);
+		if (last_connected == 0){
+			struct timeval now;
+			unsigned long current_time = 0;
+			if (!gettimeofday(&now, NULL))
+				current_time = now.tv_sec;
 
-		connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_WIFI,FALSE);
-		if (!wifi->connected)
-			connman_network_set_associating(network, true);
+			g_key_file_set_uint64(keyfile, P2P_PERSISTENT_INFO, "ConnectedTime", current_time);
 
-		break;
+			g_key_file_free(keyfile);
+			continue;
+		}
 
-	case G_SUPPLICANT_STATE_COMPLETED:
-		/* though it should be already stopped: */
-		stop_autoscan(device);
+		if (oldest_time == 0 || oldest_time > last_connected)
+		{
+			oldest_time = last_connected;
+			if (oldest_identifier != NULL)
+			{
+				g_free(oldest_identifier);
+				oldest_identifier = NULL;
+			}
+			oldest_identifier = g_strdup(peer_ident);
+		}
 
-		connman_device_set_scanning(device,CONNMAN_SERVICE_TYPE_WIFI,FALSE);
-		if (!handle_wps_completion(interface, network, device, wifi))
-			break;
+		g_key_file_free(keyfile);
+	}
 
-		connman_network_set_connected(network, true);
+	if (persistents != NULL)
+		g_strfreev(persistents);
 
-		wifi->disconnect_code = 0;
-		wifi->assoc_code = 0;
-		wifi->load_shaping_retries = 0;
-		wifi->wps_active = FALSE;
-		break;
+	return oldest_identifier;
+}
 
-	case G_SUPPLICANT_STATE_DISCONNECTED:
-		/*
-		 * If we're in one of the idle modes, we have
-		 * not started association yet and thus setting
-		 * those ones to FALSE could cancel an association
-		 * in progress.
-		 */
-		wps = connman_network_get_bool(network, "WiFi.UseWPS");
-		if (wps)
-			if (is_idle_wps(interface, wifi))
-				break;
+static void p2p_persistent_info_remove_oldest(const char *identifier, struct wifi_data *wifi)
+{
+	char *oldest_identifier = NULL;
+	GList *connected_p2p_list = NULL;
+	char persistent_info_name[28] = "p2p_persistent_";
 
-		if (is_idle(wifi))
-			break;
+	connected_p2p_list = __connman_service_connected_peer_list(wifi);
 
-		if (handle_assoc_status_code(interface, wifi))
-			break;
+	oldest_identifier = p2p_persistent_info_find_oldest(identifier, connected_p2p_list, wifi);
 
-		/* If previous state was 4way-handshake, then
-		 * it's either: psk was incorrect and thus we retry
-		 * or if we reach the maximum retries we declare the
-		 * psk as wrong */
-		if (handle_4way_handshake_failure(interface,
-						network, wifi))
-			break;
+	if (oldest_identifier == NULL)
+		return;
+
+	strncat(persistent_info_name, oldest_identifier, strlen(oldest_identifier));
 
-		/* See table 8-36 Reason codes in IEEE Std 802.11 */
-		switch (wifi->disconnect_code) {
-		case 1: /* Unspecified reason */
-			/* Let's assume it's because we got blocked */
+	g_hash_table_remove(wifi->persistent_peer_ssid, oldest_identifier);
+	__connman_storage_remove_service(persistent_info_name);
 
-		case 6: /* Class 2 frame received from nonauthenticated STA */
-			connman_network_set_error(network,
-						CONNMAN_NETWORK_ERROR_BLOCKED);
-			break;
+	g_free(oldest_identifier);
+	g_slist_free(connected_p2p_list);
+}
 
-		default:
-			break;
-		}
+static void p2p_persistent_info_save(const char *identifier, GSupplicantP2PPersistentGroup *persistent_group)
+{
+	char persistent_info_name[28] = "p2p_persistent_";
+	strncat(persistent_info_name, identifier, strlen(identifier));
+	int count = 0;
 
-		if (network != wifi->pending_network) {
-			connman_network_set_connected(network, false);
-			connman_network_set_associating(network, false);
-		}
-		wifi->disconnecting = false;
+	if(persistent_group == NULL) {
+		return;
+	} else {
+		GKeyFile *keyfile;
+		char * mac_address=NULL;
 
-		if (!deferred_wps_start(wifi))
-		{
-			/* Set connected to false to allow autoscan to start. */
-			wifi->connected = FALSE;
-		    start_autoscan(device);
-		}
+		if(persistent_group->psk == NULL)
+			return;
 
-		break;
+		keyfile = __connman_storage_open_service(persistent_info_name);
+		if (keyfile == NULL)
+			return;
 
-	case G_SUPPLICANT_STATE_INACTIVE:
-		connman_network_set_associating(network, false);
-		start_autoscan(device);
+		g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "SSID", persistent_group->ssid);
+		g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "BSSID", persistent_group->bssid);
+		g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "PSK", persistent_group->psk);
 
-		break;
+		struct wifi_data *wifi = g_supplicant_interface_get_data(persistent_group->interface);
+		if (wifi) {
+			mac_address = __connman_util_insert_colon_to_mac_addr(connman_device_get_ident(wifi->device));
+			if (mac_address)
+				g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "MAC", mac_address);
+		}
 
-	case G_SUPPLICANT_STATE_UNKNOWN:
-	case G_SUPPLICANT_STATE_DISABLED:
-	case G_SUPPLICANT_STATE_ASSOCIATED:
-	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
-	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
-		break;
-	}
+		if(persistent_group->go == TRUE)
+			g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "Role", "GO");
+		else
+			g_key_file_set_string(keyfile, P2P_PERSISTENT_INFO, "Role", "Client");
 
-	old_connected = wifi->connected;
-	wifi->state = state;
+		struct timeval now;
+		unsigned long connected_time = 0;
+		if (!gettimeofday(&now, NULL))
+			connected_time = now.tv_sec;
 
-	/* Saving wpa_s state policy:
-	 * If connected and if the state changes are roaming related:
-	 * --> We stay connected
-	 * If completed
-	 * --> We are connected
-	 * All other case:
-	 * --> We are not connected
-	 * */
-	switch (state) {
-	case G_SUPPLICANT_STATE_AUTHENTICATING:
-	case G_SUPPLICANT_STATE_ASSOCIATING:
-	case G_SUPPLICANT_STATE_ASSOCIATED:
-	case G_SUPPLICANT_STATE_4WAY_HANDSHAKE:
-	case G_SUPPLICANT_STATE_GROUP_HANDSHAKE:
-		if (wifi->connected)
-			connman_warn("Probably roaming right now!"
-						" Staying connected...");
-		break;
-	case G_SUPPLICANT_STATE_SCANNING:
-		wifi->connected = false;
+		persistent_group->connected_time = connected_time;
+		g_key_file_set_uint64(keyfile, P2P_PERSISTENT_INFO, "ConnectedTime", persistent_group->connected_time);
 
-		if (old_connected)
-			start_autoscan(device);
-		break;
-	case G_SUPPLICANT_STATE_COMPLETED:
-		wifi->connected = true;
-		break;
-	default:
-		wifi->connected = false;
-		break;
-	}
+		__connman_storage_save_service(keyfile, persistent_info_name);
 
-	DBG("DONE");
+		g_free(mac_address);
+		count = __connman_storage_get_p2p_persistents_count();
+		if (wifi && count > P2P_PERSISTENT_MAX_COUNT)
+			p2p_persistent_info_remove_oldest(identifier, wifi);
+
+		g_key_file_free(keyfile);
+	}
 }
 
-static void interface_removed(GSupplicantInterface *interface)
+static void p2p_go_neg_failed(GSupplicantInterface *interface, struct connman_peer *peer, int status)
 {
-	const char *ifname = g_supplicant_interface_get_ifname(interface);
 	struct wifi_data *wifi;
-
-	DBG("ifname %s", ifname);
+	const char *identifier, *path;
 
 	wifi = g_supplicant_interface_get_data(interface);
+	identifier = connman_peer_get_identifier(peer);
 
-	if (wifi)
-		wifi->interface = NULL;
+	DBG("identifier %s", identifier);
 
-	if (wifi && wifi->tethering)
-		return;
+	p2p_peers_refresh(wifi);
 
-	if (!wifi || !wifi->device) {
-		DBG("wifi interface already removed");
+	// TODO: will consider with other WFDS changes
+//	wfds_on_go_neg_failed(connman_network, status);
+
+	path = __connman_peer_get_path(peer);
+
+	if(!path)
 		return;
-	}
 
-	connman_device_set_powered(wifi->device, false);
+	connman_dbus_property_changed_basic(path, CONNMAN_PEER_INTERFACE,
+					"P2PGONegFailed", DBUS_TYPE_INT32, &status);
 
-	check_p2p_technology();
 }
 
-static void set_device_type(const char *type, char dev_type[17])
+static void peer_dhcp_address_update()
 {
-	const char *oui = "0050F204";
-	const char *category = "0001";
-	const char *sub_category = "0000";
+	struct connman_group *group;
 
-	if (!g_strcmp0(type, "handset")) {
-		category = "000A";
-		sub_category = "0005";
-	} else if (!g_strcmp0(type, "vm") || !g_strcmp0(type, "container"))
-		sub_category = "0001";
-	else if (!g_strcmp0(type, "server"))
-		sub_category = "0002";
-	else if (!g_strcmp0(type, "laptop"))
-		sub_category = "0005";
-	else if (!g_strcmp0(type, "desktop"))
-		sub_category = "0006";
-	else if (!g_strcmp0(type, "tablet"))
-		sub_category = "0009";
-	else if (!g_strcmp0(type, "watch"))
-		category = "00FF";
+	group = __connman_group_lookup_from_ident(p2p_go_identifier);
+	if (group == NULL)
+		return;
 
-	snprintf(dev_type, 17, "%s%s%s", category, oui, sub_category);
+	__connman_group_client_dhcp_ip_assigned(group);
 }
-
-static void p2p_support(GSupplicantInterface *interface)
+static void peer_changed(GSupplicantPeer *peer, GSupplicantPeerState state)
 {
-	char dev_type[17] = {};
-	const char *hostname;
+	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	enum connman_peer_state p_state = CONNMAN_PEER_STATE_UNKNOWN;
+	struct connman_peer *connman_peer;
+	struct connman_group *connman_group;
+	const char *identifier;
 
-	DBG("");
+	identifier = g_supplicant_peer_get_identifier(peer);
 
-	if (!interface)
+	DBG("ident: %s", identifier);
+
+	if (!wifi)
 		return;
 
-	if (!g_supplicant_interface_has_p2p(interface))
+	connman_peer = connman_peer_get(wifi->device, identifier);
+	if (!connman_peer)
 		return;
 
-	if (connman_technology_driver_register(&p2p_tech_driver) < 0) {
-		DBG("Could not register P2P technology driver");
+	switch (state) {
+	case G_SUPPLICANT_PEER_SERVICES_CHANGED:
+		apply_peer_services(peer, connman_peer);
+		connman_peer_services_changed(connman_peer);
 		return;
-	}
+	case G_SUPPLICANT_PEER_GROUP_CHANGED:
+		if (!g_supplicant_peer_is_in_a_group(peer))
+			p_state = CONNMAN_PEER_STATE_IDLE;
+		break;
+	case G_SUPPLICANT_PEER_GROUP_STARTED:
+		break;
+	case G_SUPPLICANT_PEER_GROUP_FINISHED:
+		p_state = CONNMAN_PEER_STATE_IDLE;
+		break;
+	case G_SUPPLICANT_PEER_GROUP_JOINED:
+		connman_peer_set_iface_address(connman_peer,
+				g_supplicant_peer_get_iface_address(peer));
 
-	hostname = connman_utsname_get_hostname();
-	if (!hostname)
-		hostname = "ConnMan";
+		if (p2p_go_identifier) {
+			GSupplicantP2PPersistentGroup *persistent_group;
+			GSupplicantGroup *group;
+			struct connman_network *network;
+			char *ipaddress = g_supplicant_peer_get_ip_address(peer);
 
-	set_device_type(connman_machine_get_type(), dev_type);
-	g_supplicant_interface_set_p2p_device_config(interface,
-							hostname, dev_type);
-	connman_peer_driver_register(&peer_driver);
-}
+			const char *identifier = connman_peer_get_identifier(connman_peer);
 
-static void scan_started(GSupplicantInterface *interface)
-{
-	DBG("");
-}
+			network = connman_device_get_network(wifi->device, identifier);
 
-static void scan_finished(GSupplicantInterface *interface)
-{
-	DBG("");
-}
+			connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_ASSOCIATION);
+			connman_peer_set_as_go(connman_peer, false);
+			connman_group = __connman_group_lookup_from_ident(p2p_go_identifier);
+			group = g_supplicant_get_group(__connman_group_get_group_owner(connman_group));
 
-static void ap_create_fail(GSupplicantInterface *interface)
-{
-	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
-	int ret;
+			if (connman_group->autonomous)
+				__connman_peer_set_autonomous_group(connman_peer, true);
 
-	if ((wifi->tethering) && (wifi->tethering_param)) {
-		DBG("%s create AP fail \n",
-				g_supplicant_interface_get_ifname(wifi->interface));
+			if (group) {
+				persistent_group = g_supplicant_interface_get_p2p_persistent_group(iface, group);
+				if(persistent_group != NULL) {
+					persistent_group->go = TRUE;
+					p2p_persistent_info_save(identifier, persistent_group);
+				}
+			}
 
-		connman_inet_remove_from_bridge(wifi->index, wifi->bridge);
-		wifi->ap_supported = WIFI_AP_NOT_SUPPORTED;
-		wifi->tethering = false;
+			if (ipaddress != NULL){
+				connman_group->is_static_ip = true;
+				connman_group->peer_ip = g_strdup(ipaddress);
+				//p_state = CONNMAN_PEER_STATE_CONFIGURATION;
 
-		ret = tech_set_tethering(wifi->tethering_param->technology,
-				wifi->tethering_param->ssid->ssid,
-				wifi->tethering_param->ssid->passphrase,
-				wifi->bridge, true);
+				__connman_peer_set_static_ip(connman_peer, ipaddress);
+			}
+			p_state = CONNMAN_PEER_STATE_CONFIGURATION;
+//			if (network)
+//				wfds_on_p2p_peer_joined(network, group);
 
-		if ((ret == -EOPNOTSUPP) && (wifi_technology)) {
-			connman_technology_tethering_notify(wifi_technology,false);
+//			if (network && connman_group->is_static_ip)
+//				wfds_on_p2p_group_peer_static_ip_added(network, connman_group->peer_ip);
+
+			__connman_group_peer_joined(connman_group, identifier,
+					g_supplicant_peer_get_iface_address(peer), __connman_peer_get_path(connman_peer));
+		} else {
+			connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_ASSOCIATION);
+			connman_peer_set_as_go(connman_peer, true);
+
+			p_state = CONNMAN_PEER_STATE_CONFIGURATION;
 		}
+		break;
+	case G_SUPPLICANT_PEER_GROUP_DISCONNECTED:
+		if (p2p_go_identifier) {
+			connman_group = __connman_group_lookup_from_ident(p2p_go_identifier);
+			if (__connman_group_peer_disconnected(connman_group, identifier)) {
+				peer_cancel_timeout(wifi);
+				wifi->p2p_device = false;
+				__connman_peer_set_static_ip(connman_peer, NULL);
+			}
+		}
+		p_state = CONNMAN_PEER_STATE_IDLE;
+		break;
+	case G_SUPPLICANT_PEER_GROUP_FAILED:
+		if (g_supplicant_peer_has_requested_connection(peer))
+			p_state = CONNMAN_PEER_STATE_IDLE;
+		else
+			p_state = CONNMAN_PEER_STATE_FAILURE;
 
-		g_free(wifi->tethering_param->ssid);
-		g_free(wifi->tethering_param);
-		wifi->tethering_param = NULL;
+		p2p_go_neg_failed(iface, connman_peer,  g_supplicant_peer_get_failure_status(peer));
+		break;
 	}
-}
 
-static unsigned char calculate_strength(GSupplicantNetwork *supplicant_network)
-{
-	unsigned char strength;
+	if (p_state == CONNMAN_PEER_STATE_CONFIGURATION ||
+					p_state == CONNMAN_PEER_STATE_FAILURE) {
+		if (wifi->p2p_connecting
+				&& connman_peer == wifi->pending_peer)
+			peer_cancel_timeout(wifi);
+/*		else {
+			if (!p2p_go_identifier)
+				p_state = CONNMAN_PEER_STATE_UNKNOWN;
+		}*/
+	}
 
-	strength = 120 + g_supplicant_network_get_signal(supplicant_network);
-	if (strength > 100)
-		strength = 100;
+	if (p_state == CONNMAN_PEER_STATE_UNKNOWN)
+		return;
 
-	return strength;
-}
+	if (p_state == CONNMAN_PEER_STATE_CONFIGURATION) {
+		GSupplicantInterface *g_iface;
+		struct wifi_data *g_wifi;
+		bool is_client = false;
 
-static void network_added(GSupplicantNetwork *supplicant_network)
-{
-	struct connman_network *network;
-	GSupplicantInterface *interface;
-	struct wifi_data *wifi;
-	const char *name, *identifier, *security, *group, *mode;
-	const unsigned char *ssid;
-	unsigned int ssid_len;
-	bool wps;
-	bool wps_pbc;
-	bool wps_ready;
-	bool wps_advertizing;
-	GHashTable *bss_table;
+		g_iface = g_supplicant_peer_get_group_interface(peer);
+		if (!g_iface)
+			return;
 
-	mode = g_supplicant_network_get_mode(supplicant_network);
-	identifier = g_supplicant_network_get_identifier(supplicant_network);
+		g_wifi = g_supplicant_interface_get_data(g_iface);
+		if (!g_wifi)
+			return;
+
+		is_client = g_supplicant_peer_is_client(peer);
+		connman_peer_set_as_master(connman_peer, !is_client);
+
+		if (!is_client)
+			connman_peer_dhcpclient_cb(connman_peer, peer_dhcp_address_update);
+		else
+			connman_peer_dhcpclient_cb(connman_peer, NULL);
+
+		connman_peer_set_sub_device(connman_peer, g_wifi->device);
+
+		/*
+		 * If wpa_supplicant didn't create a dedicated p2p-group
+		 * interface then mark this interface as p2p_device to avoid
+		 * scan and auto-scan are launched on it while P2P is connected.
+		 */
+		if (!g_list_find(p2p_iface_list, g_wifi))
+			wifi->p2p_device = true;
+	}
+
+	connman_peer_set_state(connman_peer, p_state);
+}
 
-	DBG("%s", identifier);
+static void peer_request(GSupplicantPeer *peer, int dev_passwd_id)
+{
+	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct connman_network *connman_network;
+	struct connman_peer *connman_peer;
+	const char *identifier, *name, *path;
 
-	if (!g_strcmp0(mode, "adhoc"))
-		return;
+	identifier = g_supplicant_peer_get_identifier(peer);
 
-	interface = g_supplicant_network_get_interface(supplicant_network);
-	wifi = g_supplicant_interface_get_data(interface);
-	name = g_supplicant_network_get_name(supplicant_network);
-	security = g_supplicant_network_get_security(supplicant_network);
-	group = g_supplicant_network_get_identifier(supplicant_network);
-	wps = g_supplicant_network_get_wps(supplicant_network);
-	wps_pbc = g_supplicant_network_is_wps_pbc(supplicant_network);
-	wps_ready = g_supplicant_network_is_wps_active(supplicant_network);
-	wps_advertizing = g_supplicant_network_is_wps_advertizing(
-							supplicant_network);
-	bss_table = g_supplicant_network_get_bss_table(supplicant_network);
+	DBG("ident: %s", identifier);
 
-	if (!wifi)
+	connman_peer = connman_peer_get(wifi->device, identifier);
+	if (!connman_peer)
 		return;
 
-	ssid = g_supplicant_network_get_ssid(supplicant_network, &ssid_len);
-
-	network = connman_device_get_network(wifi->device, identifier);
+	name = g_supplicant_peer_get_name(peer);
+	path = g_supplicant_peer_get_path(peer);
+      connman_network = connman_device_get_network(wifi->device, identifier);
 
-	if (!network) {
-		network = connman_network_create(identifier,
-						CONNMAN_NETWORK_TYPE_WIFI);
-		if (!network)
+      if (connman_network == NULL) {
+		DBG("creating new network");
+		connman_network = connman_network_create(identifier, CONNMAN_NETWORK_TYPE_WIFI);
+		if (connman_network == NULL)
 			return;
 
-		connman_network_set_index(network, wifi->index);
+		connman_network_set_index(connman_network, wifi->index);
 
-		if (connman_device_add_network(wifi->device, network) < 0) {
-			connman_network_unref(network);
+             connman_network_set_name(connman_network, name);
+		connman_network_set_string(connman_network, "Path", path);
+
+	      if (connman_device_add_network(wifi->device, connman_network) < 0) {
+			connman_network_unref(connman_network);
 			return;
 		}
 
-		wifi->networks = g_slist_prepend(wifi->networks, network);
-	}
-
-	if (name && name[0] != '\0')
-		connman_network_set_name(network, name);
+		wifi->networks = g_slist_prepend(wifi->networks, connman_network);
+	}  else	{
+		DBG("network already exists, just update it");
 
-	connman_network_set_blob(network, "WiFi.SSID",
-						ssid, ssid_len);
-	connman_network_set_string(network, "WiFi.Security", security);
-	connman_network_set_strength(network,
-				calculate_strength(supplicant_network));
-	connman_network_set_bool(network, "WiFi.WPS", wps);
-	connman_network_set_bool(network, "WiFi.WPSAdvertising",
-				wps_advertizing);
+	      connman_network_set_name(connman_network, name);
 
-	if (wps) {
-		/* Is AP advertizing for WPS association?
-		 * If so, we decide to use WPS by default */
-		if (wps_ready && wps_pbc &&
-						wps_advertizing)
-			connman_network_set_bool(network, "WiFi.UseWPS", true);
+		__connman_service_update_from_network(connman_network);
 	}
 
-	connman_network_set_frequency(network,
-			g_supplicant_network_get_frequency(supplicant_network));
+//	wfds_on_go_neg_requested(connman_network, dev_passwd_id);
 
-	connman_network_set_available(network, true);
-	connman_network_set_string(network, "WiFi.Mode", mode);
+	connman_peer_request_connection(connman_peer, dev_passwd_id);
+}
 
-	if (ssid)
-		connman_network_set_group(network, group);
+static void debug(const char *str)
+{
+	if (getenv("CONNMAN_SUPPLICANT_DEBUG"))
+		connman_debug("%s", str);
+}
 
-	if (wifi->hidden && ssid) {
-		if (!g_strcmp0(wifi->hidden->security, security) &&
-				wifi->hidden->ssid_len == ssid_len &&
-				!memcmp(wifi->hidden->ssid, ssid, ssid_len)) {
-			connman_network_connect_hidden(network,
-					wifi->hidden->identity,
-					wifi->hidden->passphrase,
-					wifi->hidden->user_data);
-			wifi->hidden->user_data = NULL;
-			hidden_free(wifi->hidden);
-			wifi->hidden = NULL;
-		}
+static void disconnect_reasoncode(GSupplicantInterface *interface,
+				int reasoncode)
+{
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+
+	if (wifi != NULL) {
+		wifi->disconnect_code = reasoncode;
 	}
+}
 
-	connman_network_set_address(network, g_supplicant_network_get_bssid(supplicant_network), 6);
+static void assoc_status_code(GSupplicantInterface *interface, int status_code)
+{
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 
-	if (bss_table)
-		g_hash_table_foreach(bss_table, bss_foreach, network);
+	if (wifi != NULL) {
+		wifi->assoc_code = status_code;
+	}
 }
 
-static void network_removed(GSupplicantNetwork *network)
+static void p2p_group_started(GSupplicantGroup *group)
 {
-	GSupplicantInterface *interface;
 	struct wifi_data *wifi;
-	const char *name, *identifier;
-	struct connman_network *connman_network;
+	GSList *item;
+	GSupplicantP2PPersistentGroup *persistent_group;
+	struct connman_group *connman_group = NULL;
+	struct connman_peer *connman_peer_go = NULL;
+	const char* go_path = NULL;
 
-	interface = g_supplicant_network_get_interface(network);
-	wifi = g_supplicant_interface_get_data(interface);
-	identifier = g_supplicant_network_get_identifier(network);
-	name = g_supplicant_network_get_name(network);
+	GSupplicantInterface *iface = g_supplicant_group_get_orig_interface(group);
 
-	DBG("name %s", name);
+	wifi = g_supplicant_interface_get_data(iface);
 
 	if (!wifi)
 		return;
 
-	connman_network = connman_device_get_network(wifi->device, identifier);
-	if (!connman_network)
-		return;
+	const char* bssid_no_colon = g_supplicant_group_get_bssid_no_colon(group);
+	const char *ssid = g_supplicant_group_get_ssid(group);
+	const char *passphrase = g_supplicant_group_get_passphrase(group);
 
-	wifi->networks = g_slist_remove(wifi->networks, connman_network);
+	struct connman_peer *peer = connman_peer_get(wifi->device, bssid_no_colon);
+	if (peer)
+		go_path = __connman_peer_get_path(peer);
+	else
+		go_path = g_supplicant_group_get_object_path(group);
 
-	connman_device_remove_network(wifi->device, connman_network);
-	connman_network_unref(connman_network);
-}
+	/* persistent check */
+	item = wifi->persistent_groups;
+	while(item != NULL) {
+		persistent_group = item->data;
 
-static void network_changed(GSupplicantNetwork *network, const char *property)
-{
-	GSupplicantInterface *interface;
-	struct wifi_data *wifi;
-	const char *name, *identifier;
-	struct connman_network *connman_network;
-	bool update_needed;
-	GHashTable *bss_table;
+		if (persistent_group->ssid == NULL || persistent_group->bssid_no_colon == NULL ||  bssid_no_colon == NULL) {
+			item = g_slist_next(item);
+			continue;
+		}
 
-	interface = g_supplicant_network_get_interface(network);
-	wifi = g_supplicant_interface_get_data(interface);
-	identifier = g_supplicant_network_get_identifier(network);
-	name = g_supplicant_network_get_name(network);
-	bss_table = g_supplicant_network_get_bss_table(network);
+		if(g_str_equal(persistent_group->bssid_no_colon, bssid_no_colon)){
+			if (!g_str_equal(persistent_group->ssid, ssid) || !g_str_equal(persistent_group->psk, passphrase)){
+				if (persistent_group->ssid)
+					g_free(persistent_group->ssid);
+				persistent_group->ssid = g_strdup(ssid);
 
-	DBG("name %s", name);
+				if (passphrase && strcmp(passphrase, "") && persistent_group->psk) {
+					g_free(persistent_group->psk);
+					persistent_group->psk = g_strdup(passphrase);
+				}
+			}
+			g_supplicant_interface_set_p2p_persistent_group(iface, group, persistent_group);
+			break;
+		}
 
-	if (!wifi)
-		return;
+		item = g_slist_next(item);
+	}
+	bool is_group_owner = false;
+	if (g_supplicant_group_get_role(group) == G_SUPPLICANT_GROUP_ROLE_GO) {
+		is_group_owner = true;
 
-	connman_network = connman_device_get_network(wifi->device, identifier);
-	if (!connman_network)
-		return;
+		__connman_p2p_go_set_bridge(p2p_group_ifname);
 
-	connman_network_set_address(connman_network, g_supplicant_network_get_bssid(network), 6);
+		//If autonomous group then only start the DHCP server
+		if (create_group_flag)
+			__connman_p2p_go_set_enabled();
+	}
 
-	if (bss_table)
-		g_hash_table_foreach(bss_table, bss_foreach, connman_network);
+	int freq = g_supplicant_group_get_frequency(group);
+	bool persistent = g_supplicant_group_get_persistent(group);
 
-	if (g_str_equal(property, "WPSCapabilities")) {
-		bool wps;
-		bool wps_pbc;
-		bool wps_ready;
-		bool wps_advertizing;
+	connman_group = __connman_group_create(iface, p2p_group_ifname, ssid, passphrase,
+					is_group_owner, persistent, go_path, create_group_flag, freq);
 
-		wps = g_supplicant_network_get_wps(network);
-		wps_pbc = g_supplicant_network_is_wps_pbc(network);
-		wps_ready = g_supplicant_network_is_wps_active(network);
-		wps_advertizing =
-			g_supplicant_network_is_wps_advertizing(network);
+	const char *connman_group_path = __connman_group_get_path(connman_group);
 
-		connman_network_set_bool(connman_network, "WiFi.WPS", wps);
-		connman_network_set_bool(connman_network,
-				"WiFi.WPSAdvertising", wps_advertizing);
+	if (is_group_owner) {
+		p2p_go_identifier = g_strdup(__connman_group_get_identifier(connman_group));
+	} else {
+		persistent_group = g_supplicant_interface_get_p2p_persistent_group(iface, group);
+		if(persistent_group != NULL) {
+			persistent_group->go = FALSE;
+			p2p_persistent_info_save(persistent_group->bssid_no_colon, persistent_group);
+		}
+		char *ip_addr = g_supplicant_group_get_ip_addr(group);
+		char *ip_mask = g_supplicant_group_get_ip_mask(group);
+		char *go_ip_addr = g_supplicant_group_get_go_ip_addr(group);
+
+		if (ip_addr) {
+			__connman_peer_set_static_ip(peer, go_ip_addr);
+			if (connman_peer_set_ipaddress(peer, ip_addr, ip_mask, go_ip_addr) < 0)
+				connman_warn("Setting static IP for Peer failed");
+		}
 
-		if (wps) {
-			/*
-			 * Is AP advertizing for WPS association?
-			 * If so, we decide to use WPS by default
-			 */
-			if (wps_ready && wps_pbc && wps_advertizing)
-				connman_network_set_bool(connman_network,
-							"WiFi.UseWPS", true);
+		GSupplicantPeer *supplicant_peer = g_supplicant_interface_peer_lookup(iface, bssid_no_colon);
+		if (supplicant_peer) {
+			peer_changed(supplicant_peer, G_SUPPLICANT_PEER_GROUP_JOINED);
 		}
+	}
 
-		update_needed = true;
-	} else if (g_str_equal(property, "Signal")) {
-		connman_network_set_strength(connman_network,
-					calculate_strength(network));
-		update_needed = true;
-	} else
-		update_needed = false;
+	if (is_group_owner && create_group_flag) {
+		g_dbus_send_reply(connection, group_msg,
+						DBUS_TYPE_OBJECT_PATH, &connman_group_path,
+						DBUS_TYPE_INVALID);
 
-	if (update_needed)
-		connman_network_update(connman_network);
+		create_group_flag = FALSE;
+		dbus_message_unref(group_msg);
+	}
 }
 
-static void network_associated(GSupplicantNetwork *network)
+static void p2p_find_group_stop(struct wifi_data *wifi)
 {
-	GSupplicantInterface *interface;
+	if (wifi) {
+		wifi->p2p_find_timeout = 0;
+		g_supplicant_interface_p2p_stop_find(wifi->interface);
+	}
+}
+
+static void p2p_group_finished(GSupplicantInterface *interface)
+{
+	GList *list;
 	struct wifi_data *wifi;
-	struct connman_network *connman_network;
-	const char *identifier;
+	GSupplicantInterface *not_group_interface;
 
 	DBG("");
 
-	interface = g_supplicant_network_get_interface(network);
-	if (!interface)
-		return;
-
-	wifi = g_supplicant_interface_get_data(interface);
-	if (!wifi)
-		return;
-
-	/* P2P networks must not be treated as WiFi networks */
-	if (wifi->p2p_connecting || wifi->p2p_device)
-		return;
+	if (p2p_go_identifier) {
+		struct connman_group *connman_group = __connman_group_lookup_from_ident(p2p_go_identifier);
+		if (connman_group->autonomous)
+			__connman_p2p_go_set_disabled();
 
-	identifier = g_supplicant_network_get_identifier(network);
+		g_free(p2p_go_identifier);
+		p2p_go_identifier = NULL;
+	}
 
-	connman_network = connman_device_get_network(wifi->device, identifier);
-	if (!connman_network)
-		return;
+	__connman_group_remove(interface);
 
-	if (wifi->network) {
-		if (wifi->network == connman_network)
-			return;
+	for (list = iface_list; list; list = list->next) {
+		wifi = list->data;
+		not_group_interface = wifi->interface;
 
-		/*
-		 * This should never happen, we got associated with
-		 * a network different than the one we were expecting.
-		 */
-		DBG("Associated to %p while expecting %p",
-					connman_network, wifi->network);
+		if (!not_group_interface ||
+			!g_supplicant_interface_has_p2p(wifi->interface))
+			continue;
 
-		connman_network_set_associating(wifi->network, false);
+		p2p_find_group_stop(wifi);
+		if (wifi->p2p_listen_suppressed == true ||
+				connman_technology_get_p2p_listen(p2p_technology)) {
+			leave_p2p_listen_on_iface(wifi);
+			p2p_peers_refresh(wifi);
+			if (wifi->p2p_listen_suppressed == true)
+				wifi->p2p_listen_suppressed = false;
+		}
 	}
 
-	DBG("Reconnecting to previous network %p from wpa_s", connman_network);
+	if (p2p_group_ifname) {
+		g_free(p2p_group_ifname);
+		p2p_group_ifname = NULL;
+	}
+}
 
-	wifi->network = connman_network_ref(connman_network);
-	wifi->retries = 0;
+static gboolean p2p_pbc_requested(gpointer argv)
+{
+	pbc_requested_ref = -1;
 
-	/*
-	 * Interface state changes callback (interface_state) is always
-	 * called before network_associated callback thus we need to call
-	 * interface_state again in order to process the new state now that
-	 * we have the network properly set.
-	 */
-	interface_state(interface);
+	return FALSE;
 }
 
-static void sta_authorized(GSupplicantInterface *interface,
-					const char *addr)
+static void p2p_invitation_result(GSupplicantInterface *interface, int status)
 {
-	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+	struct wifi_data *wifi;
 
-	DBG("wifi %p station %s authorized", wifi, addr);
+	wifi = g_supplicant_interface_get_data(interface);
 
-	if (!wifi || !wifi->tethering)
+	if (!wifi)
 		return;
 
-	__connman_tethering_client_register(addr);
+	DBG("status %i", status);
+
+	__connman_technology_p2p_invitation_result(p2p_technology, status);
 }
 
-static void sta_deauthorized(GSupplicantInterface *interface,
-					const char *addr)
+static void p2p_invitation_received(GSupplicantInterface *interface,
+				GSupplicantPeer *peer, const char *go_dev_addr, bool persistent)
 {
 	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+	struct connman_peer *connman_peer;
+	const char *identifier, *path;
+	const char *go_dev_addr_colon;
 
-	DBG("wifi %p station %s deauthorized", wifi, addr);
-
-	if (!wifi || !wifi->tethering)
+	if (!wifi || !wifi->device)
 		return;
 
-	__connman_tethering_client_unregister(addr);
-}
+	identifier = g_supplicant_peer_get_identifier(peer);
+
+	DBG("ident: %s", identifier);
 
-static void station_added(const char *mac)
-{
-	int stacount = 0;
-	connman_technology_tethering_add_station(CONNMAN_SERVICE_TYPE_WIFI, mac);
+	connman_peer = connman_peer_get(wifi->device, identifier);
+	if (!connman_peer)
+		return;
 
-	stacount = __connman_tethering_sta_count();
-	__connman_technology_sta_count_changed(CONNMAN_SERVICE_TYPE_WIFI, stacount);
-}
+	go_dev_addr_colon = __connman_util_insert_colon_to_mac_addr(go_dev_addr);
+	path = __connman_peer_get_path(connman_peer);
 
-static void station_removed(const char *mac)
-{
-	int stacount = 0;
+	if (!path) {
+		g_free(go_dev_addr_colon);
+		return;
+	}
 
-	connman_technology_tethering_remove_station(mac);
+	if (!persistent) {
+		connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_IDLE);
+
+		/* Invitation received from GO */
+		if (g_str_equal(identifier, go_dev_addr)) {
+			wifi->invited_path = __connman_peer_get_path(connman_peer);
+		/* Sometimes there is only src address in InvitationReceived signal without GO device address */
+		} else if (g_str_equal(go_dev_addr, "000000000000")) {
+			wifi->invited_path = __connman_peer_get_path(connman_peer);
+			g_free(go_dev_addr_colon);
+			go_dev_addr_colon = __connman_util_insert_colon_to_mac_addr(identifier);
+		} else {
+			struct connman_network *network_go = connman_device_get_network(wifi->device, go_dev_addr);
 
-	stacount = __connman_tethering_sta_count();
-	__connman_technology_sta_count_changed(CONNMAN_SERVICE_TYPE_WIFI, stacount);
-}
+			if (network_go) {
+				struct connman_service *service_go;
 
-static void apply_peer_services(GSupplicantPeer *peer,
-				struct connman_peer *connman_peer)
-{
-	const unsigned char *data;
-	int length;
+				wifi->invited_path = connman_network_get_string(network_go, "Path");
+			}
+		}
 
-	DBG("");
+		connman_peer_invitation_request(path, "P2PInvitationReceived", go_dev_addr_colon);
 
-	connman_peer_reset_services(connman_peer);
+	} else {
+		p2p_find_stop(wifi->device);
+		if (connman_technology_get_p2p_listen(p2p_technology) == true &&
+			connman_peer_get_state(connman_peer) == CONNMAN_PEER_STATE_READY) {//already changed to listen off
+			leave_p2p_listen_on_iface(wifi);
+			connman_technology_set_p2p_listen(p2p_technology, false);
+		}
 
-	data = g_supplicant_peer_get_widi_ies(peer, &length);
-	if (data) {
-		connman_peer_add_service(connman_peer,
-			CONNMAN_PEER_SERVICE_WIFI_DISPLAY, data, length);
+		connman_peer_invitation_request(path, "P2PPersistentReceived", go_dev_addr_colon);
 	}
 }
 
-static void peer_found(GSupplicantPeer *peer)
+static void p2p_prov_disc_requested_pbc(GSupplicantInterface *interface,
+					GSupplicantPeer *peer)
 {
-	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
-	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 	struct connman_peer *connman_peer;
-	const char *identifier, *name;
-	int ret;
+	const char *identifier, *path;
+	const char *sig = "pbc";
+
+	if (!wifi || !wifi->device)
+		return;
 
 	identifier = g_supplicant_peer_get_identifier(peer);
-	name = g_supplicant_peer_get_name(peer);
 
 	DBG("ident: %s", identifier);
 
+	/** Throttle pbc requested messages */
+	if (pbc_requested_ref != -1) {
+		g_source_remove(pbc_requested_ref);
+		pbc_requested_ref = g_timeout_add_seconds(2, p2p_pbc_requested, NULL);
+		return;
+	}
+
 	connman_peer = connman_peer_get(wifi->device, identifier);
-	if (connman_peer)
+	if (!connman_peer)
 		return;
+	if (connman_peer_get_state(connman_peer) != CONNMAN_PEER_STATE_ASSOCIATION)
+	{
+	connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_IDLE);
+	connman_peer_set_as_master(connman_peer, false);
+	}
+	path = __connman_peer_get_path(connman_peer);
 
-	connman_peer = connman_peer_create(identifier);
-	connman_peer_set_name(connman_peer, name);
-	connman_peer_set_device(connman_peer, wifi->device);
-	apply_peer_services(peer, connman_peer);
+	if (path && p2p_go_identifier) {
+		connman_dbus_property_changed_basic(path,
+					CONNMAN_PEER_INTERFACE,
+					"P2PProvDiscRequestedPBC",
+					DBUS_TYPE_STRING, &sig);
 
-	ret = connman_peer_register(connman_peer);
-	if (ret < 0 && ret != -EALREADY)
-		connman_peer_unref(connman_peer);
-	else
-		wifi->peers = g_slist_prepend(wifi->peers, connman_peer);
+		pbc_requested_ref = g_timeout_add_seconds(2, p2p_pbc_requested, NULL);
+	}
 }
 
-static void peer_lost(GSupplicantPeer *peer)
+static void p2p_prov_disc_requested_enter_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer)
 {
-	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
-	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 	struct connman_peer *connman_peer;
-	const char *identifier;
+	struct connman_network *connman_network;
+	const char *identifier, *path;
+	const char *sig = "keypad";
 
-	if (!wifi)
+	if (!wifi || !wifi->device)
 		return;
 
 	identifier = g_supplicant_peer_get_identifier(peer);
 
 	DBG("ident: %s", identifier);
 
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
+
+//	wfds_on_p2p_pin_requested(connman_network, NULL);
+
 	connman_peer = connman_peer_get(wifi->device, identifier);
-	if (connman_peer) {
-		if (wifi->p2p_connecting &&
-				wifi->pending_peer == connman_peer) {
-			peer_connect_timeout(wifi);
-		}
-		connman_peer_unregister(connman_peer);
-		connman_peer_unref(connman_peer);
+	if (!connman_peer)
+		return;
+
+	connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_IDLE);
+	connman_peer_set_as_master(connman_peer, false);
+
+	path = __connman_peer_get_path(connman_peer);
+
+	if (p2p_go_identifier) {
+		connman_dbus_property_changed_basic(path,
+					CONNMAN_PEER_INTERFACE,
+					"P2PProvDiscRequestedEnterPin",
+					DBUS_TYPE_STRING, &sig);
 	}
+}
 
-	wifi->peers = g_slist_remove(wifi->peers, connman_peer);
+static gboolean p2p_pin_requested(gpointer argv)
+{
+	pin_requested_ref = -1;
+
+	return FALSE;
 }
 
-static void peer_changed(GSupplicantPeer *peer, GSupplicantPeerState state)
+static void p2p_prov_disc_requested_display_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, const char *pin)
 {
-	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
-	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
-	enum connman_peer_state p_state = CONNMAN_PEER_STATE_UNKNOWN;
+	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
 	struct connman_peer *connman_peer;
-	const char *identifier;
+	struct connman_network *connman_network;
+	const char *identifier, *path;
+	const char *sig = "keypad";
+
+	if (!wifi || !wifi->device)
+		return;
 
 	identifier = g_supplicant_peer_get_identifier(peer);
 
 	DBG("ident: %s", identifier);
 
-	if (!wifi)
+	/** Throttle pin requested messages */
+	if (pin_requested_ref != -1) {
+		g_source_remove(pin_requested_ref);
+		pin_requested_ref = g_timeout_add_seconds(2, p2p_pin_requested, NULL);
+		return;
+	}
+
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
 		return;
 
 	connman_peer = connman_peer_get(wifi->device, identifier);
 	if (!connman_peer)
 		return;
 
-	switch (state) {
-	case G_SUPPLICANT_PEER_SERVICES_CHANGED:
-		apply_peer_services(peer, connman_peer);
-		connman_peer_services_changed(connman_peer);
-		return;
-	case G_SUPPLICANT_PEER_GROUP_CHANGED:
-		if (!g_supplicant_peer_is_in_a_group(peer))
-			p_state = CONNMAN_PEER_STATE_IDLE;
-		else
-			p_state = CONNMAN_PEER_STATE_CONFIGURATION;
-		break;
-	case G_SUPPLICANT_PEER_GROUP_STARTED:
-		break;
-	case G_SUPPLICANT_PEER_GROUP_FINISHED:
-		p_state = CONNMAN_PEER_STATE_IDLE;
-		break;
-	case G_SUPPLICANT_PEER_GROUP_JOINED:
-		connman_peer_set_iface_address(connman_peer,
-				g_supplicant_peer_get_iface_address(peer));
-		break;
-	case G_SUPPLICANT_PEER_GROUP_DISCONNECTED:
-		p_state = CONNMAN_PEER_STATE_IDLE;
-		break;
-	case G_SUPPLICANT_PEER_GROUP_FAILED:
-		if (g_supplicant_peer_has_requested_connection(peer))
-			p_state = CONNMAN_PEER_STATE_IDLE;
-		else
-			p_state = CONNMAN_PEER_STATE_FAILURE;
-		break;
-	}
+	connman_peer_set_state(connman_peer, CONNMAN_PEER_STATE_IDLE);
+	connman_peer_set_as_master(connman_peer, false);
+	path = __connman_peer_get_path(connman_peer);
 
-	if (p_state == CONNMAN_PEER_STATE_CONFIGURATION ||
-					p_state == CONNMAN_PEER_STATE_FAILURE) {
-		if (wifi->p2p_connecting
-				&& connman_peer == wifi->pending_peer)
-			peer_cancel_timeout(wifi);
-		else
-			p_state = CONNMAN_PEER_STATE_UNKNOWN;
-	}
+	wifi->generated_pin = pin;
+	wifi->pin_requested_path = connman_network_get_string(connman_network, "Path");
 
-	if (p_state == CONNMAN_PEER_STATE_UNKNOWN)
-		return;
+//	wfds_on_p2p_pin_requested(connman_network, pin);
 
-	if (p_state == CONNMAN_PEER_STATE_CONFIGURATION) {
-		GSupplicantInterface *g_iface;
-		struct wifi_data *g_wifi;
+	if (p2p_go_identifier || __connman_group_exist() == FALSE) {
+		connman_dbus_property_changed_basic(path,
+					CONNMAN_PEER_INTERFACE,
+					"P2PProvDiscRequestedDisplayPin",
+					DBUS_TYPE_STRING, &pin);
 
-		g_iface = g_supplicant_peer_get_group_interface(peer);
-		if (!g_iface)
-			return;
+		pin_requested_ref = g_timeout_add_seconds(2, p2p_pin_requested, NULL);
+	}
+}
 
-		g_wifi = g_supplicant_interface_get_data(g_iface);
-		if (!g_wifi)
-			return;
+static void p2p_prov_disc_response_enter_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer)
+{
+	struct wifi_data *wifi;
+	const char *identifier;
+	struct connman_network *connman_network;
 
-		connman_peer_set_as_master(connman_peer,
-					!g_supplicant_peer_is_client(peer));
-		connman_peer_set_sub_device(connman_peer, g_wifi->device);
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_peer_get_identifier(peer);
 
-		/*
-		 * If wpa_supplicant didn't create a dedicated p2p-group
-		 * interface then mark this interface as p2p_device to avoid
-		 * scan and auto-scan are launched on it while P2P is connected.
-		 */
-		if (!g_list_find(p2p_iface_list, g_wifi))
-			wifi->p2p_device = true;
-	}
+	DBG("identifier %s", identifier);
 
-	connman_peer_set_state(connman_peer, p_state);
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
+
+//	wfds_on_p2p_pin_response(connman_network, NULL);
 }
 
-static void peer_request(GSupplicantPeer *peer)
+static void p2p_prov_disc_response_display_pin(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, const char *pin)
 {
-	GSupplicantInterface *iface = g_supplicant_peer_get_interface(peer);
-	struct wifi_data *wifi = g_supplicant_interface_get_data(iface);
-	struct connman_peer *connman_peer;
+	struct wifi_data *wifi;
 	const char *identifier;
+	struct connman_network *connman_network;
 
+	wifi = g_supplicant_interface_get_data(interface);
 	identifier = g_supplicant_peer_get_identifier(peer);
 
-	DBG("ident: %s", identifier);
+	DBG("identifier %s", identifier);
 
-	connman_peer = connman_peer_get(wifi->device, identifier);
-	if (!connman_peer)
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
 		return;
 
-	connman_peer_request_connection(connman_peer);
+//	wfds_on_p2p_pin_response(connman_network, pin);
 }
 
-static void debug(const char *str)
+static void p2p_prov_disc_fail(GSupplicantInterface *interface,
+					GSupplicantPeer *peer, int status)
 {
-	if (getenv("CONNMAN_SUPPLICANT_DEBUG"))
-		connman_debug("%s", str);
-}
+	struct wifi_data *wifi;
+	const char *identifier;
+	struct connman_network *connman_network;
 
-static void disconnect_reasoncode(GSupplicantInterface *interface,
-				int reasoncode)
-{
-	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+	wifi = g_supplicant_interface_get_data(interface);
+	identifier = g_supplicant_peer_get_identifier(peer);
 
-	if (wifi != NULL) {
-		wifi->disconnect_code = reasoncode;
-	}
-}
+	DBG("identifier %s", identifier);
 
-static void assoc_status_code(GSupplicantInterface *interface, int status_code)
-{
-	struct wifi_data *wifi = g_supplicant_interface_get_data(interface);
+	connman_network = connman_device_get_network(wifi->device, identifier);
+	if (!connman_network)
+		return;
 
-	if (wifi != NULL) {
-		wifi->assoc_code = status_code;
-	}
+//	wfds_on_p2p_prov_failed(connman_network, status);
 }
 
 static const GSupplicantCallbacks callbacks = {
@@ -3679,6 +5888,7 @@ static const GSupplicantCallbacks callbacks = {
 	.interface_state	= interface_state,
 	.interface_removed	= interface_removed,
 	.p2p_support		= p2p_support,
+	.p2p_device_config_loaded = p2p_device_config_loaded,
 	.scan_started		= scan_started,
 	.scan_finished		= scan_finished,
 	.ap_create_fail		= ap_create_fail,
@@ -3694,13 +5904,29 @@ static const GSupplicantCallbacks callbacks = {
 	.peer_lost		= peer_lost,
 	.peer_changed		= peer_changed,
 	.peer_request		= peer_request,
+	.p2p_sd_response = p2p_sd_response,
+	.p2p_sd_asp_response = p2p_sd_asp_response,
 	.wps_state		= wps_state,
 	.debug			= debug,
 	.disconnect_reasoncode  = disconnect_reasoncode,
 	.assoc_status_code      = assoc_status_code,
+	.p2p_group_started		= p2p_group_started,
+	.p2p_group_finished		= p2p_group_finished,
+	.p2ps_prov_start = p2ps_prov_start,
+	.p2ps_prov_done = p2ps_prov_done,
+	.p2p_persistent_group_added = p2p_persistent_group_added,
+	.p2p_persistent_group_removed = p2p_persistent_group_removed,
+	.p2p_prov_disc_requested_pbc = p2p_prov_disc_requested_pbc,
+	.p2p_prov_disc_requested_enter_pin = p2p_prov_disc_requested_enter_pin,
+	.p2p_prov_disc_requested_display_pin = p2p_prov_disc_requested_display_pin,
+	.p2p_prov_disc_response_enter_pin = p2p_prov_disc_response_enter_pin,
+	.p2p_prov_disc_response_display_pin = p2p_prov_disc_response_display_pin,
+	.p2p_prov_disc_fail = p2p_prov_disc_fail,
+
+	.p2p_invitation_result = p2p_invitation_result,
+	.p2p_invitation_received = p2p_invitation_received,
 };
 
-
 static int tech_probe(struct connman_technology *technology)
 {
 	wifi_technology = technology;
@@ -4005,6 +6231,21 @@ static int tech_set_regdom(struct connman_technology *technology, const char *al
 	return g_supplicant_set_country(alpha2, regdom_callback, NULL);
 }
 
+static void tech_add_interface(struct connman_technology *technology,
+			int index, const char *name, const char *ident)
+{
+	DBG("index %d name %s ident %s", index, name, ident);
+
+	if(p2p_group_if_prefix && g_str_has_prefix(name, p2p_group_if_prefix)) {
+		if (p2p_group_ifname) {
+			g_free(p2p_group_ifname);
+			p2p_group_ifname = NULL;
+		}
+		p2p_group_ifname = g_strdup(name);
+		p2p_group_ifindex = index;
+	}
+}
+
 static struct connman_technology_driver tech_driver = {
 	.name		= "wifi",
 	.type		= CONNMAN_SERVICE_TYPE_WIFI,
@@ -4012,12 +6253,15 @@ static struct connman_technology_driver tech_driver = {
 	.remove		= tech_remove,
 	.set_tethering	= tech_set_tethering,
 	.set_regdom	= tech_set_regdom,
+	.add_interface = tech_add_interface,
 };
 
 static int wifi_init(void)
 {
 	int err;
 
+	connection = connman_dbus_get_connection();
+
 	err = connman_network_driver_register(&network_driver);
 	if (err < 0)
 		return err;
@@ -4038,6 +6282,72 @@ static int wifi_init(void)
 	return 0;
 }
 
+
+
+
+static enum connman_peer_wps_method p2psconnect_mode_to_wpa_method(int mode){
+
+ /*
+  always be in sync with p2p_connect_mode
+		typedef enum _p2p_connect_mode {
+			P2P_CONNECT_DISPLAY = 1,
+			P2P_CONNECT_KEYPAD = 5,
+			P2P_CONNECT_P2PS = 8
+		} p2p_connect_mode;
+
+ */
+   enum  connman_peer_wps_method wps_method=CONNMAN_PEER_WPS_UNKNOWN;
+
+	switch(mode){
+       case 1:
+                wps_method=CONNMAN_PEER_WPS_DISPLAY;
+		break;
+	case 5:
+                 wps_method=CONNMAN_PEER_WPS_KEYBOARD;
+		break;
+	case 8:
+                 wps_method=CONNMAN_PEER_WPS_P2PS;
+		break;
+
+	}
+	return wps_method;
+
+}
+
+
+
+/** WFDS calls into wifi.c */
+int wfds_p2p_wifi_connect(struct connman_network* network, int mode, const char* pin, gboolean persistent)
+{
+	struct connman_peer *connman_peer;
+	connman_peer = connman_peer_get(connman_network_get_device(network), connman_network_get_identifier(network));
+
+	return  peer_connect(connman_peer, p2psconnect_mode_to_wpa_method(mode), pin);
+
+}
+
+int wfds_p2p_wifi_disconnect(struct connman_network* network, GSupplicantP2PGroup* group)
+{
+	g_supplicant_interface_p2p_group_disconnect(group->group_interface, NULL, NULL);
+
+	return 0;
+}
+
+int wfds_p2p_wifi_extended_listen(gboolean enabled)
+{
+	if (enabled)
+	{
+		tech_set_p2p_listen_params(wifi_technology, 450, 500);
+	}
+
+	int err = tech_set_p2p_listen(wifi_technology, enabled);
+
+	if (err == -EINPROGRESS)
+		err = 0;
+
+	return err;
+}
+
 static void wifi_exit(void)
 {
 	DBG();
diff --git a/src/connman.h b/src/connman.h
index 5765c302..defd8f2a 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -279,6 +279,7 @@ void __connman_storage_save_provider(GKeyFile *keyfile, const char *identifier);
 bool __connman_storage_remove_provider(const char *identifier);
 char **__connman_storage_get_providers(void);
 bool __connman_storage_remove_service(const char *service_id);
+gchar **__connman_storage_get_p2p_persistents(void);
 
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
@@ -463,6 +464,7 @@ typedef void (* dhcpv6_cb) (struct connman_network *network,
 typedef void (* dhcp_cb) (struct connman_ipconfig *ipconfig,
 			struct connman_network *opt_network,
 			bool success, gpointer data);
+char *__connman_dhcp_get_client_address(struct connman_ipconfig *ipconfig);
 char *__connman_dhcp_get_server_address(struct connman_ipconfig *ipconfig);
 int __connman_dhcp_start(struct connman_ipconfig *ipconfig,
 			struct connman_network *network, dhcp_cb callback,
@@ -556,6 +558,8 @@ void __connman_technology_remove_interface(enum connman_service_type type,
 				int index, const char *ident);
 void __connman_technology_notify_regdom_by_device(struct connman_device *device,
 						int result, const char *alpha2);
+int __connman_technology_set_p2p_go(DBusMessage *msg, const char *ident,
+				const char *passphrase);
 
 #include <connman/device.h>
 
@@ -570,6 +574,7 @@ int __connman_device_request_scan(enum connman_service_type type);
 int __connman_device_request_scan_full(enum connman_service_type type);
 int __connman_device_request_start_wps(enum connman_service_type type, const char *pin);
 int __connman_device_request_cancel_wps(enum connman_service_type type);
+int __connman_device_request_cancel_p2p(enum connman_service_type type);
 int __connman_device_request_hidden_scan(struct connman_device *device,
 				const char *ssid, unsigned int ssid_len,
 				const char *identity, const char *passphrase,
@@ -694,6 +699,7 @@ int __connman_service_compare(const struct connman_service *a,
 					const struct connman_service *b);
 
 struct connman_service *__connman_service_lookup_from_index(int index);
+struct connman_service *__connman_service_lookup_from_ident(const char *identifier);
 struct connman_service *__connman_service_create_from_network(struct connman_network *network);
 struct connman_service *__connman_service_create_from_provider(struct connman_provider *provider);
 bool __connman_service_index_is_default(int index);
@@ -845,7 +851,9 @@ void __connman_peer_cleanup(void);
 
 void __connman_peer_list_struct(DBusMessageIter *array);
 const char *__connman_peer_get_path(struct connman_peer *peer);
-void __connman_peer_disconnect_all(void);
+void __connman_peer_set_static_ip(struct connman_peer *peer, char* static_ip);
+void __connman_peer_set_autonomous_group(struct connman_peer *peer, bool autonomous_group);
+bool __connman_peer_get_connected_exists(void);
 
 int __connman_peer_service_init(void);
 void __connman_peer_service_cleanup(void);
@@ -999,6 +1007,15 @@ typedef void (*ippool_collision_cb_t) (struct connman_ippool *pool,
 int __connman_ippool_init(void);
 void __connman_ippool_cleanup(void);
 
+#define __connman_ippool_ref(ipconfig) \
+	__connman_ippool_ref_debug(ipconfig, __FILE__, __LINE__, __func__)
+#define __connman_ippool_unref(ipconfig) \
+	__connman_ippool_unref_debug(ipconfig, __FILE__, __LINE__, __func__)
+
+struct connman_ippool *__connman_ippool_ref_debug(struct connman_ippool *pool,
+			const char *file, int line, const char *caller);
+void __connman_ippool_unref_debug(struct connman_ippool *pool,
+			const char *file, int line, const char *caller);
 void __connman_ippool_free(struct connman_ippool *pool);
 
 struct connman_ippool *__connman_ippool_create(int index,
@@ -1007,6 +1024,13 @@ struct connman_ippool *__connman_ippool_create(int index,
 					ippool_collision_cb_t collision_cb,
 					void *user_data);
 
+struct connman_ippool *__connman_ippool_create_with_block(int index,
+					unsigned int start,
+					unsigned int range,
+					uint32_t block,
+					ippool_collision_cb_t collision_cb,
+					void *user_data);
+
 const char *__connman_ippool_get_gateway(struct connman_ippool *pool);
 const char *__connman_ippool_get_broadcast(struct connman_ippool *pool);
 const char *__connman_ippool_get_subnet_mask(struct connman_ippool *pool);
@@ -1093,3 +1117,4 @@ int __connman_util_get_random(uint64_t *val);
 unsigned int __connman_util_random_delay_ms(unsigned int secs);
 int __connman_util_init(void);
 void __connman_util_cleanup(void);
+char *__connman_util_insert_colon_to_mac_addr(const char *mac_addr);
diff --git a/src/dbus.c b/src/dbus.c
index d80a46ce..e0b69d4c 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -182,6 +182,11 @@ void connman_dbus_property_append_array(DBusMessageIter *iter,
 	const char *variant_sig, *array_sig;
 
 	switch (type) {
+	case DBUS_TYPE_BYTE:
+		variant_sig = DBUS_TYPE_ARRAY_AS_STRING
+				DBUS_TYPE_BYTE_AS_STRING;
+		array_sig = DBUS_TYPE_BYTE_AS_STRING;
+		break;
 	case DBUS_TYPE_STRING:
 		variant_sig = DBUS_TYPE_ARRAY_AS_STRING
 				DBUS_TYPE_STRING_AS_STRING;
diff --git a/src/device.c b/src/device.c
index ce70da90..5c6d3637 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1060,6 +1060,9 @@ void connman_device_unregister(struct connman_device *device)
  */
 void *connman_device_get_data(struct connman_device *device)
 {
+	if(!device)
+		return NULL;
+
 	return device->driver_data;
 }
 
@@ -1348,6 +1351,79 @@ int __connman_device_request_cancel_wps(enum connman_service_type type)
 	return last_err;
 }
 
+static int device_cancel_p2p(struct connman_device *device)
+{
+	if (!device->driver || !device->driver->cancel_p2p)
+		return -EOPNOTSUPP;
+
+	if (!device->powered)
+		return -ENOLINK;
+
+	return device->driver->cancel_p2p(device);
+}
+
+static int device_driver_info(struct connman_device *device)
+{
+	if (!device->driver || !device->driver->cancel_p2p)
+		return -EOPNOTSUPP;
+
+	if (!device->powered)
+		return -ENOLINK;
+
+	return device->driver->get_driver_info(device);
+}
+
+int __connman_device_request_cancel_p2p(enum connman_service_type type)
+{
+	int last_err = -ENOSYS;
+	GSList *list;
+	int err;
+
+	switch (type) {
+	case CONNMAN_SERVICE_TYPE_UNKNOWN:
+	case CONNMAN_SERVICE_TYPE_SYSTEM:
+	case CONNMAN_SERVICE_TYPE_ETHERNET:
+	case CONNMAN_SERVICE_TYPE_BLUETOOTH:
+	case CONNMAN_SERVICE_TYPE_CELLULAR:
+	case CONNMAN_SERVICE_TYPE_GPS:
+	case CONNMAN_SERVICE_TYPE_VPN:
+	case CONNMAN_SERVICE_TYPE_GADGET:
+		return -EOPNOTSUPP;
+	case CONNMAN_SERVICE_TYPE_WIFI:
+	case CONNMAN_SERVICE_TYPE_P2P:
+		break;
+	}
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_device *device = list->data;
+		enum connman_service_type service_type =
+			__connman_device_get_service_type(device);
+
+		if (service_type != CONNMAN_SERVICE_TYPE_UNKNOWN) {
+			if (type == CONNMAN_SERVICE_TYPE_P2P) {
+				if (service_type != CONNMAN_SERVICE_TYPE_WIFI)
+					continue;
+			} else if (service_type != type)
+				continue;
+		}
+
+		if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+				g_strcmp0(connman_device_get_string(device, "Interface"),
+					connman_option_get_string("P2PDevice")) != 0)
+			continue;
+
+		err = device_cancel_p2p(device);
+		if (err == 0) {
+			return 0;
+		} else {
+			last_err = err;
+			DBG("device %p err %d", device, err);
+		}
+	}
+
+	return last_err;
+}
+
 int connman_device_request_signal_info(struct connman_device *device,
                                        connman_device_request_signal_info_cb cb, void *user_data)
 {
diff --git a/src/dhcp.c b/src/dhcp.c
index 42e9f417..a1df8289 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -659,6 +659,16 @@ static int dhcp_release(struct connman_dhcp *dhcp)
 
 	return 0;
 }
+char *__connman_dhcp_get_client_address(struct connman_ipconfig *ipconfig)
+{
+	struct connman_dhcp *dhcp;
+
+	dhcp = g_hash_table_lookup(ipconfig_table, ipconfig);
+	if (!dhcp)
+		return NULL;
+
+	return g_dhcp_client_get_address(dhcp->dhcp_client);
+}
 
 char *__connman_dhcp_get_server_address(struct connman_ipconfig *ipconfig)
 {
diff --git a/src/group.c b/src/group.c
new file mode 100644
index 00000000..83661cf1
--- /dev/null
+++ b/src/group.c
@@ -0,0 +1,799 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2013-2019 LG Electronics, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <netdb.h>
+#include <gdbus.h>
+#include <ctype.h>
+
+#include <connman/storage.h>
+#include <connman/setting.h>
+#include <connman/agent.h>
+#include "include/group.h"
+#include <gsupplicant/gsupplicant.h>
+
+#include "connman.h"
+
+static DBusConnection *connection = NULL;
+static GList *group_list = NULL;
+static GHashTable *group_hash = NULL;
+
+struct peer_cb_data {
+	DBusMessageIter *iter;
+	struct connman_group *group;
+};
+
+static struct connman_group *group_get(const char *identifier)
+{
+	struct connman_group *group;
+
+	group = g_hash_table_lookup(group_hash, identifier);
+	if (group) {
+		return group;
+	}
+
+	group = g_try_new0(struct connman_group, 1);
+	if (!group)
+		return NULL;
+
+	DBG("group %p", group);
+
+	group->identifier = g_strdup(identifier);
+	group->peer_hash = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	group->peer_intf = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+
+	group_list = g_list_prepend(group_list, group);
+
+	g_hash_table_insert(group_hash, group->identifier, group);
+
+	return group;
+}
+
+static int set_tethering(struct connman_group *group,
+		bool enabled)
+{
+	group->tethering = enabled;
+	dbus_bool_t val = enabled;
+
+	connman_dbus_property_changed_basic(group->path,
+			CONNMAN_GROUP_INTERFACE, "Tethering",
+			DBUS_TYPE_BOOLEAN,
+			&val);
+
+	if (enabled == TRUE) {
+		__connman_p2p_go_set_enabled();
+		__connman_p2p_go_tethering_set_enabled();
+	} else {
+		__connman_p2p_go_tethering_set_disabled();
+		__connman_p2p_go_set_disabled();
+	}
+
+	return 0;
+}
+
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_group *group = user_data;
+	DBusMessageIter iter, value;
+	const char *name;
+	int type;
+
+	DBG("group %p", group);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_VARIANT)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_recurse(&iter, &value);
+
+	type = dbus_message_iter_get_arg_type(&value);
+
+	if (g_str_equal(name, "Tethering") == TRUE) {
+		int err;
+		bool tethering;
+
+		if (type != DBUS_TYPE_BOOLEAN)
+			return __connman_error_invalid_arguments(msg);
+
+		dbus_message_iter_get_basic(&value, &tethering);
+
+		if (group->tethering == tethering) {
+			if (tethering == FALSE)
+				return __connman_error_already_disabled(msg);
+			else
+				return __connman_error_already_enabled(msg);
+		}
+
+		err = set_tethering(group, tethering);
+		if (err < 0)
+			return __connman_error_failed(msg, -err);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static void append_properties(DBusMessageIter *dict, struct connman_group *group)
+{
+	dbus_bool_t val;
+	struct connman_peer *connman_peer = NULL;
+
+	if(group->name)
+		connman_dbus_dict_append_basic(dict, "Name", DBUS_TYPE_STRING, &group->name);
+
+	val = group->is_group_owner;
+	connman_dbus_dict_append_basic(dict, "Owner", DBUS_TYPE_BOOLEAN, &val);
+
+	if (group->is_group_owner)
+		connman_dbus_dict_append_basic(dict, "Passphrase", DBUS_TYPE_STRING, &group->passphrase);
+	else if (group->group_owner)
+		connman_dbus_dict_append_basic(dict, "OwnerPath", DBUS_TYPE_OBJECT_PATH, &group->group_owner);
+
+	val = group->is_persistent;
+	connman_dbus_dict_append_basic(dict, "Persistent", DBUS_TYPE_BOOLEAN, &val);
+
+	val = group->tethering;
+	connman_dbus_dict_append_basic(dict, "Tethering", DBUS_TYPE_BOOLEAN, &val);
+
+	connman_dbus_dict_append_basic(dict, "Freq", DBUS_TYPE_UINT32, &group->freq);
+
+	if(group->is_group_owner)
+		__connman_dhcpserver_append_gateway(dict);
+	/*else {
+		connman_peer = connman_peer_get_by_path(group->group_owner);
+		if (connman_peer) {
+			connman_peer_get_local_address(dict, connman_peer);
+		}
+	}*/
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_group *group = user_data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("group %p", group);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	connman_dbus_dict_open(&array, &dict);
+	append_properties(&dict, group);
+	connman_dbus_dict_close(&array, &dict);
+
+	return reply;
+}
+
+static void group_added_signal(struct connman_group *group)
+{
+	DBusMessage *signal;
+	DBusMessageIter iter;
+	DBusMessageIter dict;
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+			CONNMAN_MANAGER_INTERFACE, "GroupAdded");
+	if (!signal)
+		return;
+
+	dbus_message_iter_init_append(signal, &iter);
+	dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH,
+							&group->path);
+
+	connman_dbus_dict_open(&iter, &dict);
+	append_properties(&dict, group);
+	connman_dbus_dict_close(&iter, &dict);
+
+	dbus_connection_send(connection, signal, NULL);
+	dbus_message_unref(signal);
+}
+
+static void group_removed_signal(struct connman_group *group)
+{
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+			CONNMAN_MANAGER_INTERFACE, "GroupRemoved",
+			DBUS_TYPE_OBJECT_PATH, &group->path,
+			DBUS_TYPE_INVALID);
+}
+
+static void p2p_disconnect_callback(int result,
+					GSupplicantInterface *interface,
+							void *user_data)
+{
+	struct connman_group *group = user_data;
+
+	DBG("group %p\n", group);
+}
+
+static DBusMessage *p2p_disconnect(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_group *group = user_data;
+	int err = 0;
+
+	DBG("group %p", group);
+
+	err = g_supplicant_interface_p2p_group_disconnect(group->interface, p2p_disconnect_callback, group);
+
+	if (err < 0) {
+		if (err != -EINPROGRESS)
+			return __connman_error_failed(msg, -err);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static void p2p_invite_callback(int result,
+					GSupplicantInterface *interface,
+							void *user_data)
+{
+	DBG("p2p invite callback %d\n", result);
+}
+
+static DBusMessage *p2p_invite(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_group *group = user_data;
+	DBusMessageIter iter;
+	const char *peer_path;
+	char *peer_ident;
+	GSupplicantP2PInviteParams *invite_params = NULL;
+	struct connman_service *service;
+	struct connman_network *network;
+	struct connman_peer *connman_peer;
+	GSupplicantPeer *gs_peer;
+
+	DBG("group %p", group);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &peer_path);
+
+	connman_peer = connman_peer_get_by_path(peer_path);
+	peer_ident = connman_peer_get_identifier(connman_peer);
+
+	gs_peer = g_supplicant_interface_peer_lookup(group->orig_interface, peer_ident);
+
+	if(!gs_peer || !g_supplicant_peer_get_path(gs_peer))
+		return __connman_error_invalid_arguments(msg);
+
+	invite_params = g_try_malloc0(sizeof(GSupplicantP2PInviteParams));
+	if (!invite_params)
+		return __connman_error_invalid_arguments(msg);
+
+	invite_params->peer = g_strdup(g_supplicant_peer_get_path(gs_peer));
+
+	g_supplicant_interface_p2p_invite(group->interface, invite_params, p2p_invite_callback, NULL);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static void append_peer_struct(gpointer value, gpointer user_data)
+{
+	struct peer_cb_data *cbd = user_data;
+	const char *peer_ident = value;
+	const char *peer_path, *peer_dev_addr = NULL;
+	DBusMessageIter entry, dict;
+	struct connman_peer *connman_peer = NULL;
+
+	DBG("peer_ident %s", peer_ident);
+
+	dbus_message_iter_open_container(cbd->iter, DBUS_TYPE_STRUCT, NULL, &entry);
+
+	peer_path = g_hash_table_lookup(cbd->group->peer_hash, peer_ident);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_OBJECT_PATH, &peer_path);
+
+	connman_peer = connman_peer_get_by_path(peer_path);
+	if (connman_peer) {
+		__connman_peer_get_properties_struct(&entry, connman_peer);
+	} else {
+		connman_dbus_dict_open(&entry, &dict);
+		peer_dev_addr = __connman_util_insert_colon_to_mac_addr(peer_ident);
+		connman_dbus_dict_append_basic(&dict, "DeviceAddress", DBUS_TYPE_STRING, &peer_dev_addr);
+		connman_dbus_dict_close(&entry, &dict);
+	}
+
+	dbus_message_iter_close_container(cbd->iter, &entry);
+	g_free(peer_dev_addr);
+}
+
+static void append_peer_structs(DBusMessageIter *iter, void *user_data)
+{
+	struct connman_group *group = user_data;
+	struct peer_cb_data cbd;
+
+	cbd.iter = iter;
+	cbd.group = group;
+
+	DBG("iter %p group %p", iter, group);
+
+	g_slist_foreach(group->peer_list, append_peer_struct, &cbd);
+}
+
+static void append_peer_go(DBusMessageIter *iter, void *user_data)
+{
+	struct connman_group *group = user_data;
+	const char *peer_ident, *peer_dev_addr = NULL;
+	DBusMessageIter entry, dict;
+	struct connman_peer *connman_peer;
+
+	if(!group || !g_list_find(group_list, group) || !group->group_owner)
+		return;
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_OBJECT_PATH, &group->group_owner);
+
+	connman_peer = connman_peer_get_by_path(group->group_owner);
+	if(connman_peer) {
+		peer_ident = connman_peer_get_identifier(connman_peer);
+		__connman_peer_get_properties_struct(&entry, connman_peer);
+	} else {
+		connman_dbus_dict_open(&entry, &dict);
+		peer_ident = strrchr(group->group_owner, '_') + 1;
+		peer_dev_addr = __connman_util_insert_colon_to_mac_addr(peer_ident);
+		connman_dbus_dict_append_basic(&dict, "DeviceAddress", DBUS_TYPE_STRING, &peer_dev_addr);
+		connman_dbus_dict_close(&entry, &dict);
+	}
+
+	dbus_message_iter_close_container(iter, &entry);
+	g_free(peer_dev_addr);
+}
+
+static DBusMessage *get_peers(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+	struct connman_group *group = user_data;
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if(group->is_group_owner)
+		__connman_dbus_append_objpath_dict_array(reply,
+			append_peer_structs, group);
+	else
+		__connman_dbus_append_objpath_dict_array(reply,
+			append_peer_go, group);
+
+	return reply;
+}
+
+static const GDBusMethodTable group_methods[] = {
+	{ GDBUS_DEPRECATED_METHOD("GetProperties",
+			NULL, GDBUS_ARGS({ "properties", "a{sv}" }),
+			get_properties) },
+	{ GDBUS_METHOD("SetProperty",
+			GDBUS_ARGS({ "name", "s" }, { "value", "v" }),
+			NULL, set_property) },
+	{ GDBUS_METHOD("Disconnect",
+			NULL, NULL, p2p_disconnect) },
+	{ GDBUS_METHOD("Invite",
+			GDBUS_ARGS({ "service_path", "s" }),
+			NULL, p2p_invite) },
+	{ GDBUS_METHOD("GetPeers",
+			NULL, GDBUS_ARGS({ "peers", "a(oa{sv})" }),
+			get_peers) },
+	{},
+};
+
+static const GDBusSignalTable group_signals[] = {
+	{ GDBUS_SIGNAL("PropertyChanged",
+			GDBUS_ARGS({ "name", "s" }, { "value", "v" })) },
+	{ GDBUS_SIGNAL("PeerAdded",
+			GDBUS_ARGS({ "path", "o" })) },
+	{ GDBUS_SIGNAL("PeerRemoved",
+			GDBUS_ARGS({ "path", "o" })) },
+	{ },
+};
+
+const char* __connman_group_get_path(struct connman_group *group)
+{
+	if (group)
+		return group->path;
+
+	return NULL;
+}
+
+const char* __connman_group_get_identifier(struct connman_group *group)
+{
+	return group->identifier;
+}
+
+const char* __connman_group_get_group_owner(struct connman_group *group)
+{
+	if (group)
+		return group->group_owner;
+
+	return NULL;
+}
+
+int  __connman_group_get_list_length(struct connman_group *group)
+{
+	int length = 0;
+
+	if (group->peer_list == NULL)
+		return 0;
+
+	length = g_slist_length(group->peer_list);
+
+	return length;
+}
+
+bool __connman_group_is_autonomous(struct connman_group *group)
+{
+		return group->autonomous;
+}
+
+bool __connman_group_exist(void)
+{
+	if(!group_list || !group_list->data)
+		return false;
+
+	return true;
+}
+
+int __connman_group_accept_connection(struct connman_group *group, GSupplicantP2PWPSParams *wps_params)
+{
+	if(group == NULL)
+		return -1;
+
+	if(group->path == NULL)
+		return -1;
+
+	return g_supplicant_interface_p2p_wps_start(group->interface, wps_params, NULL, NULL);
+}
+
+void __connman_group_peer_failed(struct connman_group *group)
+{
+	g_supplicant_interface_p2p_group_disconnect(group->interface, NULL, NULL);
+}
+
+struct connman_group *__connman_group_lookup_from_ident(const char *identifier)
+{
+	return group_get(identifier);
+}
+
+static void append_dict_properties(DBusMessageIter *dict, void *user_data)
+{
+	struct connman_group *group = user_data;
+
+	append_properties(dict, group);
+}
+
+static void append_struct_group(DBusMessageIter *iter,
+		connman_dbus_append_cb_t function,
+		struct connman_group *group)
+{
+	DBusMessageIter entry, dict;
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_OBJECT_PATH,
+							&group->path);
+
+	connman_dbus_dict_open(&entry, &dict);
+	if (function)
+		function(&dict, group);
+	connman_dbus_dict_close(&entry, &dict);
+
+	dbus_message_iter_close_container(iter, &entry);
+}
+
+static void append_struct(gpointer value, gpointer user_data)
+{
+	struct connman_group *group = value;
+	DBusMessageIter *iter = user_data;
+
+	if (!group->path)
+		return;
+
+	append_struct_group(iter, append_dict_properties, group);
+}
+
+void __connman_group_list_struct(DBusMessageIter *iter)
+{
+	g_list_foreach(group_list, append_struct, iter);
+}
+
+static int group_register(struct connman_group *group)
+{
+	DBG("group %p", group);
+
+	if (group->path != NULL)
+		return -EALREADY;
+
+	group->path = g_strdup_printf("%s/group/%s", CONNMAN_PATH,
+						group->identifier);
+
+	DBG("path %s", group->path);
+
+	g_dbus_register_interface(connection, group->path,
+								CONNMAN_GROUP_INTERFACE,
+								group_methods, group_signals,
+								NULL, group, NULL);
+
+	__connman_p2p_set_dhcp_pool(NULL);
+	group_added_signal(group);
+
+	return 0;
+}
+
+static void interface_create_callback(int result,
+					GSupplicantInterface *interface,
+							void *user_data)
+{
+	struct connman_group *group = user_data;
+
+	DBG("result %d ifname %s", result,
+				g_supplicant_interface_get_ifname(interface));
+
+	group->interface = interface;
+}
+
+void __connman_group_client_dhcp_ip_assigned(struct connman_group *group)
+{
+	dbus_bool_t dhcp_address = TRUE;
+
+	connman_dbus_property_changed_basic(group->path,
+			CONNMAN_GROUP_INTERFACE, "DHCPAddress", DBUS_TYPE_BOOLEAN,
+			&dhcp_address);
+}
+struct connman_group* __connman_group_create(GSupplicantInterface *iface, const char *ifname, const char *ssid, const char *passphrase,
+											bool go, bool persistent, const char *go_path, bool autonomous, int freq)
+{
+	struct connman_group *group;
+	char *ident;
+	int ssid_len = strlen(ssid);
+	GString *name = g_string_sized_new(ssid_len * 2 + 1);
+	int i=0;
+	int ret=0;
+
+	DBG("ssid : %s, len : %d\n", ssid, ssid_len);
+
+	for(i=0; i<ssid_len; i++) {
+		g_string_append_printf(name, "%02x", ssid[i]);
+	}
+
+	ident = g_string_free(name, FALSE);
+
+	DBG("ident : %s\n", ident);
+
+	group = group_get(ident);
+
+	g_free(ident);
+	ident = NULL;
+	if (!group)
+		return NULL;
+
+	group->name = g_strdup(ssid);
+	group->is_group_owner = go;
+	if (go) {
+		group->passphrase = g_strdup(passphrase);
+	}
+	group->is_persistent = persistent;
+	group->group_owner = go_path;
+	group->autonomous = autonomous;
+	group->freq = freq;
+	group->is_static_ip = false;
+	group->orig_interface = iface;
+
+	DBG("go path : %s\n", go_path);
+
+	ret = group_register(group);
+
+	if (ret == 0) {
+		g_supplicant_interface_create(ifname, "nl80211", NULL, NULL, interface_create_callback, group);
+	}
+
+	return group;
+}
+
+void __connman_group_remove(GSupplicantInterface *interface)
+{
+	GList *list;
+	struct connman_group *group = NULL;
+
+	if(!group_list)
+		return;
+
+	for (list = group_list; list != NULL; list = list->next) {
+		group = list->data;
+
+		if (group->interface == interface) {
+			break;
+		}
+	}
+
+	if (group) {
+		DBG("group removed\n");
+
+		if(!connection)
+			connection = connman_dbus_get_connection();
+
+		DBG("group path : %s\n", group->path);
+		__connman_p2p_set_dhcp_pool(NULL);
+
+		if (group->path && strncmp(group->path, CONNMAN_PATH, strlen(CONNMAN_PATH)) == 0) {
+			group_removed_signal(group);
+			g_dbus_unregister_interface(connection, group->path, CONNMAN_GROUP_INTERFACE);
+		}
+		g_hash_table_remove(group_hash, group->identifier);
+		group_list = g_list_remove(group_list, group);
+
+		g_hash_table_destroy(group->peer_hash);
+		g_hash_table_destroy(group->peer_intf);
+
+		g_free(group->path);
+		g_free(group->passphrase);
+		g_free(group->peer_ip);
+		g_free(group->identifier);
+		g_free(group->name);
+		g_free(group);
+		group = NULL;
+	}
+}
+
+void __connman_group_peer_joined(struct connman_group *group, const char *_peer_ident, char *intf_addr, const char *peer_path)
+{
+	const char *not_p2p_peer = "/";
+	const char *sig = "pbc";
+
+	DBG("group: %s, peer: %s peer_path: %s \n", group->name, _peer_ident, peer_path);
+
+	//Peer list will be the owner.
+	char* peer_ident = g_strdup(_peer_ident);
+
+	if (peer_path) {
+		g_hash_table_replace(group->peer_hash, peer_ident, g_strdup(peer_path));
+		if(intf_addr != NULL && g_str_equal(peer_ident, intf_addr) == FALSE)
+			g_hash_table_replace(group->peer_intf, peer_ident, intf_addr);
+	} else {
+		g_hash_table_replace(group->peer_hash, peer_ident, g_strdup(not_p2p_peer));
+	}
+
+	group->peer_list = g_slist_prepend(group->peer_list, peer_ident);
+
+	if (peer_path) {
+		g_dbus_emit_signal(connection, group->path, CONNMAN_GROUP_INTERFACE, "PeerAdded",
+						DBUS_TYPE_OBJECT_PATH, &peer_path,
+						DBUS_TYPE_INVALID);
+		connman_dbus_property_changed_basic(peer_path, CONNMAN_PEER_INTERFACE,
+						"PeerAdded", DBUS_TYPE_STRING, &sig);
+	}
+}
+
+bool __connman_group_peer_disconnected(struct connman_group *group, char *peer_ident)
+{
+	char *peer_path = NULL;
+	GSList* item;
+
+	DBG("group %s\n", group->name);
+
+	if (group->peer_hash)
+		peer_path = g_hash_table_lookup(group->peer_hash, peer_ident);
+
+	item = g_slist_find_custom(group->peer_list, peer_ident, (GCompareFunc)g_strcmp0);
+
+	if (!item)
+	{
+		DBG("Internal error - Peer not found in list %s\n", peer_ident);
+		return false;
+	}
+
+	if (peer_path && peer_ident) {
+		g_hash_table_remove(group->peer_hash, peer_ident);
+	}
+	g_hash_table_remove(group->peer_intf, peer_ident);
+	g_free(item->data);
+	group->peer_list = g_slist_delete_link(group->peer_list, item);
+
+	if(peer_path) {
+		g_dbus_emit_signal(connection, group->path,
+						CONNMAN_GROUP_INTERFACE, "PeerRemoved",
+						DBUS_TYPE_OBJECT_PATH, &peer_path,
+						DBUS_TYPE_INVALID);
+
+		g_free(peer_path);
+	}
+
+	if(group->autonomous == false && group->peer_list == NULL)
+		if (-EINPROGRESS == g_supplicant_interface_p2p_group_disconnect(group->interface, NULL, NULL))
+			return true;
+
+	return true;
+}
+
+void __connman_group_init(void)
+{
+	connection = connman_dbus_get_connection();
+
+	if (group_hash != NULL){
+		__connman_group_cleanup();
+	}
+
+	group_hash = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+}
+
+void __connman_group_cleanup(void)
+{
+	GList *list;
+
+	if (!group_list){
+		if (group_hash != NULL){
+			g_hash_table_destroy(group_hash);
+			group_hash = NULL;
+		}
+		return;
+	}
+
+	for (list = group_list; list != NULL; list = list->next) {
+
+		struct connman_group *group = list->data;
+
+		/*
+		 * Checking if group->path == null is added to prevent connman crash [NCVTDEFFECT-2085]).
+		 * You can check original code review in http://wall.lge.com:8110/#/c/80192/.
+		 * For network module migration from drd4tv to emo, this patch will be taken as it is.
+		 * For further investigation, PLAT-16133 is created for to find a better solution
+		 * other than checking null.
+		 */
+
+		if (group && group->path && strstr(group->path, "group") != NULL) {
+			group_removed_signal(group);
+
+			if (group->interface) {
+				g_supplicant_interface_p2p_group_disconnect(group->interface, NULL, NULL);
+				g_dbus_unregister_interface(connection, group->path, CONNMAN_GROUP_INTERFACE);
+			}
+		}
+	}
+
+	list = group_list;
+	group_list = NULL;
+	g_list_free (list);
+
+	g_hash_table_destroy(group_hash);
+	group_hash = NULL;
+}
diff --git a/src/ippool.c b/src/ippool.c
index f2e9b000..f3fd094e 100644
--- a/src/ippool.c
+++ b/src/ippool.c
@@ -42,6 +42,8 @@ struct address_info {
 };
 
 struct connman_ippool {
+	unsigned int refcount;
+
 	struct address_info *info;
 
 	char *gateway;
@@ -62,8 +64,47 @@ static uint32_t block_20_bits;
 static uint32_t block_24_bits;
 static uint32_t subnet_mask_24;
 
+struct connman_ippool *
+__connman_ippool_ref_debug(struct connman_ippool *pool,
+				const char *file, int line, const char *caller)
+{
+	DBG("%p ref %d by %s:%d:%s()", pool, pool->refcount + 1,
+		file, line, caller);
+
+	__sync_fetch_and_add(&pool->refcount, 1);
+
+	return pool;
+}
+
+void __connman_ippool_unref_debug(struct connman_ippool *pool,
+				const char *file, int line, const char *caller)
+{
+	if (!pool)
+		return;
+
+	DBG("%p ref %d by %s:%d:%s()", pool, pool->refcount - 1,
+		file, line, caller);
+
+	if (__sync_fetch_and_sub(&pool->refcount, 1) != 1)
+		return;
+
+	if (pool->info) {
+		allocated_blocks = g_slist_remove(allocated_blocks, pool->info);
+		g_free(pool->info);
+	}
+
+	g_free(pool->gateway);
+	g_free(pool->broadcast);
+	g_free(pool->start_ip);
+	g_free(pool->end_ip);
+	g_free(pool->subnet_mask);
+
+	g_free(pool);
+}
+
 void __connman_ippool_free(struct connman_ippool *pool)
 {
+
 	if (!pool)
 		return;
 
@@ -79,6 +120,7 @@ void __connman_ippool_free(struct connman_ippool *pool)
 	g_free(pool->subnet_mask);
 
 	g_free(pool);
+
 }
 
 static char *get_ip(uint32_t ip)
@@ -326,10 +368,20 @@ struct connman_ippool *__connman_ippool_create(int index,
 					unsigned int range,
 					ippool_collision_cb_t collision_cb,
 					void *user_data)
+{
+	return __connman_ippool_create_with_block(index, start, range, 0, collision_cb, user_data);
+}
+
+
+struct connman_ippool *__connman_ippool_create_with_block(int index,
+					unsigned int start,
+					unsigned int range,
+					uint32_t block,
+					ippool_collision_cb_t collision_cb,
+					void *user_data)
 {
 	struct connman_ippool *pool;
 	struct address_info *info;
-	uint32_t block;
 
 	DBG("");
 
@@ -341,12 +393,13 @@ struct connman_ippool *__connman_ippool_create(int index,
 		connman_error("IP pool does not support pool size larger than 254");
 		return NULL;
 	}
-
-	block = get_free_block(start + range);
-	if (block == 0) {
-		connman_warn("Could not find a free IP block");
-		return NULL;
-	}
+    if(block == 0) {
+		block = get_free_block(start + range);
+		if (block == 0) {
+			connman_warn("Could not find a free IP block");
+			return NULL;
+		}
+    }
 
 	pool = g_try_new0(struct connman_ippool, 1);
 	if (!pool)
@@ -364,6 +417,7 @@ struct connman_ippool *__connman_ippool_create(int index,
 	info->start = block;
 	info->end = block + range;
 
+	pool->refcount = 1;
 	pool->info = info;
 	pool->collision_cb = collision_cb;
 	pool->user_data = user_data;
diff --git a/src/manager.c b/src/manager.c
index 2aacee37..0c424598 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -30,6 +30,7 @@
 #include <connman/agent.h>
 
 #include "connman.h"
+#include "include/group.h"
 
 static bool connman_state_idle;
 static dbus_bool_t sessionmode;
@@ -449,7 +450,8 @@ static int parse_peers_service_specs(DBusMessageIter *array,
 							query, query_len);
 		} else if (!g_strcmp0(key, "UpnpService")) {
 			dbus_message_iter_get_basic(&inter, spec);
-			*spec_len = strlen((const char *)*spec)+1;
+			if (*spec)
+				*spec_len = strlen((const char *)*spec)+1;
 		} else if (!g_strcmp0(key, "UpnpVersion")) {
 			dbus_message_iter_get_basic(&inter, version);
 		} else if (!g_strcmp0(key, "WiFiDisplayIEs")) {
@@ -500,10 +502,8 @@ static DBusMessage *register_peer_service(DBusConnection *conn,
 
 	ret = __connman_peer_service_register(owner, msg, spec, spec_len,
 					query, query_len, version,master);
-	if (!ret)
+	if (!ret || ret == -EINPROGRESS)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-	if (ret == -EINPROGRESS)
-		return NULL;
 error:
 	return __connman_error_failed(msg, -ret);
 }
@@ -539,6 +539,64 @@ error:
 
 }
 
+static DBusMessage *create_group(DBusConnection *conn,
+		DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter;
+	const char *identifier, *passphrase;
+	int err;
+
+	DBG("");
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+				return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &identifier);
+
+	if (strlen(identifier) > (P2P_MAX_SSID - P2P_WILDCARD_SSID_LEN))
+			return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &passphrase);
+
+	if ((strlen(passphrase) > 1 && strlen(passphrase) < 8) || strlen(passphrase) > 63)
+			return __connman_error_passphrase_required(msg);
+
+	err = __connman_technology_set_p2p_go(msg, identifier, passphrase);
+
+	if (err < 0)
+			return __connman_error_failed(msg, -err);
+
+	return NULL;
+}
+
+static void append_group_structs(DBusMessageIter *iter, void *user_data)
+{
+	__connman_group_list_struct(iter);
+}
+
+static DBusMessage *get_groups(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(msg);
+	if (!reply)
+		return NULL;
+
+	__connman_dbus_append_objpath_dict_array(reply,
+			append_group_structs, NULL);
+
+	return reply;
+}
+
 static const GDBusMethodTable manager_methods[] = {
 	{ GDBUS_METHOD("GetProperties",
 			NULL, GDBUS_ARGS({ "properties", "a{sv}" }),
@@ -604,6 +662,13 @@ static const GDBusMethodTable manager_methods[] = {
 	{ GDBUS_METHOD("UnregisterPeerService",
 			GDBUS_ARGS({ "specification", "a{sv}" }), NULL,
 			unregister_peer_service) },
+	{ GDBUS_ASYNC_METHOD("CreateGroup",
+			GDBUS_ARGS({ "identifier", "s" },{ "passphrase", "s" }),
+			GDBUS_ARGS({ "path", "o" }),
+			create_group) },
+	{ GDBUS_METHOD("GetGroups",
+			NULL, GDBUS_ARGS({ "groups", "a(oa{sv})" }),
+			get_groups) },
 	{ },
 };
 
@@ -621,6 +686,11 @@ static const GDBusSignalTable manager_signals[] = {
 	{ GDBUS_SIGNAL("PeersChanged",
 			GDBUS_ARGS({ "changed", "a(oa{sv})" },
 					{ "removed", "ao" })) },
+	{ GDBUS_SIGNAL("GroupAdded",
+			GDBUS_ARGS({ "path", "o" },
+					{ "properties", "a{sv}" })) },
+	{ GDBUS_SIGNAL("GroupRemoved",
+			GDBUS_ARGS({ "path", "o"})) },
 	{ },
 };
 
diff --git a/src/network.c b/src/network.c
index 161e84e0..a66cffa3 100644
--- a/src/network.c
+++ b/src/network.c
@@ -87,6 +87,7 @@ struct connman_network {
 
 	bool connecting;
 	bool associating;
+	connman_bool_t p2p_network;
 
 	struct connman_device *device;
 
@@ -489,6 +490,8 @@ static void dhcp_callback(struct connman_ipconfig *ipconfig,
 			struct connman_network *network,
 			bool success, gpointer data)
 {
+	connman_info("DHCP success %d",success);
+
 	network->connecting = false;
 
 	if (success)
@@ -1565,6 +1568,15 @@ int connman_network_set_associating(struct connman_network *network,
 	return 0;
 }
 
+connman_bool_t connman_network_get_p2p_network(struct connman_network *network)
+{
+	return network->p2p_network;
+}
+
+void connman_network_set_p2p_network(struct connman_network *network, connman_bool_t is_p2p_network)
+{
+	network->p2p_network = is_p2p_network;
+}
 static void set_associate_error(struct connman_network *network)
 {
 	struct connman_service *service;
diff --git a/src/p2pgo.c b/src/p2pgo.c
new file mode 100644
index 00000000..e9d5f2d0
--- /dev/null
+++ b/src/p2pgo.c
@@ -0,0 +1,284 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2012  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2011	ProFUSION embedded systems
+ *  Copyright (C) 2013 LG Electronics, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <linux/sockios.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/if_tun.h>
+#include <linux/if_bridge.h>
+
+#include "connman.h"
+
+#include <gdhcp/gdhcp.h>
+
+#include <gdbus.h>
+
+#ifndef DBUS_TYPE_UNIX_FD
+#define DBUS_TYPE_UNIX_FD -1
+#endif
+
+#define BRIDGE_DNS		"8.8.8.8"
+#define DEFAULT_MTU		1500
+
+#define PRIVATE_NETWORK_PRIMARY_DNS		BRIDGE_DNS
+#define PRIVATE_NETWORK_SECONDARY_DNS		"8.8.4.4"
+
+#define P2P_DEFAULT_BLOCK		0xc0a83100 //192.168.49.x
+
+static GDHCPServer *tethering_dhcp_server = NULL;
+static struct connman_ippool *dhcp_ippool = NULL;
+
+static char* bridge_name;
+
+void __connman_p2p_go_set_bridge(char *bridge)
+{
+	bridge_name = g_strdup(bridge);
+}
+
+const char *__connman_p2p_go_get_bridge(void)
+{
+	return bridge_name;
+}
+
+static void dhcp_server_debug(const char *str, void *data)
+{
+	connman_info("%s: %s\n", (const char *) data, str);
+}
+
+static void dhcp_server_error(GDHCPServerError error)
+{
+	switch (error) {
+	case G_DHCP_SERVER_ERROR_NONE:
+		connman_error("OK");
+		break;
+	case G_DHCP_SERVER_ERROR_INTERFACE_UNAVAILABLE:
+		connman_error("Interface unavailable");
+		break;
+	case G_DHCP_SERVER_ERROR_INTERFACE_IN_USE:
+		connman_error("Interface in use");
+		break;
+	case G_DHCP_SERVER_ERROR_INTERFACE_DOWN:
+		connman_error("Interface down");
+		break;
+	case G_DHCP_SERVER_ERROR_NOMEM:
+		connman_error("No memory");
+		break;
+	case G_DHCP_SERVER_ERROR_INVALID_INDEX:
+		connman_error("Invalid index");
+		break;
+	case G_DHCP_SERVER_ERROR_INVALID_OPTION:
+		connman_error("Invalid option");
+		break;
+	case G_DHCP_SERVER_ERROR_IP_ADDRESS_INVALID:
+		connman_error("Invalid address");
+		break;
+	}
+}
+
+static GDHCPServer *dhcp_server_start(const char *bridge,
+				const char *router, const char* subnet,
+				const char *start_ip, const char *end_ip,
+				unsigned int lease_time, const char *dns)
+{
+	GDHCPServerError error;
+	GDHCPServer *dhcp_server;
+	int index;
+
+	DBG("");
+
+	index = connman_inet_ifindex(bridge);
+	if (index < 0)
+		return NULL;
+
+	dhcp_server = g_dhcp_server_new(G_DHCP_IPV4, index, &error);
+	if (!dhcp_server) {
+		dhcp_server_error(error);
+		return NULL;
+	}
+
+	g_dhcp_server_set_debug(dhcp_server, dhcp_server_debug, "DHCP server");
+
+	g_dhcp_server_set_lease_time(dhcp_server, lease_time);
+	g_dhcp_server_set_option(dhcp_server, G_DHCP_SUBNET, subnet);
+	g_dhcp_server_set_option(dhcp_server, G_DHCP_ROUTER, router);
+	g_dhcp_server_set_option(dhcp_server, G_DHCP_DNS_SERVER, dns);
+	g_dhcp_server_set_ip_range(dhcp_server, start_ip, end_ip);
+
+	g_dhcp_server_start(dhcp_server);
+
+	return dhcp_server;
+}
+
+static void dhcp_server_stop(GDHCPServer *server)
+{
+	if (!server)
+		return;
+
+	g_dhcp_server_unref(server);
+}
+
+int __connman_p2p_go_set_enabled(void)
+{
+	int index;
+	int err;
+	const char *gateway;
+	const char *broadcast;
+	const char *subnet_mask;
+	const char *start_ip;
+	const char *end_ip;
+	const char *dns;
+
+	index = connman_inet_ifindex(bridge_name);
+	connman_info("p2pgo.c :  index = %d",index);
+
+	dhcp_ippool = __connman_ippool_create_with_block(index, 2, 252,
+						P2P_DEFAULT_BLOCK, NULL, NULL);
+
+	if (!dhcp_ippool) {
+		connman_error("Fail to create IP pool");
+		__connman_bridge_remove(bridge_name);
+	}
+
+	gateway = __connman_ippool_get_gateway(dhcp_ippool);
+	broadcast = __connman_ippool_get_broadcast(dhcp_ippool);
+	subnet_mask = __connman_ippool_get_subnet_mask(dhcp_ippool);
+	start_ip = __connman_ippool_get_start_ip(dhcp_ippool);
+	end_ip = __connman_ippool_get_end_ip(dhcp_ippool);
+
+	err = __connman_bridge_enable(bridge_name, gateway,
+		connman_ipaddress_calc_netmask_len(subnet_mask), broadcast);
+	if (err < 0 && err != -EALREADY) {
+		__connman_ippool_unref(dhcp_ippool);
+		__connman_bridge_remove(bridge_name);
+	}
+
+	dns = gateway;
+	if (__connman_dnsproxy_add_listener(index) < 0) {
+		connman_error("Can't add listener %s to DNS proxy",
+								bridge_name);
+		dns = BRIDGE_DNS;
+	}
+
+	tethering_dhcp_server = dhcp_server_start(bridge_name,
+						gateway, subnet_mask,
+						start_ip, end_ip,
+						24 * 3600, dns);
+	if (tethering_dhcp_server == NULL) {
+		__connman_bridge_disable(bridge_name);
+		__connman_ippool_unref(dhcp_ippool);
+		__connman_bridge_remove(bridge_name);
+	}
+
+	DBG("p2p go dhcp started");
+	return 0;
+}
+
+void __connman_p2p_go_set_disabled(void)
+{
+	int index;
+
+	index = connman_inet_ifindex(bridge_name);
+	if (index < 0)
+		return;
+
+	__connman_dnsproxy_remove_listener(index);
+
+	__connman_nat_disable(bridge_name);
+
+	dhcp_server_stop(tethering_dhcp_server);
+
+	tethering_dhcp_server = NULL;
+
+	__connman_bridge_disable(bridge_name);
+
+	__connman_ippool_unref(dhcp_ippool);
+
+	__connman_bridge_remove(bridge_name);
+
+	DBG("p2p go stopped");
+}
+
+void __connman_p2p_go_tethering_set_enabled(void)
+{
+	unsigned char prefixlen;
+	const char *subnet_mask;
+	const char *start_ip;
+
+	subnet_mask = __connman_ippool_get_subnet_mask(dhcp_ippool);
+	start_ip = __connman_ippool_get_start_ip(dhcp_ippool);
+
+	prefixlen =
+		connman_ipaddress_calc_netmask_len(subnet_mask);
+	__connman_nat_enable(bridge_name, start_ip, prefixlen);
+}
+
+void __connman_p2p_go_tethering_set_disabled(void)
+{
+	__connman_nat_disable(bridge_name);
+}
+
+const char* __connman_p2p_group_get_local_ip(void)
+{
+	if(dhcp_ippool) {
+		const char *gateway = __connman_ippool_get_gateway(dhcp_ippool);
+		return gateway;
+	}
+
+	return NULL;
+}
+
+void __connman_dhcpserver_append_gateway(DBusMessageIter* iter)
+{
+	const char* local_address = __connman_p2p_group_get_local_ip();
+	if(local_address != NULL)
+		connman_dbus_dict_append_basic(iter, "LocalAddress", DBUS_TYPE_STRING, &local_address);
+}
+
+int __connman_p2p_go_init(void)
+{
+	DBG("");
+	return 0;
+}
+
+void __connman_p2p_set_dhcp_pool(struct connman_ippool *ippool)
+{
+	dhcp_ippool = ippool;
+}
+
+void __connman_p2p_go_cleanup(void)
+{
+	DBG("");
+}
diff --git a/src/peer.c b/src/peer.c
index 2102f119..83586cbc 100644
--- a/src/peer.c
+++ b/src/peer.c
@@ -33,12 +33,16 @@
 
 #include "connman.h"
 
+#define P2P_DEFAULT_BLOCK 0xc0a83100 //192.168.49.
+
+
 static DBusConnection *connection = NULL;
 
 static GHashTable *peers_table = NULL;
 
 static struct connman_peer_driver *peer_driver;
 
+typedef void (*GdhcpaddressclientCb) ();
 struct _peers_notify {
 	int id;
 	GHashTable *add;
@@ -64,10 +68,35 @@ struct connman_peer {
 	DBusMessage *pending;
 	bool registered;
 	bool connection_master;
+	bool is_groupOwner;
 	struct connman_ippool *ip_pool;
 	GDHCPServer *dhcp_server;
 	uint32_t lease_ip;
 	GSList *services;
+
+	const char *type;
+	const char *device_address;
+	unsigned char strength;
+	dbus_uint16_t config_methods;
+
+	char *static_ip;
+	char *dhcp_ip;
+	bool is_static_ip;
+	bool is_dhcp_ip;
+	char* pri_dev_type;
+	bool is_autonomous_group;
+	GdhcpaddressclientCb clientCb;
+};
+
+struct connman_peerrequest {
+	struct connman_peer *peer;
+	int dev_passwd_id;
+};
+
+struct connman_peer_invitation {
+	const char * peer_path;
+	const char * signal;
+	const char * go_dev_addr;
 };
 
 static void settings_changed(struct connman_peer *peer);
@@ -82,7 +111,7 @@ static void stop_dhcp_server(struct connman_peer *peer)
 	peer->dhcp_server = NULL;
 
 	if (peer->ip_pool)
-		__connman_ippool_free(peer->ip_pool);
+		__connman_ippool_unref(peer->ip_pool);
 	peer->ip_pool = NULL;
 	peer->lease_ip = 0;
 }
@@ -95,13 +124,30 @@ static void dhcp_server_debug(const char *str, void *data)
 static void lease_added(unsigned char *mac, uint32_t ip)
 {
 	GList *list, *start;
+	char *mac_no_colon = __connman_util_mac_binary_to_string_no_colon(mac);
+
+	if (!mac_no_colon){
+		connman_info("Failed to get mac");
+		return;
+	}
+
+	const char* identifier = g_supplicant_peer_identifier_from_intf_address(mac_no_colon);
+	g_free(mac_no_colon);
+
+	if (!identifier)
+		return;
 
 	start = list = g_hash_table_get_values(peers_table);
 	for (; list; list = list->next) {
 		struct connman_peer *temp = list->data;
 
-		if (!memcmp(temp->iface_address, mac, ETH_ALEN)) {
+		if (!g_strcmp0(temp->identifier, identifier)) {
 			temp->lease_ip = ip;
+			if (temp->is_static_ip) {
+				temp->is_static_ip = false;
+				if (temp->clientCb)
+					temp->clientCb();
+			}
 			settings_changed(temp);
 			break;
 		}
@@ -140,7 +186,8 @@ static int start_dhcp_server(struct connman_peer *peer)
 	else
 		index = connman_device_get_index(peer->device);
 
-	peer->ip_pool = __connman_ippool_create(index, 2, 1, NULL, NULL);
+	peer->ip_pool = __connman_ippool_create_with_block(index, 2, 252,
+						P2P_DEFAULT_BLOCK, NULL, NULL);
 	if (!peer->ip_pool)
 		goto error;
 
@@ -197,6 +244,7 @@ static void reply_pending(struct connman_peer *peer, int error)
 static void peer_free(gpointer data)
 {
 	struct connman_peer *peer = data;
+	DBG("");
 
 	reply_pending(peer, ENOENT);
 
@@ -208,6 +256,7 @@ static void peer_free(gpointer data)
 	}
 
 	if (peer->ipconfig) {
+		__connman_dhcp_stop(peer->ipconfig);
 		__connman_ipconfig_set_ops(peer->ipconfig, NULL);
 		__connman_ipconfig_set_data(peer->ipconfig, NULL);
 		__connman_ipconfig_unref(peer->ipconfig);
@@ -226,7 +275,7 @@ static void peer_free(gpointer data)
 
 	g_free(peer->identifier);
 	g_free(peer->name);
-
+	g_free(peer->device_address);
 	g_free(peer);
 }
 
@@ -252,6 +301,28 @@ static const char *state2string(enum connman_peer_state state)
 	return NULL;
 }
 
+
+ const char *connman_peer_wps_method2string(enum connman_peer_wps_method method)
+{
+	switch (method) {
+	case CONNMAN_PEER_WPS_UNKNOWN:
+		break;
+	case CONNMAN_PEER_WPS_PBC:
+		return "pbc";
+	case CONNMAN_PEER_WPS_PIN:
+		return "pin";
+	case CONNMAN_PEER_WPS_DISPLAY:
+		return "display";
+	case CONNMAN_PEER_WPS_KEYBOARD:
+		return "keypad";
+	case CONNMAN_PEER_WPS_P2PS:
+		return "p2ps";
+	}
+
+	return NULL;
+}
+
+
 static bool is_connecting(struct connman_peer *peer)
 {
 	if (peer->state == CONNMAN_PEER_STATE_ASSOCIATION ||
@@ -298,6 +369,10 @@ static void append_ipv4(DBusMessageIter *iter, void *user_data)
 
 		local = __connman_ippool_get_gateway(peer->ip_pool);
 		remote = trans;
+		if (peer->lease_ip == 0)
+			peer->is_dhcp_ip = false;
+		else
+			peer->is_dhcp_ip = true;
 	} else if (peer->ipconfig) {
 		local = __connman_ipconfig_get_local(peer->ipconfig);
 
@@ -305,15 +380,22 @@ static void append_ipv4(DBusMessageIter *iter, void *user_data)
 		if (!remote) {
 			remote = dhcp = __connman_dhcp_get_server_address(
 							peer->ipconfig);
-			if (!dhcp)
+			if (!dhcp || !__connman_dhcp_get_client_address(peer->ipconfig))
 				remote = "";
 		}
 	}
 
-	connman_dbus_dict_append_basic(iter, "Local",
+	if (local)
+		connman_dbus_dict_append_basic(iter, "Local",
 						DBUS_TYPE_STRING, &local);
-	connman_dbus_dict_append_basic(iter, "Remote",
+
+	if (remote)
+		connman_dbus_dict_append_basic(iter, "Remote",
 						DBUS_TYPE_STRING, &remote);
+
+	g_free(peer->dhcp_ip);
+	peer->dhcp_ip = g_strdup(remote);
+
 	if (dhcp)
 		g_free(dhcp);
 }
@@ -361,6 +443,27 @@ static void append_peer_services(DBusMessageIter *iter, void *user_data)
 	dbus_message_iter_close_container(iter, &container);
 }
 
+static void append_peer(DBusMessageIter *dict, void *user_data)
+{
+	dbus_bool_t val;
+	struct connman_peer *peer = user_data;
+
+	connman_dbus_dict_append_basic(dict, "DeviceAddress", DBUS_TYPE_STRING,
+					&peer->device_address);
+
+	val = peer->is_groupOwner;
+	connman_dbus_dict_append_basic(dict, "GroupOwner", DBUS_TYPE_BOOLEAN,
+					&val);
+
+	if (peer->config_methods)
+		connman_dbus_dict_append_basic(dict, "ConfigMethod", DBUS_TYPE_UINT16,
+					&peer->config_methods);
+
+	if (peer->pri_dev_type)
+		connman_dbus_dict_append_basic(dict, "DeviceType", DBUS_TYPE_STRING,
+					&peer->pri_dev_type);
+}
+
 static void append_properties(DBusMessageIter *iter, struct connman_peer *peer)
 {
 	const char *state = state2string(peer->state);
@@ -368,14 +471,30 @@ static void append_properties(DBusMessageIter *iter, struct connman_peer *peer)
 
 	connman_dbus_dict_open(iter, &dict);
 
+	connman_dbus_dict_append_basic(&dict, "Type",
+					DBUS_TYPE_STRING, &peer->type);
 	connman_dbus_dict_append_basic(&dict, "State",
 					DBUS_TYPE_STRING, &state);
 	connman_dbus_dict_append_basic(&dict, "Name",
 					DBUS_TYPE_STRING, &peer->name);
+	connman_dbus_dict_append_basic(&dict, "Strength",
+					DBUS_TYPE_BYTE, &peer->strength);
+	connman_dbus_dict_append_dict(&dict, "P2P", append_peer, peer);
+
 	connman_dbus_dict_append_dict(&dict, "IPv4", append_ipv4, peer);
 	connman_dbus_dict_append_array(&dict, "Services",
 					DBUS_TYPE_DICT_ENTRY,
 					append_peer_services, peer);
+
+	if (is_connected(peer)) {
+		if (peer->is_static_ip)
+			connman_dbus_dict_append_basic(&dict, "IPAddress",
+				DBUS_TYPE_STRING, &peer->static_ip);
+		else if (peer->is_dhcp_ip)
+			connman_dbus_dict_append_basic(&dict, "IPAddress",
+				DBUS_TYPE_STRING, &peer->dhcp_ip);
+	}
+
 	connman_dbus_dict_close(iter, &dict);
 }
 
@@ -488,8 +607,6 @@ static gboolean peer_send_changed(gpointer data)
 
 	DBG("");
 
-	peers_notify->id = 0;
-
 	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "PeersChanged");
 	if (!signal)
@@ -511,10 +628,7 @@ static gboolean peer_send_changed(gpointer data)
 
 static void peer_schedule_changed(void)
 {
-	if (peers_notify->id != 0)
-		return;
-
-	peers_notify->id = g_timeout_add(100, peer_send_changed, NULL);
+	peer_send_changed(NULL);
 }
 
 static void peer_added(struct connman_peer *peer)
@@ -606,9 +720,6 @@ static int peer_connect(struct connman_peer *peer)
 {
 	int err = -ENOTSUP;
 
-	if (is_connected(peer))
-		return -EISCONN;
-
 	if (peer_driver->connect)
 		err = peer_driver->connect(peer,
 					CONNMAN_PEER_WPS_UNKNOWN, NULL);
@@ -637,7 +748,29 @@ static int peer_disconnect(struct connman_peer *peer)
 		__connman_dhcp_stop(peer->ipconfig);
 
 	if (peer_driver->disconnect)
-		err = peer_driver->disconnect(peer);
+			err = peer_driver->disconnect(peer);
+
+	connman_peer_set_state(peer, CONNMAN_PEER_STATE_IDLE);
+
+	return err;
+}
+
+static int peer_reject(struct connman_peer *peer)
+{
+	int err = -ENOTSUP;
+
+	connman_agent_cancel(peer);
+	reply_pending(peer, ECONNABORTED);
+
+	connman_peer_set_state(peer, CONNMAN_PEER_STATE_DISCONNECT);
+
+	if (peer->connection_master)
+		stop_dhcp_server(peer);
+	else
+		__connman_dhcp_stop(peer->ipconfig);
+
+	if (peer_driver->reject)
+		err = peer_driver->reject(peer);
 
 	connman_peer_set_state(peer, CONNMAN_PEER_STATE_IDLE);
 
@@ -656,23 +789,27 @@ static DBusMessage *connect_peer(DBusConnection *conn,
 	if (peer->pending)
 		return __connman_error_in_progress(msg);
 
-	list = g_hash_table_get_values(peers_table);
-	start = list;
-	for (; list; list = list->next) {
-		struct connman_peer *temp = list->data;
-
-		if (temp == peer || temp->device != peer->device)
-			continue;
-
-		if (is_connecting(temp) || is_connected(temp)) {
-			if (peer_disconnect(temp) == -EINPROGRESS) {
-				g_list_free(start);
-				return __connman_error_in_progress(msg);
+	// Dont disconnect if already group is present,
+	// required to support connection with multiple Peers
+	if (!__connman_group_exist()) {
+		list = g_hash_table_get_values(peers_table);
+		start = list;
+		for (; list; list = list->next) {
+			struct connman_peer *temp = list->data;
+
+			if (temp == peer || temp->device != peer->device)
+				continue;
+
+			if (is_connecting(temp) || is_connected(temp)) {
+				if (peer_disconnect(temp) == -EINPROGRESS) {
+					g_list_free(start);
+					return __connman_error_in_progress(msg);
+				}
 			}
 		}
-	}
 
-	g_list_free(start);
+		g_list_free(start);
+	}
 
 	peer->pending = dbus_message_ref(msg);
 
@@ -705,6 +842,21 @@ static DBusMessage *disconnect_peer(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *reject_peer(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_peer *peer = user_data;
+	int err;
+
+	DBG("peer %p", peer);
+
+	err = peer_reject(peer);
+	if (err < 0 && err != -EINPROGRESS)
+		return __connman_error_failed(msg, -err);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 struct connman_peer *connman_peer_create(const char *identifier)
 {
 	struct connman_peer *peer;
@@ -714,6 +866,17 @@ struct connman_peer *connman_peer_create(const char *identifier)
 	peer->state = CONNMAN_PEER_STATE_IDLE;
 
 	peer->refcount = 1;
+	peer->type = "peer";
+	peer->device_address = __connman_util_insert_colon_to_mac_addr(identifier);
+	peer->is_static_ip = false;
+	peer->is_dhcp_ip = false;
+	peer->is_groupOwner = false;
+	peer->static_ip = NULL;
+	peer->dhcp_ip = g_strdup("");
+	peer->config_methods = 0;
+	peer->pri_dev_type = NULL;
+	peer->is_autonomous_group = false;
+	peer->clientCb = NULL;
 
 	return peer;
 }
@@ -754,8 +917,19 @@ const char *connman_peer_get_identifier(struct connman_peer *peer)
 
 void connman_peer_set_name(struct connman_peer *peer, const char *name)
 {
+	if (!peer || !name)
+		return;
+
 	g_free(peer->name);
-	peer->name = g_strdup(name);
+	peer->name = g_strdup(strlen(name) ? name : " ");
+}
+
+void connman_peer_dhcpclient_cb(struct connman_peer *peer,GdhcpaddressclientCb callback)
+{
+	if (!peer)
+		return;
+
+	peer->clientCb = callback;
 }
 
 void connman_peer_set_iface_address(struct connman_peer *peer,
@@ -775,6 +949,55 @@ void connman_peer_set_device(struct connman_peer *peer,
 	connman_device_ref(device);
 }
 
+void connman_peer_set_strength(struct connman_peer *peer,
+				unsigned char strength)
+{
+	if (!peer)
+		return;
+
+	peer->strength = strength;
+}
+
+void connman_peer_set_config_methods(struct connman_peer *peer,
+				dbus_uint16_t config_methods)
+{
+	if (!peer)
+		return;
+
+	peer->config_methods = config_methods;
+}
+
+void connman_peer_set_pri_dev_type(struct connman_peer *peer,
+				const char* pri_dev_type)
+{
+	if (!peer)
+		return;
+
+	peer->pri_dev_type = pri_dev_type;
+}
+
+int connman_peer_set_ipaddress(struct connman_peer *peer,
+				const char *address, const char *netmask, const char *gateway)
+{
+	if (!peer)
+		return -EINVAL;
+
+	DBG("");
+
+	__connman_ipconfig_set_method(peer->ipconfig, CONNMAN_IPCONFIG_METHOD_MANUAL);
+	__connman_ipconfig_set_local(peer->ipconfig, address);
+
+	unsigned char prefixlen = connman_ipaddress_calc_netmask_len(netmask);
+	if (prefixlen == 255)
+		connman_warn("netmask: %s is invalid", netmask);
+
+	__connman_ipconfig_set_prefixlen(peer->ipconfig, prefixlen);
+	__connman_ipconfig_set_gateway(peer->ipconfig, gateway);
+	__connman_ipconfig_set_dhcp_address(peer->ipconfig, address);
+
+	return 0;
+}
+
 struct connman_device *connman_peer_get_device(struct connman_peer *peer)
 {
 	if (!peer)
@@ -800,12 +1023,21 @@ void connman_peer_set_as_master(struct connman_peer *peer, bool master)
 	peer->connection_master = master;
 }
 
+void connman_peer_set_as_go(struct connman_peer *peer, bool go)
+{
+	if (!peer || !is_connecting(peer))
+		return;
+
+	peer->is_groupOwner = go;
+}
+
 static void dhcp_callback(struct connman_ipconfig *ipconfig,
 			struct connman_network *network,
 			bool success, gpointer data)
 {
 	struct connman_peer *peer = data;
 	int err;
+	const char *identifier = connman_peer_get_identifier(peer);
 
 	if (!success)
 		goto error;
@@ -816,6 +1048,7 @@ static void dhcp_callback(struct connman_ipconfig *ipconfig,
 	if (err < 0)
 		goto error;
 
+	//wfds_on_p2p_peer_dhcp_done(identifier, ipconfig);
 	return;
 
 error:
@@ -831,7 +1064,21 @@ static int start_dhcp_client(struct connman_peer *peer)
 
 	__connman_ipconfig_enable(peer->ipconfig);
 
-	return __connman_dhcp_start(peer->ipconfig, NULL, dhcp_callback, peer);
+	if (peer->is_static_ip) {
+		dhcp_callback(peer->ipconfig, NULL, true, peer);
+		return 0;
+	} else {
+		return __connman_dhcp_start(peer->ipconfig, NULL, dhcp_callback, peer);
+	}
+}
+
+static void stop_dhcp_client(struct connman_peer *peer)
+{
+	if (peer->is_static_ip) {
+		__connman_ipconfig_set_method(peer->ipconfig, CONNMAN_IPCONFIG_METHOD_DHCP);
+		__connman_ipconfig_address_remove(peer->ipconfig);
+	} else
+		__connman_dhcp_stop(peer->ipconfig);
 }
 
 static void report_error_cb(void *user_context, bool retry, void *user_data)
@@ -875,6 +1122,14 @@ static int manage_peer_error(struct connman_peer *peer)
 	return 0;
 }
 
+enum connman_peer_state connman_peer_get_state(struct connman_peer *peer)
+{
+	if (!peer)
+		return CONNMAN_PEER_STATE_UNKNOWN;
+
+	return peer->state;
+}
+
 int connman_peer_set_state(struct connman_peer *peer,
 					enum connman_peer_state new_state)
 {
@@ -898,8 +1153,12 @@ int connman_peer_set_state(struct connman_peer *peer,
 	case CONNMAN_PEER_STATE_ASSOCIATION:
 		break;
 	case CONNMAN_PEER_STATE_CONFIGURATION:
-		if (peer->connection_master)
+		if (peer->connection_master) {
+
 			err = start_dhcp_server(peer);
+			if (err >= 0 && !peer->is_autonomous_group)
+				__connman_p2p_set_dhcp_pool(peer->ip_pool);
+		}
 		else
 			err = start_dhcp_client(peer);
 		if (err < 0)
@@ -911,17 +1170,30 @@ int connman_peer_set_state(struct connman_peer *peer,
 		__connman_technology_set_connected(CONNMAN_SERVICE_TYPE_P2P, true);
 		break;
 	case CONNMAN_PEER_STATE_DISCONNECT:
-		if (peer->connection_master)
+		if (peer->connection_master) {
+			if (!peer->is_autonomous_group)
+				__connman_p2p_set_dhcp_pool(NULL);
 			stop_dhcp_server(peer);
-		else
-			__connman_dhcp_stop(peer->ipconfig);
+		} else
+			stop_dhcp_client(peer);
+
 		peer->connection_master = false;
+		peer->is_groupOwner = false;
 		peer->sub_device = NULL;
+		peer->is_autonomous_group = false;
+
+		g_free(peer->dhcp_ip);
+		peer->dhcp_ip = g_strdup("");
+		peer->is_dhcp_ip = false;
+
+		__connman_peer_set_static_ip(peer, NULL);
 		__connman_technology_set_connected(CONNMAN_SERVICE_TYPE_P2P, false);
 		break;
 	case CONNMAN_PEER_STATE_FAILURE:
-		if (manage_peer_error(peer) == 0)
+		if (manage_peer_error(peer) == 0) {
+			peer->state = new_state;
 			return 0;
+		}
 		break;
 	};
 
@@ -935,11 +1207,78 @@ int connman_peer_set_state(struct connman_peer *peer,
 	return 0;
 }
 
-int connman_peer_request_connection(struct connman_peer *peer)
+static void peer_state_cancelled(gpointer key, gpointer value,
+						gpointer user_data)
 {
-	return __connman_agent_request_peer_authorization(peer,
-					request_authorization_cb, false,
-					NULL, NULL);
+	struct connman_peer *peer = value;
+
+	if (peer && peer->state == CONNMAN_PEER_STATE_ASSOCIATION)
+		connman_peer_set_state(peer, CONNMAN_PEER_STATE_IDLE);
+}
+
+void connman_peer_state_change_by_cancelled(void)
+{
+	g_hash_table_foreach(peers_table, peer_state_cancelled, NULL);
+}
+
+static gboolean peer_request_changed(gpointer data)
+{
+	struct connman_peerrequest *peer_request = data;
+
+	struct connman_peer *peer = peer_request->peer;
+	int dev_passwd_id = peer_request->dev_passwd_id;
+
+	connman_dbus_property_changed_basic(peer->path,
+					 CONNMAN_PEER_INTERFACE, "P2PGONegRequested",
+					 DBUS_TYPE_INT32, &dev_passwd_id);
+
+	g_free(peer_request);
+
+	return FALSE;
+}
+
+static gboolean peer_invitation_changed(gpointer data)
+{
+	struct connman_peer_invitation *peer_invitation = data;
+	struct connman_peer *peer = g_hash_table_lookup(peers_table, peer_invitation->peer_path);
+
+	if (peer && peer->path && peer->registered) {
+		connman_dbus_property_changed_basic(peer->path,
+						 CONNMAN_PEER_INTERFACE, peer_invitation->signal,
+						 DBUS_TYPE_STRING, &peer_invitation->go_dev_addr);
+	}
+
+	g_free(peer_invitation->peer_path);
+	g_free(peer_invitation->signal);
+	g_free(peer_invitation->go_dev_addr);
+	g_free(peer_invitation);
+
+	return FALSE;
+}
+
+void connman_peer_request_connection(struct connman_peer *peer, int dev_passwd_id)
+{
+	struct connman_peerrequest *peer_request;
+
+	peer_request = g_malloc0(sizeof(struct connman_peerrequest));
+	peer_request->peer = peer;
+	peer_request->dev_passwd_id = dev_passwd_id;
+
+	g_timeout_add(100, peer_request_changed, peer_request);
+}
+
+void connman_peer_invitation_request(const char* peer_path,
+					const char* signal, const char* go_dev_addr)
+{
+	DBG("Sending %s", signal);
+
+	struct connman_peer_invitation *peer_invitation;
+	peer_invitation = g_malloc0(sizeof(struct connman_peer_invitation));
+	peer_invitation->peer_path = g_strdup(peer_path);
+	peer_invitation->signal = g_strdup(signal);
+	peer_invitation->go_dev_addr = g_strdup(go_dev_addr);
+
+	peer_invitation_changed(peer_invitation);
 }
 
 static void peer_service_free(gpointer data)
@@ -1072,6 +1411,7 @@ static const GDBusMethodTable peer_methods[] = {
 			get_peer_properties) },
 	{ GDBUS_ASYNC_METHOD("Connect", NULL, NULL, connect_peer) },
 	{ GDBUS_METHOD("Disconnect", NULL, NULL, disconnect_peer) },
+	{ GDBUS_METHOD("RejectPeer", NULL, NULL, reject_peer) },
 	{ },
 };
 
@@ -1127,6 +1467,8 @@ void connman_peer_unregister(struct connman_peer *peer)
 	connman_agent_cancel(peer);
 	reply_pending(peer, EIO);
 
+	DBG("path %s", peer->path);
+
 	g_dbus_unregister_interface(connection, peer->path,
 					CONNMAN_PEER_INTERFACE);
 	peer->registered = false;
@@ -1145,6 +1487,35 @@ struct connman_peer *connman_peer_get(struct connman_device *device,
 	return peer;
 }
 
+struct connman_peer *connman_peer_get_by_path(const char *path)
+{
+	struct connman_peer *peer;
+
+	peer = g_hash_table_lookup(peers_table, path);
+
+	return peer;
+}
+
+void connman_peer_get_local_address(gpointer user_data, DBusMessageIter *iter)
+{
+	struct connman_peer *peer = user_data;
+	const char *local = "";
+
+	if (peer->ipconfig) {
+		local = __connman_ipconfig_get_local(peer->ipconfig);
+
+		connman_dbus_dict_append_basic(iter, "LocalAddress",
+				DBUS_TYPE_STRING, &local);
+	}
+}
+
+void __connman_peer_get_properties_struct(DBusMessageIter *iter, gpointer user_data)
+{
+	struct connman_peer *peer = user_data;
+
+	append_properties(iter, peer);
+}
+
 int connman_peer_driver_register(struct connman_peer_driver *driver)
 {
 	if (peer_driver && peer_driver != driver)
@@ -1180,16 +1551,63 @@ const char *__connman_peer_get_path(struct connman_peer *peer)
 	return peer->path;
 }
 
-static void disconnect_peer_hash_table(gpointer key,
-					gpointer value, gpointer user_data)
+void __connman_peer_set_static_ip(struct connman_peer *peer, char* static_ip) {
+	if (!peer)
+		return;
+
+	if (static_ip) {
+		peer->is_static_ip = true;
+		peer->static_ip = g_strdup(static_ip);
+	} else {
+		peer->is_static_ip = false;
+		if(peer->static_ip) {
+			g_free(peer->static_ip);
+			peer->static_ip = NULL;
+		}
+	}
+}
+
+void __connman_peer_set_autonomous_group(struct connman_peer *peer, bool autonomous_group) {
+	if (!peer)
+		return;
+
+	peer->is_autonomous_group = autonomous_group;
+}
+
+struct connman_peer *__connman_get_connected_peer(void)
 {
-	struct connman_peer *peer = value;
-	peer_disconnect(peer);
+	GList *list, *start;
+
+	list = g_hash_table_get_values(peers_table);
+	start = list;
+	for (; list; list = list->next) {
+		struct connman_peer *peer = list->data;
+
+		if (peer->state == CONNMAN_PEER_STATE_READY) {
+			g_list_free(start);
+			return peer;
+		}
+	}
+	g_list_free(start);
+	return NULL;
 }
 
-void __connman_peer_disconnect_all(void)
+bool __connman_peer_get_connected_exists(void)
 {
-	g_hash_table_foreach(peers_table, disconnect_peer_hash_table, NULL);
+	GList *list, *start;
+
+	list = g_hash_table_get_values(peers_table);
+	start = list;
+	for (; list; list = list->next) {
+		struct connman_peer *peer = list->data;
+
+		if (peer->state == CONNMAN_PEER_STATE_READY) {
+			g_list_free(start);
+			return true;
+		}
+	}
+	g_list_free(start);
+	return false;
 }
 
 int __connman_peer_init(void)
diff --git a/src/peer_service.c b/src/peer_service.c
index a457bff7..c73863c8 100644
--- a/src/peer_service.c
+++ b/src/peer_service.c
@@ -228,6 +228,20 @@ static int register_peer_service(struct _peer_service *service)
 					service_registration_result, service);
 }
 
+static void unregister_all_services(gpointer key, gpointer value,
+						gpointer user_data)
+{
+	struct _peer_service_owner *ps_owner = value;
+	GList *list;
+
+	for (list = ps_owner->services; list; list = list->next) {
+		struct _peer_service *service = list->data;
+
+		if (service->registered)
+			remove_peer_service(service);
+	}
+}
+
 static void register_all_services(gpointer key, gpointer value,
 						gpointer user_data)
 {
@@ -244,11 +258,12 @@ static void register_all_services(gpointer key, gpointer value,
 
 void __connman_peer_service_set_driver(struct connman_peer_driver *driver)
 {
-	peer_driver = driver;
-	if (!peer_driver)
-		return;
+	if (!driver)
+		g_hash_table_foreach(owners_map, unregister_all_services, NULL);
 
-	g_hash_table_foreach(owners_map, register_all_services, NULL);
+	peer_driver = driver;
+	if (peer_driver)
+		g_hash_table_foreach(owners_map, register_all_services, NULL);
 }
 
 int __connman_peer_service_register(const char *owner, DBusMessage *msg,
diff --git a/src/sd.c b/src/sd.c
new file mode 100644
index 00000000..9be1bde8
--- /dev/null
+++ b/src/sd.c
@@ -0,0 +1,382 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2018-2021 LG Electronics, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <netdb.h>
+#include <gdbus.h>
+#include <ctype.h>
+
+#include "../include/sd.h"
+#include <gsupplicant/gsupplicant.h>
+
+#include "connman.h"
+
+static DBusConnection *connection = NULL;
+static DBusMessage *sd_msg = NULL;
+
+#define DISCOVER_SERVICE_FROM_ALL_PEERS "00:00:00:00:00:00"
+#define UPNP_SERVICE "upnp"
+#define BONJOUR_SERVICE "bonjour"
+
+struct connman_service_discovery {
+	GSupplicantInterface *interface;
+	char *peer_service_prefix;
+};
+
+static struct connman_service_discovery *sd = NULL;
+
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	DBusMessageIter iter, value;
+	const char *name;
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_VARIANT)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_recurse(&iter, &value);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	connman_dbus_dict_open(&array, &dict);
+	connman_dbus_dict_close(&array, &dict);
+
+	return reply;
+}
+
+static void request_device_discovery()
+{
+	__connman_device_request_scan(CONNMAN_SERVICE_TYPE_P2P);
+}
+
+static void request_discover_service_callback(int result, GSupplicantInterface *interface,
+								void *user_data, void* result_data)
+{
+	DBusMessage *reply;
+
+	if(sd_msg == NULL)
+		return;
+
+	if(result < 0) {
+		reply = __connman_error_failed(sd_msg, -result);
+		if(reply != NULL)
+			g_dbus_send_message(connection, reply);
+	} else
+		g_dbus_send_reply(connection, sd_msg,
+								DBUS_TYPE_INT32, &result,
+								DBUS_TYPE_INVALID);
+
+	dbus_message_unref(sd_msg);
+	sd_msg = NULL;
+}
+
+static DBusMessage *request_discover_upnp_service(DBusConnection *conn,
+								DBusMessage *msg, void *user_data)
+{
+	DBusMessageIter iter;
+	const char *address, *description;
+	dbus_int32_t version;
+	GSupplicantP2PSDParams *sd_params;
+	int err;
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &address);
+
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_INT32)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &version);
+
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &description);
+
+	sd_params = g_try_malloc0(sizeof(GSupplicantP2PSDParams));
+	if(sd_params == NULL)
+		return __connman_error_failed(msg, ENOMEM);
+
+	if(g_str_equal(address, DISCOVER_SERVICE_FROM_ALL_PEERS) == FALSE) {
+		const char *addr_no_colon;
+		GString *str_peer_ident = g_string_new(NULL);
+		char *peer_ident;
+		struct connman_service *service;
+		struct connman_network *network;
+		const char *path;
+
+		addr_no_colon = __connman_util_remove_colon_from_mac_addr(address);
+		if(addr_no_colon == NULL) {
+			g_string_free(str_peer_ident, TRUE);
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+                }
+
+		g_string_append_printf(str_peer_ident, "%s_%s", sd->peer_service_prefix, addr_no_colon);
+		g_free(addr_no_colon);
+
+		peer_ident = g_string_free(str_peer_ident, FALSE);
+
+		service = __connman_service_lookup_from_ident(peer_ident);
+		if(service == NULL) {
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+		}
+
+		network = __connman_service_get_network(service);
+		path = connman_network_get_string(network, "Path");
+		if(path == NULL) {
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+		}
+
+		sd_params->peer = g_strdup(path);
+	}
+	sd_params->service_type = UPNP_SERVICE;
+	sd_params->desc = g_strdup(description);
+	sd_params->version = version;
+
+	err = g_supplicant_interface_p2p_sd_request(sd->interface, sd_params,
+												request_discover_service_callback, NULL);
+
+	if(err == -EINPROGRESS) {
+		sd_msg = dbus_message_ref(msg);
+
+		request_device_discovery();
+	} else {
+		g_free(sd_params);
+		return __connman_error_failed(msg, -err);
+	}
+
+	return NULL;
+}
+
+static DBusMessage *request_discover_bonjour_service(DBusConnection *conn,
+								DBusMessage *msg, void *user_data)
+{
+	DBusMessageIter iter, iter_array;
+	const char *address;
+	unsigned char *query = NULL;
+	int len = 0;
+	GSupplicantP2PSDParams *sd_params;
+	int err;
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &address);
+
+	dbus_message_iter_next(&iter);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_recurse(&iter, &iter_array);
+
+	dbus_message_iter_get_fixed_array(&iter_array, &query, &len);
+
+	sd_params = g_try_malloc0(sizeof(GSupplicantP2PSDParams));
+	if(sd_params == NULL)
+		return __connman_error_failed(msg, ENOMEM);
+
+	if(g_str_equal(address, DISCOVER_SERVICE_FROM_ALL_PEERS) == FALSE) {
+		const char *addr_no_colon;
+		GString *str_peer_ident = g_string_new(NULL);
+		char *peer_ident;
+		struct connman_service *service;
+		struct connman_network *network;
+		const char *path;
+
+		addr_no_colon = __connman_util_remove_colon_from_mac_addr(address);
+		if(addr_no_colon == NULL) {
+			g_string_free(str_peer_ident, TRUE);
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+                }
+
+		g_string_append_printf(str_peer_ident, "%s_%s", sd->peer_service_prefix, addr_no_colon);
+		g_free(addr_no_colon);
+
+                peer_ident = g_string_free(str_peer_ident, FALSE);
+
+		service = __connman_service_lookup_from_ident(peer_ident);
+		if(service == NULL) {
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+		}
+
+		network = __connman_service_get_network(service);
+		path = connman_network_get_string(network, "Path");
+		if(path == NULL) {
+			g_free(sd_params);
+			return __connman_error_invalid_arguments(msg);
+		}
+
+		sd_params->peer = g_strdup(path);
+	}
+	sd_params->query = query;
+	sd_params->query_len = len;
+
+	err = g_supplicant_interface_p2p_sd_request(sd->interface, sd_params,
+												request_discover_service_callback, NULL);
+
+	if(err == -EINPROGRESS) {
+		sd_msg = dbus_message_ref(msg);
+
+		request_device_discovery();
+	} else {
+		g_free(sd_params);
+		return __connman_error_failed(msg, -err);
+	}
+
+	return NULL;
+}
+
+static const GDBusMethodTable sd_methods[] = {
+	{ GDBUS_DEPRECATED_METHOD("GetProperties",
+			NULL, GDBUS_ARGS({ "properties", "a{sv}" }),
+			get_properties) },
+	{ GDBUS_METHOD("SetProperty",
+			GDBUS_ARGS({ "name", "s" }, { "value", "v" }),
+			NULL, set_property) },
+	{ GDBUS_ASYNC_METHOD("RequestDiscoverUPnPService",
+			GDBUS_ARGS({ "address", "s" }, { "version", "i" }, { "description", "s" }),
+			GDBUS_ARGS({ "reference", "i" }),
+			request_discover_upnp_service) },
+	{ GDBUS_ASYNC_METHOD("RequestDiscoverBonjourService",
+			GDBUS_ARGS({ "address", "s" }, { "query", "ay" }),
+			GDBUS_ARGS({ "reference", "i" }),
+			request_discover_bonjour_service) },
+	{},
+};
+
+static const GDBusSignalTable sd_signals[] = {
+	{ GDBUS_SIGNAL("PropertyChanged",
+			GDBUS_ARGS({ "name", "s" }, { "value", "v" })) },
+	{ GDBUS_SIGNAL("DiscoveryResponse",
+			GDBUS_ARGS({ "address", "s" }, { "reference", "i" }, { "tlv", "ay" })) },
+	{ },
+};
+
+static void emit_sd_response(const char *dev_addr, int reference, unsigned char *tlv, int tlv_len)
+{
+	DBusMessage *signal;
+	DBusMessageIter iter, array;
+
+	signal = dbus_message_new_signal(CONNMAN_SD_PATH, CONNMAN_SD_INTERFACE, "DiscoveryResponse");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &iter);
+	dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &dev_addr);
+	dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &reference);
+	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE_AS_STRING, &array);
+	dbus_message_iter_append_fixed_array(&array, DBUS_TYPE_BYTE, &tlv, tlv_len);
+	dbus_message_iter_close_container(&iter, &array);
+
+	g_dbus_send_message(connection, signal);
+}
+
+void __connman_sd_response_from_p2p_peer(const char *peer_ident, int reference,
+								unsigned char *tlv, int tlv_len)
+{
+	const char *dev_addr;
+
+	dev_addr = __connman_util_insert_colon_to_mac_addr(peer_ident);
+
+	emit_sd_response(dev_addr, reference, tlv, tlv_len);
+	g_free(dev_addr);
+}
+
+void __connman_sd_init(GSupplicantInterface *interface, const char* dev_ident)
+{
+	connman_bool_t res;
+
+	connection = connman_dbus_get_connection();
+
+	sd = g_try_new0(struct connman_service_discovery, 1);
+	if(sd == NULL)
+		return;
+
+	res = g_dbus_register_interface(connection, CONNMAN_SD_PATH, CONNMAN_SD_INTERFACE,
+									sd_methods, sd_signals,
+									NULL, NULL, NULL);
+
+	if(res == FALSE) {
+		g_free(sd);
+		sd = NULL;
+		return;
+	}
+
+	sd->interface = interface;
+	sd->peer_service_prefix = g_strdup_printf("wifi_%s", dev_ident);
+}
+
+void __connman_sd_cleanup(void)
+{
+	if(connection != NULL)
+		g_dbus_unregister_interface(connection, "/", CONNMAN_SD_INTERFACE);
+
+	if(sd != NULL) {
+		g_free(sd->peer_service_prefix);
+		g_free(sd);
+		sd = NULL;
+	}
+}
diff --git a/src/service.c b/src/service.c
index a693d11f..6bdfdc93 100644
--- a/src/service.c
+++ b/src/service.c
@@ -7280,6 +7280,11 @@ struct connman_service *__connman_service_lookup_from_index(int index)
 	return NULL;
 }
 
+struct connman_service *__connman_service_lookup_from_ident(const char *identifier)
+{
+	return lookup_by_identifier(identifier);
+}
+
 const char *connman_service_get_identifier(struct connman_service *service)
 {
 	return service ? service->identifier : NULL;
diff --git a/src/storage.c b/src/storage.c
index 90f03ebc..7e6d6590 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -263,6 +263,14 @@ int __connman_storage_save_service(GKeyFile *keyfile, const char *service_id)
 	return ret;
 }
 
+static bool is_file_exists(const char *path)
+{
+    if (access(path, F_OK) == -1)
+        return false;
+
+    return true;
+}
+
 static bool remove_file(const char *service_id, const char *file)
 {
 	gchar *pathname;
@@ -273,7 +281,12 @@ static bool remove_file(const char *service_id, const char *file)
 		return false;
 
 	if (!g_file_test(pathname, G_FILE_TEST_EXISTS)) {
-		ret = true;
+		if (!is_file_exists(pathname)) {
+			ret = true;
+		} else {
+			unlink(pathname);
+			ret = true;
+		}
 	} else if (g_file_test(pathname, G_FILE_TEST_IS_REGULAR)) {
 		unlink(pathname);
 		ret = true;
@@ -452,3 +465,127 @@ gchar **__connman_storage_get_providers(void)
 
 	return providers;
 }
+
+gchar **__connman_storage_get_p2p_persistents(void)
+{
+	GSList *list = NULL;
+	int num = 0, i = 0;
+	struct dirent *d;
+	gchar *str;
+	DIR *dir;
+	struct stat buf;
+	int ret;
+	char **persistents;
+	GSList *iter;
+
+	dir = opendir(STORAGEDIR);
+	if (dir == NULL)
+		return NULL;
+
+	while ((d = readdir(dir))) {
+		if (strcmp(d->d_name, ".") == 0 ||
+				strcmp(d->d_name, "..") == 0 ||
+				strncmp(d->d_name, "p2p_persistent_", 15) != 0)
+			continue;
+
+		if (d->d_type == DT_DIR) {
+			str = g_strdup_printf("%s/%s/settings", STORAGEDIR,
+					d->d_name);
+			ret = stat(str, &buf);
+			g_free(str);
+			if (ret < 0)
+				continue;
+			list = g_slist_prepend(list, g_strdup(d->d_name));
+			num += 1;
+		}
+	}
+
+	closedir(dir);
+
+	persistents = g_try_new0(char *, num + 1);
+	for (iter = list; iter != NULL; iter = g_slist_next(iter)) {
+		if (persistents != NULL)
+			persistents[i] = iter->data;
+		else
+			g_free(iter->data);
+		i += 1;
+	}
+	g_slist_free(list);
+
+	return persistents;
+}
+
+int __connman_storage_get_p2p_persistents_count(void)
+{
+	int i;
+	int cnt = 0;
+	gchar **persistents;
+
+	persistents = __connman_storage_get_p2p_persistents();
+
+	for (i = 0; persistents && persistents[i]; i++) {
+		DBG("loop : %s\n", persistents[i]);
+
+		if (strncmp(persistents[i], "p2p_persistent_", 15) != 0)
+			continue;
+
+		cnt++;
+	}
+
+	if (persistents != NULL)
+		g_strfreev(persistents);
+
+	return cnt;
+}
+
+void __connman_storage_del_unlinked_file(void)
+{
+	struct dirent *d, *sub_d;
+	gchar *str, *path;
+	DIR *dir, *sub_dir;
+
+	dir = opendir(STORAGEDIR);
+	if (dir == NULL)
+		return;
+
+	while ((d = readdir(dir))) {
+
+		if (strcmp(d->d_name, ".") == 0 ||
+				strcmp(d->d_name, "..") == 0 ||
+				strncmp(d->d_name, "p2p_", 4) == 0)
+			continue;
+
+		if (d->d_type == DT_DIR) {
+			path = g_strdup_printf("%s/%s/", STORAGEDIR,d->d_name);
+			sub_dir = opendir(path);
+			if (sub_dir == NULL) {
+				g_free(path);
+				continue;
+			}
+
+			while ((sub_d = readdir(sub_dir))) {
+				if (strcmp(sub_d->d_name, ".") == 0 ||
+						strcmp(sub_d->d_name, "..") == 0) {
+					continue;
+				}
+
+				if (strncmp(sub_d->d_name, "settings.", 9) == 0) {
+					str = g_strdup_printf("%s/%s/%s", STORAGEDIR, d->d_name, sub_d->d_name);
+					unlink(str);
+					g_free(str);
+				}
+			}
+			g_free(path);
+			closedir(sub_dir);
+		}
+		else {
+			if (strncmp(d->d_name, "settings.", 9) == 0) {
+				str = g_strdup_printf("%s/%s", STORAGEDIR, d->d_name);
+				unlink(str);
+				g_free(str);
+			}
+		}
+	}
+
+	closedir(dir);
+}
diff --git a/src/technology.c b/src/technology.c
index 5bfc1c5f..aab672c8 100644
--- a/src/technology.c
+++ b/src/technology.c
@@ -69,6 +69,16 @@ struct connman_technology {
 	char *tethering_ipaddress;
 	unsigned int tethering_channel;
 
+	int period;
+	int interval;
+
+	bool enable_p2p_listen_persistent;	/* Save the tech p2p listen state by p2p/setstate API */
+	bool p2p_listen;
+	unsigned int p2p_listen_channel;
+
+	char *p2p_identifier;
+	bool p2p_persistent;
+
 	bool enable_persistent; /* Save the tech state */
 
 	GSList *driver_list;
@@ -89,6 +99,7 @@ static GSList *driver_list = NULL;
 
 static int technology_enabled(struct connman_technology *technology);
 static int technology_disabled(struct connman_technology *technology);
+static int set_p2p_enable(struct connman_technology *technology, bool status);
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
 {
@@ -161,12 +172,14 @@ static const char *get_name(enum connman_service_type type)
 static void technology_save(struct connman_technology *technology)
 {
 	GKeyFile *keyfile;
+	GError *error = NULL;
 	gchar *identifier;
 	const char *name = get_name(technology->type);
 
 	DBG("technology %p type %d name %s", technology, technology->type,
 									name);
-	if (!name)
+
+	if (!name || (technology->type == CONNMAN_SERVICE_TYPE_P2P))
 		return;
 
 	keyfile = __connman_storage_load_global();
@@ -177,8 +190,27 @@ static void technology_save(struct connman_technology *technology)
 	if (!identifier)
 		goto done;
 
-	g_key_file_set_boolean(keyfile, identifier, "Enable",
-				technology->enable_persistent);
+	if (technology->type == CONNMAN_SERVICE_TYPE_P2P) {
+			g_key_file_set_boolean(keyfile, "WiFi", "P2PListen",
+						technology->enable_p2p_listen_persistent);
+		goto done;
+	}
+
+	// Update only if a WiFi Enable key is present and new value is ture
+	if (technology->type == CONNMAN_SERVICE_TYPE_WIFI) {
+		g_key_file_get_boolean(keyfile, identifier, "Enable", &error);
+		if (error == NULL) {
+			g_key_file_set_boolean(keyfile, identifier, "Enable",
+						technology->enable_persistent);
+		} else if (error && technology->enable_persistent) {
+			g_key_file_set_boolean(keyfile, identifier, "Enable",
+						technology->enable_persistent);
+			g_clear_error(&error);
+		}
+	} else {
+		g_key_file_set_boolean(keyfile, identifier, "Enable",
+					technology->enable_persistent);
+	}
 
 	g_key_file_set_boolean(keyfile, identifier, "Tethering",
 				technology->tethering_persistent);
@@ -426,11 +458,15 @@ static void technology_load(struct connman_technology *technology)
 	keyfile = __connman_storage_load_global();
 	/* Fallback on disabling technology if file not found. */
 	if (!keyfile) {
-		if (technology->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		if (technology->type == CONNMAN_SERVICE_TYPE_ETHERNET || technology->type == CONNMAN_SERVICE_TYPE_WIFI)
 			/* We enable ethernet by default */
 			technology->enable_persistent = true;
 		else
 			technology->enable_persistent = false;
+
+		if (technology->type == CONNMAN_SERVICE_TYPE_P2P)
+			technology->enable_p2p_listen_persistent = true;
+
 		return;
 	}
 
@@ -449,6 +485,15 @@ static void technology_load(struct connman_technology *technology)
 
 		need_saving = true;
 		g_clear_error(&error);
+			if (technology->type == CONNMAN_SERVICE_TYPE_P2P) {
+				enable = g_key_file_get_boolean(keyfile, "WiFi", "P2PListen", &error);
+				if (!error)
+					technology->enable_p2p_listen_persistent = enable;
+				else {
+					technology->enable_p2p_listen_persistent = true;
+					g_clear_error(&error);
+				}
+			}
 	}
 
 	enable = g_key_file_get_boolean(keyfile, identifier,
@@ -569,6 +614,20 @@ void connman_technology_interface_changed(struct connman_technology *technology)
 	interface_changed(technology);
 }
 
+static void append_p2plistenparams(DBusMessageIter *iter, void *user_data)
+{
+	struct connman_technology *technology = user_data;
+
+	if (!technology)
+		return;
+
+	connman_dbus_dict_append_basic(iter, "Period",
+					DBUS_TYPE_INT32, &technology->period);
+
+	connman_dbus_dict_append_basic(iter, "Interval",
+					DBUS_TYPE_INT32, &technology->interval);
+}
+
 static void append_properties(DBusMessageIter *iter,
 		struct connman_technology *technology)
 {
@@ -629,6 +688,28 @@ static void append_properties(DBusMessageIter *iter,
 					DBUS_TYPE_UINT32,
 					&technology->tethering_channel);
 
+	if(technology->p2p_identifier)
+		connman_dbus_dict_append_basic(&dict, "P2PIdentifier",
+					DBUS_TYPE_STRING,
+					&technology->p2p_identifier);
+
+	val = technology->p2p_persistent;
+	connman_dbus_dict_append_basic(&dict, "P2PPersistent",
+					DBUS_TYPE_BOOLEAN,
+					&val);
+
+	connman_dbus_dict_append_dict(&dict, "P2PListenParams",
+					append_p2plistenparams, technology);
+
+	connman_dbus_dict_append_basic(&dict, "P2PListenChannel",
+					DBUS_TYPE_UINT32,
+					&technology->p2p_listen_channel);
+
+	val = technology->p2p_listen;
+	connman_dbus_dict_append_basic(&dict, "P2PListen",
+					DBUS_TYPE_BOOLEAN,
+					&val);
+
 	connman_dbus_dict_close(iter, &dict);
 }
 
@@ -790,16 +871,23 @@ static int technology_enabled(struct connman_technology *technology)
 	if (technology->enabled)
 		return -EALREADY;
 
-	technology->enabled = true;
-
+	struct connman_technology *p2p;
 	if (technology->type == CONNMAN_SERVICE_TYPE_WIFI) {
-		struct connman_technology *p2p;
 
 		p2p = technology_find(CONNMAN_SERVICE_TYPE_P2P);
-		if (p2p && !p2p->enabled && p2p->enable_persistent)
+		if (p2p && !p2p->enabled && p2p->enable_persistent){
 			technology_enabled(p2p);
+		}
+	}
+
+	if (technology->type == CONNMAN_SERVICE_TYPE_P2P) {
+		p2p = technology_find(CONNMAN_SERVICE_TYPE_P2P);
+		if (p2p){
+			(void)set_p2p_enable(p2p,true);
+		}
 	}
 
+	technology->enabled = true;
 	if (technology->tethering_persistent)
 		enable_tethering(technology);
 
@@ -853,6 +941,10 @@ static int technology_disabled(struct connman_technology *technology)
 	if (!technology->enabled)
 		return -EALREADY;
 
+	if (technology->type == CONNMAN_SERVICE_TYPE_P2P) {
+		(void)set_p2p_enable(technology,false);
+	}
+
 	technology->enabled = false;
 
 	powered_changed(technology);
@@ -871,7 +963,7 @@ static int technology_disable(struct connman_technology *technology)
 	if (technology->type == CONNMAN_SERVICE_TYPE_P2P) {
 		technology->enable_persistent = false;
 		__connman_device_stop_scan(CONNMAN_SERVICE_TYPE_P2P);
-		__connman_peer_disconnect_all();
+		//__connman_peer_disconnect_all();
 		return technology_disabled(technology);
 	} else if (technology->type == CONNMAN_SERVICE_TYPE_WIFI) {
 		struct connman_technology *p2p;
@@ -900,6 +992,51 @@ static int technology_disable(struct connman_technology *technology)
 	return err;
 }
 
+static int remove_persistent_info(struct connman_technology *technology,
+													const char *identifier)
+{
+	int result = -EOPNOTSUPP;
+	GSList *tech_drivers;
+
+	__sync_synchronize();
+	if (technology->enabled == FALSE)
+		return -EACCES;
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+		tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (driver == NULL || driver->remove_persistent_info == NULL)
+			continue;
+
+		result = driver->remove_persistent_info(technology, identifier);
+	}
+
+	return result;
+}
+
+static int remove_persistent_info_all(struct connman_technology *technology)
+{
+	int result = -EOPNOTSUPP;
+	GSList *tech_drivers;
+
+	__sync_synchronize();
+	if (technology->enabled == FALSE)
+		return -EACCES;
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+		tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (driver == NULL || driver->remove_persistent_info_all == NULL)
+			continue;
+
+		result = driver->remove_persistent_info_all(technology);
+	}
+
+	return result;
+}
+
 static DBusMessage *set_powered(struct connman_technology *technology,
 				DBusMessage *msg, bool powered)
 {
@@ -939,6 +1076,463 @@ make_reply:
 	return reply;
 }
 
+
+bool connman_technology_get_enable_p2p_listen(struct connman_technology *technology)
+{
+	return technology->enable_p2p_listen_persistent;
+}
+
+bool connman_technology_get_p2p_listen(struct connman_technology *technology)
+{
+	return technology->p2p_listen;
+}
+
+void connman_technology_set_p2p_listen(struct connman_technology *technology, bool enabled)
+{
+	dbus_bool_t listen_enabled;
+
+	if (enabled == technology->p2p_listen)
+		return;
+
+	technology->p2p_listen = enabled;
+	listen_enabled = enabled;
+
+	connman_dbus_property_changed_basic(technology->path,
+			CONNMAN_TECHNOLOGY_INTERFACE,
+			"P2PListen",
+			DBUS_TYPE_BOOLEAN,
+			&listen_enabled);
+}
+
+void __connman_technology_p2p_invitation_result(struct connman_technology *technology, int status)
+{
+	if(technology->type != CONNMAN_SERVICE_TYPE_P2P)
+		return;
+
+	connman_dbus_property_changed_basic(technology->path,
+			CONNMAN_TECHNOLOGY_INTERFACE, "P2PInvitationResult",
+			DBUS_TYPE_INT32, &status);
+}
+
+static DBusMessage *set_p2p_listen(struct connman_technology *technology,
+				DBusMessage *msg, bool enable)
+{
+	DBusMessage *reply = NULL;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+
+	__sync_synchronize();
+	if (!technology->enabled) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	if (technology->p2p_listen && enable)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	for (tech_drivers = technology->driver_list; tech_drivers;
+	     tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_listen)
+			continue;
+
+		err = driver->set_p2p_listen(technology, enable);
+		if (!err) {
+			technology->enable_p2p_listen_persistent = enable;
+			technology_save(technology);
+		}
+	}
+
+make_reply:
+	if (err == -EINPROGRESS)
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+	else if (err == -EALREADY) {
+		if (enable)
+			reply = __connman_error_already_enabled(msg);
+		else
+			reply = __connman_error_already_disabled(msg);
+	} else if (err < 0)
+		reply = __connman_error_failed(msg, -err);
+	else
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+void connman_technology_set_p2p_listen_params(struct connman_technology *technology,
+						int period, int interval)
+{
+	if (!technology)
+		return;
+
+	technology->period = period;
+	technology->interval = interval;
+}
+
+unsigned int connman_technology_get_p2p_listen_channel(struct connman_technology *technology)
+{
+	return technology->p2p_listen_channel;
+}
+
+void connman_technology_set_p2p_listen_channel(struct connman_technology *technology,
+						unsigned int listen_channel)
+{
+	if (!connman_technology_get_p2p_listen(technology))
+		return;
+
+	if (connman_technology_get_p2p_listen_channel(technology) != listen_channel)
+	{
+		technology->p2p_listen_channel = listen_channel;
+		connman_dbus_property_changed_basic(technology->path,
+				CONNMAN_TECHNOLOGY_INTERFACE,
+				"P2PListenChannel",
+				DBUS_TYPE_UINT32,
+				&technology->p2p_listen_channel);
+	}
+}
+
+bool connman_technology_get_p2p_persistent(struct connman_technology *technology)
+{
+	return technology->p2p_persistent;
+}
+
+void connman_technology_set_p2p_persistent(struct connman_technology *technology, bool enabled)
+{
+	GSList *tech_drivers;
+	int err = 0;
+	dbus_bool_t persistent_enabled;
+
+	if (technology->p2p_persistent == enabled)
+		return;
+
+	technology->p2p_persistent = enabled;
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+		tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_persistent)
+			continue;
+
+		err = driver->set_p2p_persistent(technology, enabled);
+		if (err < 0)
+			connman_error("Failed to set P2P persistent state");
+	}
+
+	persistent_enabled = technology->p2p_persistent;
+	connman_dbus_property_changed_basic(technology->path,
+			CONNMAN_TECHNOLOGY_INTERFACE,
+			"P2PPersistent",
+			DBUS_TYPE_BOOLEAN,
+			&persistent_enabled);
+}
+
+static DBusMessage *set_p2p_persistent(struct connman_technology *technology,
+													DBusMessage *msg, bool enabled)
+{
+	DBusMessage *reply = NULL;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+	dbus_bool_t persistent_enabled;
+
+	__sync_synchronize();
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P || !technology->enabled) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	if(technology->p2p_persistent == enabled)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	technology->p2p_persistent = enabled;
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+	     tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (driver == NULL || driver->set_p2p_persistent == NULL)
+			continue;
+
+		err = driver->set_p2p_persistent(technology, enabled);
+	}
+make_reply:
+	if (err < 0)
+		reply = __connman_error_failed(msg, -err);
+	else {
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+		persistent_enabled = technology->p2p_persistent;
+		connman_dbus_property_changed_basic(technology->path,
+				CONNMAN_TECHNOLOGY_INTERFACE,
+				"P2PPersistent",
+				DBUS_TYPE_BOOLEAN,
+				&persistent_enabled);
+	}
+
+	return reply;
+}
+
+void connman_technology_set_p2p_identifier(struct connman_technology *technology, const char *p2p_identifier)
+{
+
+	if (technology->p2p_identifier) {
+		g_free(technology->p2p_identifier);
+		technology->p2p_identifier = NULL;
+	}
+
+	if(p2p_identifier == NULL)
+		return;
+
+	technology->p2p_identifier = g_strdup(p2p_identifier);
+
+	connman_dbus_property_changed_basic(technology->path,
+			CONNMAN_TECHNOLOGY_INTERFACE,
+			"P2PIdentifier",
+			DBUS_TYPE_STRING,
+			&technology->p2p_identifier);
+}
+
+static int set_p2p_identifier(struct connman_technology *technology,
+											const char *p2p_identifier)
+{
+	int result = -EOPNOTSUPP;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+		return -EINVAL;
+
+	for (tech_drivers = technology->driver_list; tech_drivers;
+	     tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_identifier)
+			continue;
+
+		err = driver->set_p2p_identifier(technology, p2p_identifier);
+
+		if (result == -EINPROGRESS)
+			continue;
+
+		if (err == -EINPROGRESS || err == 0) {
+			result = err;
+			continue;
+		}
+	}
+
+	return result;
+}
+
+static DBusMessage *set_p2p_listen_params(struct connman_technology *technology,
+				DBusMessage *msg, DBusMessageIter *array)
+{
+	DBusMessage *reply = NULL;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+	int period = 0, interval = 0;
+	DBusMessageIter dict;
+
+	if (dbus_message_iter_get_arg_type(array) != DBUS_TYPE_ARRAY)
+		return NULL;
+
+	dbus_message_iter_recurse(array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+		int type;
+
+		dbus_message_iter_recurse(&dict, &entry);
+
+		if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_STRING)
+			return NULL;
+
+		dbus_message_iter_get_basic(&entry, &key);
+		dbus_message_iter_next(&entry);
+
+		if (dbus_message_iter_get_arg_type(&entry) != DBUS_TYPE_VARIANT)
+			return NULL;
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		type = dbus_message_iter_get_arg_type(&value);
+
+		if (g_str_equal(key, "Period")) {
+			if (type != DBUS_TYPE_INT32)
+				return NULL;
+
+			dbus_message_iter_get_basic(&value, &period);
+		} else if (g_str_equal(key, "Interval")) {
+			if (type != DBUS_TYPE_INT32)
+				return NULL;
+
+			dbus_message_iter_get_basic(&value, &interval);
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	for (tech_drivers = technology->driver_list; tech_drivers;
+			tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_listen_params)
+			continue;
+
+		err = driver->set_p2p_listen_params(technology, period, interval);
+
+		if (err == 0)
+			connman_technology_set_p2p_listen_params(technology, period, interval);
+	}
+
+	if (err < 0)
+		reply = __connman_error_failed(msg, -err);
+	else
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_p2p_listen_channel(struct connman_technology *technology,
+													DBusMessage *msg, unsigned int listen_channel)
+{
+	DBusMessage *reply = NULL;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+
+	__sync_synchronize();
+	if (!technology->enabled) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P) {
+		err = -EINVAL;
+		goto make_reply;
+	}
+
+	for (tech_drivers = technology->driver_list; tech_drivers;
+			tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver|| !driver->set_p2p_listen_channel)
+			continue;
+
+		err = driver->set_p2p_listen_channel(technology, listen_channel);
+
+		if (err == 0)
+			connman_technology_set_p2p_listen_channel(technology, listen_channel);
+	}
+make_reply:
+	if (err < 0)
+		reply = __connman_error_failed(msg, -err);
+	else
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_p2p_go_intent(struct connman_technology *technology,
+				   DBusMessage *msg, unsigned int go_intent)
+{
+	DBusMessage *reply = NULL;
+	int err = 0;
+	GSList *tech_drivers = NULL;
+
+	__sync_synchronize();
+	if (!technology->enabled) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P) {
+		err = -EOPNOTSUPP;
+		goto make_reply;
+	}
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+			tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_go_intent)
+			continue;
+
+		err = driver->set_p2p_go_intent(technology, go_intent);
+	}
+
+make_reply:
+	if (err < 0)
+		reply = __connman_error_failed(msg, -err);
+	else
+		reply = g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static int set_p2p_enable(struct connman_technology *technology,
+				 bool status)
+{
+	int err = 0;
+	GSList *tech_drivers = NULL;
+
+	__sync_synchronize();
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P) {
+		return -EOPNOTSUPP;
+	}
+
+
+	for (tech_drivers = technology->driver_list; tech_drivers != NULL;
+			tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_enable)
+			continue;
+
+		err = driver->set_p2p_enable(technology, status);
+		return err;
+	}
+
+	return err;
+}
+
+void connman_technology_set_p2p(struct connman_technology *technology, bool enabled)
+{
+	dbus_bool_t p2p_enabled;
+	DBG("Set p2p enable..enter");
+
+	if (!technology) {
+		DBG("Set p2p enable..tech null");
+		return;
+	}
+
+	if (enabled == technology->enabled)
+		return;
+
+	technology->enabled = enabled;
+	p2p_enabled = enabled;
+
+	powered_changed(technology);
+
+	connman_dbus_property_changed_basic(technology->path,
+		CONNMAN_TECHNOLOGY_INTERFACE,
+		"P2P",
+		DBUS_TYPE_BOOLEAN,
+		&p2p_enabled);
+}
+
+bool is_technology_enabled(struct connman_technology *technology)
+{
+	return technology == NULL ? false : technology->enabled;
+}
+
+
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -1101,6 +1695,74 @@ static DBusMessage *set_property(DBusConnection *conn,
 					DBUS_TYPE_STRING,
 					&technology->tethering_ipaddress);
 		}
+	} else if (g_str_equal(name, "P2PListen")) {
+		bool enable;
+
+		if (type != DBUS_TYPE_BOOLEAN)
+			return __connman_error_invalid_arguments(msg);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		dbus_message_iter_get_basic(&value, &enable);
+
+		return set_p2p_listen(technology, msg, enable);
+	} else if (g_str_equal(name, "P2PPersistent")) {
+		bool enable;
+
+		if (type != DBUS_TYPE_BOOLEAN)
+			return __connman_error_invalid_arguments(msg);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		dbus_message_iter_get_basic(&value, &enable);
+
+		return set_p2p_persistent(technology, msg, enable);
+	} else if (g_str_equal(name, "P2PIdentifier")) {
+		int err;
+		const char *p2p_identifier;
+
+		if (type != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
+		dbus_message_iter_get_basic(&value, &p2p_identifier);
+
+		if(strlen(p2p_identifier) > 32)
+			return __connman_error_invalid_arguments(msg);
+
+		err = set_p2p_identifier(technology, p2p_identifier);
+		if (err < 0)
+			return __connman_error_failed(msg, -err);
+	} else if (g_str_equal(name, "P2PListenParams")) {
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		return set_p2p_listen_params(technology, msg, &value);
+	} else if (g_str_equal(name, "P2PListenChannel")) {
+		dbus_uint32_t listen_channel;
+
+		if (type != DBUS_TYPE_UINT32)
+			return __connman_error_invalid_arguments(msg);
+
+		dbus_message_iter_get_basic(&value, &listen_channel);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		return set_p2p_listen_channel(technology, msg, listen_channel);
+	} else if (g_str_equal(name, "P2PGOIntent")) {
+		dbus_uint32_t go_intent;
+
+		if (type != DBUS_TYPE_UINT32)
+			return __connman_error_invalid_arguments(msg);
+
+		dbus_message_iter_get_basic(&value, &go_intent);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		return set_p2p_go_intent(technology, msg, go_intent);
 	} else if (g_str_equal(name, "Powered")) {
 		dbus_bool_t enable;
 
@@ -1110,6 +1772,24 @@ static DBusMessage *set_property(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &enable);
 
 		return set_powered(technology, msg, enable);
+	}	else if (g_str_equal(name, "RemovePersistentInfo") == TRUE) {
+		const char *identifier;
+		int res;
+
+		dbus_message_iter_get_basic(&value, &identifier);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_P2P)
+			return __connman_error_not_supported(msg);
+
+		if (!strncmp(identifier, "all", 3))
+			res = remove_persistent_info_all(technology);
+		else if (strlen(identifier) != 17)
+			return __connman_error_invalid_arguments(msg);
+		else
+			res = remove_persistent_info(technology, identifier);
+
+		if (res < 0)
+			return __connman_error_failed(msg, -res);
 	} else
 		return __connman_error_invalid_property(msg);
 
@@ -1209,6 +1889,46 @@ void __connman_technology_notify_regdom_by_device(struct connman_device *device,
 	connman_technology_regdom_notify(technology, alpha2);
 }
 
+int __connman_technology_set_p2p_go(DBusMessage *msg, const char *ident, const char *passphrase)
+{
+	struct connman_technology *technology;
+	GSList *tech_drivers;
+	int result = 0;
+	int err;
+
+	technology = technology_find(CONNMAN_SERVICE_TYPE_P2P);
+
+	DBG("technology %p", technology);
+
+	if (!technology)
+		return -EINVAL;
+
+	if (strlen(ident) < 1 || strlen(passphrase) < 1){
+		ident = NULL;
+		passphrase = NULL;
+	}
+
+	for (tech_drivers = technology->driver_list; tech_drivers;
+			tech_drivers = g_slist_next(tech_drivers)) {
+		struct connman_technology_driver *driver = tech_drivers->data;
+
+		if (!driver || !driver->set_p2p_go)
+			continue;
+
+		err = driver->set_p2p_go(msg, technology, ident, passphrase);
+
+		if (result == -EINPROGRESS)
+			continue;
+
+		if (err == -EINPROGRESS || err == 0) {
+			result = err;
+			continue;
+		}
+	}
+
+	return 0;
+}
+
 static DBusMessage *scan(DBusConnection *conn, DBusMessage *msg, void *data)
 {
 	struct connman_technology *technology = data;
@@ -1276,6 +1996,22 @@ static DBusMessage *cancel_wps(DBusConnection *conn, DBusMessage *msg, void *dat
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *cancel_p2p(DBusConnection *conn, DBusMessage *msg, void *data)
+{
+	struct connman_technology *technology = data;
+	int err;
+
+	if (technology->type != CONNMAN_SERVICE_TYPE_P2P &&
+				!technology->enabled)
+		return __connman_error_failed(msg, EOPNOTSUPP);
+
+	err = __connman_device_request_cancel_p2p(technology->type);
+	if (err < 0)
+		return __connman_error_failed(msg, -err);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static void reply_interface_properties(struct connman_device *device, void *user_data)
 {
 	DBusMessage *msg = user_data;
@@ -1321,6 +2057,48 @@ static void reply_interface_properties(struct connman_device *device, void *user
 	dbus_message_unref(msg);
 }
 
+static DBusMessage *get_interface_properties(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct connman_technology *technology = user_data;
+	DBusMessageIter iter;
+	GSList *list;
+	char *interface = NULL;
+
+	if (!dbus_message_iter_init(msg, &iter))
+		return __connman_error_invalid_arguments(msg);
+
+	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &interface);
+
+	if (!interface)
+		return __connman_error_invalid_arguments(msg);
+
+	struct connman_device *device = NULL;
+
+	for (list = technology->device_list; list; list = list->next) {
+		struct connman_device *current_device = list->data;
+		const char *iface = connman_device_get_interface(current_device);
+
+		if (g_strcmp0(iface, interface) == 0) {
+			device = current_device;
+			break;
+		}
+	}
+
+	if (!device)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_ref(msg);
+
+	connman_device_request_signal_info(device, reply_interface_properties, msg);
+
+	return NULL;
+}
+
+
 static const GDBusMethodTable technology_methods[] = {
 	{ GDBUS_DEPRECATED_METHOD("GetProperties",
 			NULL, GDBUS_ARGS({ "properties", "a{sv}" }),
@@ -1333,6 +2111,11 @@ static const GDBusMethodTable technology_methods[] = {
 			GDBUS_ARGS({ "pin", "s" }),
 			NULL, start_wps) },
 	{ GDBUS_METHOD("CancelWPS", NULL, NULL, cancel_wps) },
+	{ GDBUS_METHOD("CancelP2P", NULL, NULL, cancel_p2p) },
+	{ GDBUS_ASYNC_METHOD("GetInterfaceProperties",
+			GDBUS_ARGS({ "interface", "s" }),
+			GDBUS_ARGS({ "properties", "a{sv}"}),
+			get_interface_properties) },
 	{ },
 };
 
@@ -1416,6 +2199,7 @@ static void technology_put(struct connman_technology *technology)
 	g_free(technology->tethering_ident);
 	g_free(technology->tethering_passphrase);
 	g_free(technology->tethering_ipaddress);
+	g_free(technology->p2p_identifier);
 	g_free(technology);
 }
 
@@ -1723,7 +2507,13 @@ int __connman_technology_add_device(struct connman_device *device)
 		__connman_device_disable(device);
 
 done:
-	technology->device_list = g_slist_prepend(technology->device_list,
+	if (connman_setting_get_bool("SupportP2P0Interface") == TRUE &&
+					g_strcmp0(connman_device_get_string(device, "Interface"),
+						connman_option_get_string("WiFiDevice")) == 0)
+		technology->device_list = g_slist_append(technology->device_list,
+								device);
+	else
+		technology->device_list = g_slist_prepend(technology->device_list,
 								device);
 
 	return 0;
@@ -1774,6 +2564,8 @@ int __connman_technology_enabled(enum connman_service_type type)
 		return 0;
 	}
 
+//	__connman_device_get_driver_info(technology->type);
+
 	return technology_enabled(technology);
 }
 
diff --git a/src/util.c b/src/util.c
index 03b14cdc..78a312ca 100644
--- a/src/util.c
+++ b/src/util.c
@@ -102,3 +102,108 @@ unsigned int __connman_util_random_delay_ms(unsigned int secs)
        __connman_util_get_random(&rand);
        return rand % (secs * 1000);
 }
+
+char *__connman_util_insert_colon_to_mac_addr(const char *mac_addr)
+{
+	char *result = g_try_malloc(18);
+	int i;
+
+	if (!mac_addr || strlen(mac_addr) < 12) {
+		g_free(result);
+		return NULL;
+	}
+
+	for (i=0; i<6; i++) {
+		result[i*3] = mac_addr[i*2];
+		result[i*3+1] = mac_addr[i*2+1];
+	}
+
+	result[2] = ':';
+	result[5] = ':';
+	result[8] = ':';
+	result[11] = ':';
+	result[14] = ':';
+	result[17] = '\0';
+
+	DBG("before: %s, after: %s", mac_addr, result);
+
+	return result;
+}
+
+char *__connman_util_remove_colon_from_mac_addr(const char *mac_addr)
+{
+	char *result;
+	int i=0;
+
+	if(mac_addr == NULL || strlen(mac_addr) != 17)
+		return NULL;
+
+	result = g_try_malloc(13);
+	if(result == NULL)
+		return NULL;
+
+	for(i=0; i<6; i++) {
+		result[i*2] = mac_addr[i*3];
+		result[i*2+1] = mac_addr[i*3+1];
+	}
+	result[12] = '\0';
+
+	return result;
+}
+
+
+void __connman_util_byte_to_string(unsigned char *src, char *dest, int len)
+{
+	int i=0;
+
+	for(i=0; i<len; i++) {
+		snprintf(&dest[i*2], 3, "%02x", src[i]);
+	}
+
+	dest[len*2] = '\0';
+}
+
+char *__connman_util_mac_binary_to_string(const unsigned char binmac[6]){
+	return g_strdup_printf("%02x:%02x:%02x:%02x:%02x:%02x",
+	                       binmac[0], binmac[1], binmac[2],
+	                       binmac[3], binmac[4], binmac[5]);
+}
+
+char *__connman_util_mac_binary_to_string_no_colon(const unsigned char binmac[6]){
+	return g_strdup_printf("%02x%02x%02x%02x%02x%02x",
+	                       binmac[0], binmac[1], binmac[2],
+	                       binmac[3], binmac[4], binmac[5]);
+}
+
+char *__connman_util_ipaddr_binary_to_string(const unsigned char addr[4]){
+	return g_strdup_printf("%u.%u.%u.%u",
+	                       addr[0], addr[1], addr[2], addr[3]);
+}
+
+static unsigned char char_to_hex_value(char c)
+{
+	c = toupper(c);
+
+	if (c >= 'A')
+		return c - 'A' + 10;
+	else
+		return c - '0';
+}
+
+static unsigned char char2_to_hex_value(const char c[2])
+{
+	return char_to_hex_value(c[0]) * 16 + char_to_hex_value(c[1]);
+}
+
+void __connman_util_mac_string_to_binary(const char* mac_string, unsigned char binmac[6])
+{
+	if (mac_string == NULL || strlen(mac_string) != 17)
+		return;
+
+	binmac[0] = char2_to_hex_value(mac_string);
+	binmac[1] = char2_to_hex_value(mac_string+3);
+	binmac[2] = char2_to_hex_value(mac_string+6);
+	binmac[3] = char2_to_hex_value(mac_string+9);
+	binmac[4] = char2_to_hex_value(mac_string+12);
+	binmac[5] = char2_to_hex_value(mac_string+15);
+}
