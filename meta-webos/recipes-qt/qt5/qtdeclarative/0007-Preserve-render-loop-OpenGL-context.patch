From 5e4c42f7d39043f88046bfce63a39ee03d965116 Mon Sep 17 00:00:00 2001
From: Jani Hautakangas <jani.hautakangas@lge.com>
Date: Sat, 28 Mar 2015 16:03:14 +0200
Subject: [PATCH] Preserve render loop OpenGL context

:Release Notes:
Preserve render loop OpenGL context

:Detailed Notes:
Add environment variable option to control
GUI thread render loop OpenGL context lifetime.

QSG_RENDER_LOOP_PRESERVE_OPENGL_CONTEXT

By default OpenGL context destroyed when all windows have
been closed but with this option enabled context is
destroyed only when application is closed. This option
is used by WAM.

:Testing Performed:

:QA Notes:

:Issues Addressed:
[DRD-6157] Stability: WebAppMgr crashes at multiple locations

Change-Id: Ic38ef5b759e2a678a6003b450c44a15ce411c6af
---
 src/quick/scenegraph/qsgrenderloop.cpp | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/quick/scenegraph/qsgrenderloop.cpp b/src/quick/scenegraph/qsgrenderloop.cpp
index 05f635cf1..597c29e48 100644
--- a/src/quick/scenegraph/qsgrenderloop.cpp
+++ b/src/quick/scenegraph/qsgrenderloop.cpp
@@ -88,6 +88,9 @@ extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize &size, bool alpha_
 DEFINE_BOOL_CONFIG_OPTION(qmlNoThreadedRenderer, QML_BAD_GUI_RENDER_LOOP);
 DEFINE_BOOL_CONFIG_OPTION(qmlForceThreadedRenderer, QML_FORCE_THREADED_RENDERER); // Might trigger graphics driver threading bugs, use at own risk
 #endif
+
+static bool qsg_preserve_opengl_context = qgetenv("QSG_RENDER_LOOP_PRESERVE_OPENGL_CONTEXT").toInt();
+
 QSGRenderLoop *QSGRenderLoop::s_instance = nullptr;
 
 QSGRenderLoop::~QSGRenderLoop()
@@ -283,6 +286,9 @@ QSGGuiThreadRenderLoop::QSGGuiThreadRenderLoop()
     }
     sg = QSGContext::createDefaultContext();
     rc = sg->createRenderContext();
+
+    if (gl && qsg_preserve_opengl_context)
+        delete gl;
 }
 
 QSGGuiThreadRenderLoop::~QSGGuiThreadRenderLoop()
@@ -338,9 +344,11 @@ void QSGGuiThreadRenderLoop::windowDestroyed(QQuickWindow *window)
     d->cleanupNodesOnShutdown();
     if (m_windows.size() == 0) {
         rc->invalidate();
-        delete gl;
-        gl = nullptr;
-    } else if (gl && window == gl->surface() && current) {
+        if (!qsg_preserve_opengl_context) {
+            delete gl;
+            gl = nullptr;
+        }
+    } else if (gl && window == gl->surface() && current && !qsg_preserve_opengl_context) {
         gl->doneCurrent();
     }
 
